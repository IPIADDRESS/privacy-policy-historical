<!--The following is the downloaded HTML source of the barkshop.com privacy policy that was archived on 2015-10-18.
 Please check the original snapshot on the Wayback Machine (https://web.archive.org/web/20151018120832id_/https%3A//barkshop.com/privacy) for the most accurate reproduction.-->

<!DOCTYPE html><html id="ng-app" ng-app="app" ng-class="{'hide-overflow': modal.isOpen()}" ng-controller="MainController" ng-keyup="keyUp($event)"><head>
<script src="https://js-agent.newrelic.com/nr-768.min.js"></script><script async="" charset="utf-8" src="//v2.zopim.com/?31hwtwabcV8aIaGpPCG4YPfC8ycOymAn" type="text/javascript"></script><script async="" src="//www.googletagmanager.com/gtm.js?id=GTM-MVZ86D"></script><script type="text/javascript" async="" src="//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js"></script><script type="text/javascript">window.NREUM||(NREUM={});NREUM.info={"beacon":"bam.nr-data.net","errorBeacon":"bam.nr-data.net","licenseKey":"eb599a375b","applicationID":"11516001","transactionName":"dgtbEhQLXlRRQh5EVlIBRkkWFltOVVNI","queueTime":12,"applicationTime":193,"agent":"js-agent.newrelic.com/nr-768.min.js"}</script>
<script type="text/javascript">window.NREUM||(NREUM={}),__nr_require=function(e,n,t){function r(t){if(!n[t]){var o=n[t]={exports:{}};e[t][0].call(o.exports,function(n){var o=e[t][1][n];return r(o||n)},o,o.exports)}return n[t].exports}if("function"==typeof __nr_require)return __nr_require;for(var o=0;o<t.length;o++)r(t[o]);return r}({QJf3ax:[function(e,n){function t(e){function n(n,t,a){e&&e(n,t,a),a||(a={});for(var u=c(n),f=u.length,s=i(a,o,r),p=0;f>p;p++)u[p].apply(s,t);return s}function a(e,n){f[e]=c(e).concat(n)}function c(e){return f[e]||[]}function u(){return t(n)}var f={};return{on:a,emit:n,create:u,listeners:c,_events:f}}function r(){return{}}var o="nr@context",i=e("gos");n.exports=t()},{gos:"7eSDFh"}],ee:[function(e,n){n.exports=e("QJf3ax")},{}],3:[function(e,n){function t(e){return function(){r(e,[(new Date).getTime()].concat(i(arguments)))}}var r=e("handle"),o=e(1),i=e(2);"undefined"==typeof window.newrelic&&(newrelic=window.NREUM);var a=["setPageViewName","addPageAction","setCustomAttribute","finished","addToTrace","inlineHit","noticeError"];o(a,function(e,n){window.NREUM[n]=t("api-"+n)}),n.exports=window.NREUM},{1:12,2:13,handle:"D5DuLP"}],gos:[function(e,n){n.exports=e("7eSDFh")},{}],"7eSDFh":[function(e,n){function t(e,n,t){if(r.call(e,n))return e[n];var o=t();if(Object.defineProperty&&Object.keys)try{return Object.defineProperty(e,n,{value:o,writable:!0,enumerable:!1}),o}catch(i){}return e[n]=o,o}var r=Object.prototype.hasOwnProperty;n.exports=t},{}],D5DuLP:[function(e,n){function t(e,n,t){return r.listeners(e).length?r.emit(e,n,t):void(r.q&&(r.q[e]||(r.q[e]=[]),r.q[e].push(n)))}var r=e("ee").create();n.exports=t,t.ee=r,r.q={}},{ee:"QJf3ax"}],handle:[function(e,n){n.exports=e("D5DuLP")},{}],XL7HBI:[function(e,n){function t(e){var n=typeof e;return!e||"object"!==n&&"function"!==n?-1:e===window?0:i(e,o,function(){return r++})}var r=1,o="nr@id",i=e("gos");n.exports=t},{gos:"7eSDFh"}],id:[function(e,n){n.exports=e("XL7HBI")},{}],G9z0Bl:[function(e,n){function t(){var e=d.info=NREUM.info,n=f.getElementsByTagName("script")[0];if(e&&e.licenseKey&&e.applicationID&&n){c(p,function(n,t){n in e||(e[n]=t)});var t="https"===s.split(":")[0]||e.sslForHttp;d.proto=t?"https://":"http://",a("mark",["onload",i()]);var r=f.createElement("script");r.src=d.proto+e.agent,n.parentNode.insertBefore(r,n)}}function r(){"complete"===f.readyState&&o()}function o(){a("mark",["domContent",i()])}function i(){return(new Date).getTime()}var a=e("handle"),c=e(1),u=window,f=u.document;e(2);var s=(""+location).split("?")[0],p={beacon:"bam.nr-data.net",errorBeacon:"bam.nr-data.net",agent:"js-agent.newrelic.com/nr-768.min.js"},d=n.exports={offset:i(),origin:s,features:{}};f.addEventListener?(f.addEventListener("DOMContentLoaded",o,!1),u.addEventListener("load",t,!1)):(f.attachEvent("onreadystatechange",r),u.attachEvent("onload",t)),a("mark",["firstbyte",i()])},{1:12,2:3,handle:"D5DuLP"}],loader:[function(e,n){n.exports=e("G9z0Bl")},{}],12:[function(e,n){function t(e,n){var t=[],o="",i=0;for(o in e)r.call(e,o)&&(t[i]=n(o,e[o]),i+=1);return t}var r=Object.prototype.hasOwnProperty;n.exports=t},{}],13:[function(e,n){function t(e,n,t){n||(n=0),"undefined"==typeof t&&(t=e?e.length:0);for(var r=-1,o=t-n||0,i=Array(0>o?0:o);++r<o;)i[r]=e[n+r];return i}n.exports=t},{}]},{},["G9z0Bl"]);</script>
<title>Privacy Policy | BarkShop</title>


<meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport">
<meta content="1532250563653729" property="fb:app_id">
<link rel="stylesheet" media="all" href="//dv4pc7nwcrrvy.cloudfront.net/assets/application-92c5e136bd55de9cb29576a062f8b947.css">
<link rel="stylesheet" media="screen" href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
<link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
<meta name="apple-mobile-web-app-title" content="BarkShop">
<link rel="icon" type="image/png" href="/favicon-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="/favicon-160x160.png" sizes="160x160">
<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
<meta name="msapplication-TileColor" content="#36ade7">
<meta name="msapplication-TileImage" content="/mstile-144x144.png">
<meta name="application-name" content="BarkShop">
<meta name="csrf-param" content="authenticity_token">
<meta name="csrf-token" content="/40g1MpWicqyKAoL0ChDWHtJnJA9ve03BiqymiEPp1SZofuqeBcRU96jGn7ol4jDISnaAzAj9E+uUW1D6VPcEA==">
<script src="//dv4pc7nwcrrvy.cloudfront.net/assets/application-4004f74c338d639f0ce0b6a4838e6f03.js"></script>
<script type="text/javascript">
  (function(f,b){if(!b.__SV){var a,e,i,g;window.mixpanel=b;b._i=[];b.init=function(a,e,d){function f(b,h){var a=h.split(".");2==a.length&&(b=b[a[0]],h=a[1]);b[h]=function(){b.push([h].concat(Array.prototype.slice.call(arguments,0)))}}var c=b;"undefined"!==typeof d?c=b[d]=[]:d="mixpanel";c.people=c.people||[];c.toString=function(b){var a="mixpanel";"mixpanel"!==d&&(a+="."+d);b||(a+=" (stub)");return a};c.people.toString=function(){return c.toString(1)+".people (stub)"};i="disable track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");for(g=0;g<i.length;g++)f(c,i[g]);b._i.push([a,e,d])};b.__SV=1.2;a=f.createElement("script");a.type="text/javascript";a.async=!0;a.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";e=f.getElementsByTagName("script")[0];e.parentNode.insertBefore(a,e)}})(document,window.mixpanel||[]);mixpanel.init("a501e8bb04e9293b919904a4af5a9e07");
  </script>


<script type="text/javascript">
  (function(d) {   
    var e = d.createElement('script');   
    e.src = d.location.protocol + '//bounceexchange.com/tag/1168/i.js';    
    e.async = true;    
    d.getElementsByTagName("head")[0].appendChild(e);    
  }(document));
</script><script src="https://bounceexchange.com/tag/1168/i.js" async=""></script>

<script src="//cdn.optimizely.com/js/2797290298.js"></script>

</head>

<body>
<script type="text/javascript">
  window.dataLayer = [];
  window.track();
</script>
<!-- Google Tag Manager -->
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-MVZ86D"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MVZ86D');</script>
<!-- End Google Tag Manager -->

<div class="ng-hide" id="modal-wrapper" ng-controller="ModalController" ng-show="modal.isOpen()">
<div id="mask" ng-click="hideModal()"></div>
<div id="modal" ng-style="{'top' : (isMobile ? 0 : modal.cartOffset() + 60) + 'px'}">
<div id="roadblock" class="account-flow ng-hide" ng-show="modal.stateOpen('roadblock')" ng-controller="RoadblockController">
  <header>
    <a ng-click="hideModal()">
      <i class="fa fa-angle-left"></i>
    </a>
    <h2>Checkout</h2>
  </header>
  <img src="//dv4pc7nwcrrvy.cloudfront.net/assets/checkout-doodle-1-f63e7daae3742fa5cdeb035b2f530e0f.png">
  <h6>We know each other?</h6>
  <h3>Just pop in your email<br>and we'll work out the rest ...</h3>
  <form name="roadblockForm" novalidate="" ng-submit="checkUser(email)">
    <div>
      <input id="roadblock-focus" name="email" placeholder="woof@barkshop.com" ng-model="email" type="email" required="true" ng-model-options="{ updateOn: 'default blur' }">
    </div>
    <div>
      <label for="email">EMAIL ADDRESS</label>
    </div>
  <div class="btn-bar">
    <button class="btn left back" type="button" ng-click="modal.setState('cart')">
      <span>
         Back to Cart
      </span>
    </button>
    <button class="btn right cta" type="submit" ng-disabled="roadblockForm.$invalid||isLoading" ng-class="{'loading': isLoading}">
      Next
    </button> 
  </div>
  </form>
</div>

<div id="login" class="account-flow ng-hide" ng-show="modal.stateOpen('login')" ng-controller="LoginController">
  <header>
    <a ng-click="hideModal()">
      <i class="fa fa-angle-left"></i>
    </a>
    <h2>Checkout</h2>
  </header>
  <img src="//dv4pc7nwcrrvy.cloudfront.net/assets/checkout-doodle-2-56374735e79a0d3839319270ea09b430.png">
  <h6>Did you change your hair?</h6>
  <h3>Great to see you again!</h3>
  <form name="loginForm" ng-submit="loginUser(password)" novalidate="">
    <div class="field">
      <input id="login-focus" name="password" ng-model="password" type="password" required="true" ng-change="touched('password')">
      <div class="error-wrap" ng-show="loginForm.password.$dirty &amp;&amp; loginForm.password.$invalid">
        <span class="error" ng-show="loginForm.password.$error.required">Required</span>
        <span class="error" ng-show="loginForm.password.$error.custom">{{ error_msg.password }}</span>
      </div>
      <label for="password" ng-hide="loginForm.password.$dirty &amp;&amp; loginForm.password.$invalid">Password</label>
    </div>
    <a href="https://barkbox.com/users/password/new">Forgot Password?</a>
    <!-- <a ng-click="confirmReset()">Forgot Password?</a> -->
  <div class="btn-bar">
    <button class="btn left back" type="button" ng-click="modal.setState('roadblock')">
      <span>Back</span>
    </button>
    <button class="btn right cta" type="submit" ng-disabled="addressForm.$invalid||isLoading" ng-class="{'loading':isLoading}">
      <span>Login</span>
    </button>
  </div>
  </form>
</div>

<div id="register" class="account-flow ng-hide" ng-show="modal.stateOpen('register')" ng-controller="RegisterController">
  <header>
    <a ng-click="hideModal()">
      <i class="fa fa-angle-left"></i>
    </a>
    <h2>Checkout</h2>
  </header>
  <h6>Hey noob!</h6>
  <h3>Let’s get to know each other first...</h3>
  <form name="registerForm" ng-submit="registerUser(fname, lname, password)" novalidate="">
    <div class="row">
      <div class="left">
      	<input id="register-focus" name="fname" ng-model="fname" required="true" ng-model-options="{updateOn:'default blur'}" ng-change="touched('fname')">
      	<div class="error-wrap" ng-show="registerForm.fname.$dirty &amp;&amp; registerForm.fname.$invalid">
          <span class="error" ng-show="registerForm.fname.$error.required">Required</span>
          <span class="error" ng-show="registerForm.fname.$error.custom">{{ error_msg.fname }}</span>
      	</div>
      	<label for="fname" ng-hide="registerForm.fname.$dirty &amp;&amp; registerForm.fname.$invalid">First Name</label>
      </div>
      <div class="right">
      	<input name="lname" ng-model="lname" required="true" ng-model-options="{updateOn:'default blur'}" ng-change="touched('lname')">
      	<div class="error-wrap" ng-show="registerForm.lname.$dirty &amp;&amp; registerForm.lname.$invalid">
          <span class="error" ng-show="registerForm.lname.$error.required">Required</span>
          <span class="error" ng-show="registerForm.lname.$error.custom">{{ error_msg.lname }}</span>
      	</div>
      	<label for="lname" ng-hide="registerForm.lname.$dirty &amp;&amp; registerForm.lname.$invalid">Last Name</label>
      </div>
    </div>
    <div class="row">
      <input name="password" ng-model="password" type="password" required="true" ng-model-options="{updateOn:'default blur'}" ng-change="touched('password')">
      <div class="error-wrap" ng-show="registerForm.password.$dirty &amp;&amp; registerForm.password.$invalid">
        <span class="error" ng-show="registerForm.password.$error.required">Required</span>
        <span class="error" ng-show="registerForm.password.$error.custom">{{ error_msg.password }}</span>
      </div>
      <label for="password" ng-hide="registerForm.password.$dirty &amp;&amp; registerForm.password.$invalid">Password</label>
    </div>
  <div class="btn-bar">
    <button class="btn left back" type="button" ng-click="modal.setState('roadblock')">
        Back
    </button>
    <button class="btn right cta" type="submit" ng-disabled="registerForm.$invalid||isLoading" ng-class="{'loading': isLoading}">
      Sign Up
    </button>
  </div>
  </form>
</div>

<div id="cart" class="ng-hide" ng-show="modal.stateOpen('cart')" ng-controller="CartController">
  <div class="header">
    <div class="back" ng-click="hideModal()">
      <i class="fa fa-angle-left"></i>
    </div>
    <h3>Cart</h3>
    <div class="price">{{ cart.quote.subtotal | currency:"$" }}</div>
    <span class="loading ng-hide" ng-show="cart.loading"></span>
    <div class="cart-banner free-shipping" ng-show="!!cart.freeShippingMinimum &amp;&amp; cart.quote.subtotal < cart.freeShippingMinimum &amp;&amp; cart.shipping_country != 'CA'">
      You are <em>{{(cart.freeShippingMinimum - cart.quote.subtotal) | currency:"$" }}</em> away from <em>FREE</em> shipping!
    </div>
    <div class="cart-banner free-shipping" ng-show="!!cart.freeShippingMinimum &amp;&amp; cart.quote.subtotal >= cart.freeShippingMinimum &amp;&amp; cart.shipping_country != 'CA'">
      Arf Arf Aroooo! <em>FREE</em> shipping!
    </div>
  </div>
  <div ng-repeat="(key, value) in cart.errors">
    <div ng-switch="key">
      <span class="alert" ng-switch-when="limited_stock">
        Due to limited stock, we had to modify your order.
        <h6 ng-repeat="message in value">
          {{message}}
        </h6>
      </span>
      <span class="alert" ng-switch-when="out_of_stock">
        Looks like we ran out of something
        <h6 ng-repeat="message in value">
          {{message}}
        </h6>
      </span>
    </div>
  </div>
  <div class="cart-info">  
    <div class="cart-item" ng-repeat="item in cart.items">
      <a ng-href="{{cart.itemUrl(item.id)}}" target="_self">
        <img ng-src="{{(item.grid_images.length > 0) ? item.grid_images[0].original_url : ''}}">
      </a>
      <div class="cart-item-count">
        <button ng-click="incrementQuantity(item, -1)" class="cart-btn" ng-disabled="cart.loading" ng-class="{'hidden': (item.promotion_action_id)}">-</button>
        <span>{{ item.quantity }}</span>
        <button ng-click="incrementQuantity(item, 1)" class="cart-btn" ng-disabled="cart.loading" ng-class="{'hidden': item.promotion_action_id || (item.purchase_limit != null &amp;&amp; item.quantity >= item.purchase_limit)}">+</button>
      </div>
      <h5>{{ item.name }}</h5>
      <span class="variants">{{ cart.variantDisplayString(item.id) }}</span>
      <span class="price {{(cart.itemPrice(item.id) == 0) ? 'free' : ''}}">{{(cart.itemPrice(item.id) == 0) ? 'FREE' : (cart.itemPrice(item.id) | currency:"$")}}</span>
    </div>
  </div>
  <div ng-hide="!isMobile">
    <div class="btn-bar">
      <h4 class="total">
        Total
        <div class="price">{{ cart.quote.subtotal | currency:"$"}}</div>
      </h4>
      <button class="btn left back" ng-click="hideModal()">
        <span>Continue Shopping</span>
      </button>
      <button class="btn right cta" ng-click="toCheckout()" ng-disabled="cart.items.length < 1">
        <span>Checkout</span>
      </button>
    </div>
  </div>
    <div id="cart-suggestions">
    <script type="text/javascript">
      window.cart_suggestions = [{"id":3615,"barkbox_id":4666,"sku":"203222","name":"Hyper Squawker Jack","slug":"hyper-squawker-jack-green","description":"Ready to throw down on the ground? The Hyper Squawker Jack is. It's three-pronged shape creates unpredictable bouncing that'll drive your pup bonkers. And once it finds its way into canine jaws, the Jack emits silly noises to further excite your pup!","bark_labs":"---\r\n###Official Tester\r\n##Chicken Little\r\n---\r\n- Built for indoor and outdoor play\r\n- Made of durable TPR and nylon\r\n- Multi-textured for chewing pleasure","bark_specs":"","tagline":"Rumble \u0026 Tumble fun!","size":"medium","color":"green","price":10.0,"quantity_allowed":157,"flavor":null,"quantity_allowed_all_variants":157,"purchase_limit":null,"shareable":false,"attributes_string":"medium, green","url":"/items/hyper-squawker-jack-green","display_price":10.0,"viewability":"full","grid_images":[{"original_url":"https://s3.amazonaws.com/barkshop_production/items/9fd10f2d848418b88f3a3c02cff99ad5c2860bdb.jpg?1429634183","is_dark":false}],"badges":[{"name":"Heavy Chewer","image_url":"https://s3.amazonaws.com/barkshop_production/items/bde734caa946e6d625c58a575dced6a51d659b2c.png?1412177897"},{"name":"For mid sized pooches","image_url":"https://s3.amazonaws.com/barkshop_production/items/f93ab835a78aece8a25a293306e6cebcc1a92604.png?1412177986"},{"name":"Workout Friendly","image_url":"https://s3.amazonaws.com/barkshop_production/items/ecf2d3aef8cb7863baa024d5336128485df657b9.png?1412178154"}]},{"id":3851,"barkbox_id":5882,"sku":"203739","name":"3-Play Hippo","slug":"3-play-hippo-mini-fucshia","description":"Is your pup ready for Africa's most ferocious beast? With this hippo toy, she will be. Made of super-durable post-consumer material by Cycle Dog, this toy simulates how incredibly difficult it will be for your dog to chew on a full-sized hippopotamus. Its belly hides treats to reward your dog for a job well done, and it even floats high in the water (for realism!).\r\n","bark_labs":"---\r\n###Official Tester\r\n##Bowie\r\n---\r\n- Extreme buoyancy makes it easy for dogs to see and retrieve in water\r\n- Squeaks when chewed, just like a real 3,300 lb hippo\r\n- Mini size measures 4″x3″x3″, Medium 7″x4″x4″\r\n- Available in Fuchsia and Blue colors","bark_specs":"","tagline":"Hippopotamus: the most dangerous game","size":"mini","color":"fuchsia","price":10.0,"quantity_allowed":48,"flavor":null,"quantity_allowed_all_variants":229,"purchase_limit":null,"shareable":false,"attributes_string":"mini, fuchsia","url":"/items/3-play-hippo-mini-fucshia","display_price":"10.00 - $15.00","viewability":"full","grid_images":[{"original_url":"https://s3.amazonaws.com/barkshop_production/items/f00ad2c0dfd9f7efff0f3b835e61a79b7dabfe79.jpg?1443547468","is_dark":false}],"badges":[{"name":"Puppy Playtime Friendly","image_url":"https://s3.amazonaws.com/barkshop_production/items/f1e05f83b50b219b0ee68c65812982d1f6589b51.png?1412177663"},{"name":"Heavy Chewer","image_url":"https://s3.amazonaws.com/barkshop_production/items/bde734caa946e6d625c58a575dced6a51d659b2c.png?1412177897"},{"name":"For small pups","image_url":"https://s3.amazonaws.com/barkshop_production/items/1a8f308cd925826cd4db09e943489ad3aeb5d9a4.png?1412178038"}]},{"id":194,"barkbox_id":669,"sku":"200360","name":"Urban Stick","slug":"urban-stick-s","description":"Into the wood chipper, stick. There's a new stick in town and his name is Urban. (no, not Karl Urban) The dedicated designers at Bionic ® have come up with the perfect stick for chewing, throwing, fetching and tugging, and unlike its archaic ancestor, it is long-lasting and splinter-free. You can also hide treats or pack peanut butter into the opening and drive your puppy bonkers; afterwards, just throw it in the dishwasher for easy cleaning. Sound great? Go! Go get the stick!","bark_labs":"---\r\n###Official Tester\r\n##Small Talk\r\n---\r\n- No sharp edges\r\n- Contoured ridges for gripping\r\n- Floats in water\r\n- Comes in 2 different sizes - for all dogs to enjoy\r\n","bark_specs":null,"tagline":"The Stick of the Future","size":"small","color":null,"price":9.0,"quantity_allowed":153,"flavor":null,"quantity_allowed_all_variants":153,"purchase_limit":null,"shareable":true,"attributes_string":"small","url":"/items/urban-stick-s","display_price":"9.00 - $12.00","viewability":"full","grid_images":[{"original_url":"https://s3.amazonaws.com/barkshop_production/items/9bfcc1ddc85fa545ca48b0239cb92589d516b3a5.jpg?1418687202","is_dark":false}],"badges":[]},{"id":133,"barkbox_id":850,"sku":"200393","name":"Duck Chew","slug":"duck-chew-12","description":"Combining all the savory flavor of rawhides with the chewiness of duck feet, this is one meaty hybrid your pup will go ducking crazy for. It's healthier and safer to chew than a rawhide, and less traumatizing to watch your puppy eat than real duck feet. The best of both worlds!","bark_labs":"---\r\n###Official Tester\r\n##Small Talk\r\n---\r\n- Chew come in two sizes 7\" and 12\"\r\n- 100% American made and sourced\r\n- Ingredients: rawhide, duck, natural caramel color, salt\r\n- Great for teeth, gums and happiness\r\n","bark_specs":"","tagline":"This meat stick tastes ducking good!","size":"12\"","color":null,"price":4.0,"quantity_allowed":482,"flavor":null,"quantity_allowed_all_variants":839,"purchase_limit":null,"shareable":false,"attributes_string":"12\"","url":"/items/duck-chew-12","display_price":"3.00 - $4.00","viewability":"full","grid_images":[{"original_url":"https://s3.amazonaws.com/barkshop_production/items/210d4651d8279df3416e1de4bc1a21812aca5a38.jpg?1426000809","is_dark":false}],"badges":[{"name":"All natural","image_url":"https://s3.amazonaws.com/barkshop_production/items/270446c3ccbc6c705dd160cfd48e30c73bc4c091.png?1412178060"},{"name":"Low Fat","image_url":"https://s3.amazonaws.com/barkshop_production/items/81901e3a32945b255b00c39aa96fa66c4b7d05fb.png?1412178245"}]},{"id":28,"barkbox_id":1487,"sku":"202458","name":"Hyper Pet K9 Kannon Ball Launcher","slug":"hyper-pet-k9-kannon-mini-ball-launcher","description":"\"On my mark: Load! Lift! Launch!\" The K9 Kannon Ball Launcher is the most fun you'll have with a gun and a dog since Duck Hunt. Give your shoulder a rest and play fetch the modern way; by just pulling your trigger finger. \"Fetch, Fido! And keep the change, ya furry animal.\"","bark_labs":"---\r\n###Official Tester\r\n##Kayla\r\n---\r\n- Launcher is fun and easy to use\r\n- Load a ball, pull back on the launcher, then pull the trigger\r\n- Pull!","bark_specs":"","tagline":"The game of fetch just got a whole lot more badass","size":"large","color":null,"price":25.0,"quantity_allowed":71,"flavor":null,"quantity_allowed_all_variants":72,"purchase_limit":null,"shareable":true,"attributes_string":"large","url":"/items/hyper-pet-k9-kannon-mini-ball-launcher","display_price":"19.00 - $25.00","viewability":"full","grid_images":[{"original_url":"https://s3.amazonaws.com/barkshop_production/items/208837d2392b2d93e861807407e2eb438c394fab.jpg?1412040360","is_dark":false}],"badges":[{"name":"Made in USA","image_url":"https://s3.amazonaws.com/barkshop_production/items/fe987d684960b30bca7b6e369ad144c57de94b55.png?1412177947"},{"name":"Workout Friendly","image_url":"https://s3.amazonaws.com/barkshop_production/items/ecf2d3aef8cb7863baa024d5336128485df657b9.png?1412178154"}]},{"id":4086,"barkbox_id":1842,"sku":"202723","name":"Snoop","slug":"snoop-medium-orange","description":"Dogs are terrible at non-Euclidean geometry. Fill this confounding puzzle toy with treats, and watch your pooch ponder the complexities of curved planes folding in on themselves. Designed by Planet Dog, this American made toy is sure to occupy for hours, unless your pup has better spatial reasoning than most small children.","bark_labs":"---\r\n###Official Tester\r\n##Hudson\r\n---\r\n- Flexible opening pops out for easy treat-filling  and cleaning\r\n- Fits a 2.5” ball inside, for days when your pup is acting a bit overconfident and needs the difficulty cranked up\r\n- Built for nuzzling and puzzling, not heavy chewing\r\n- Comes in Blue and Orange\r\n- 5” in diameter\r\n","bark_specs":"","tagline":"Is Your Dog Smarter Than A 5th Grader?\r\n","size":"medium","color":"orange","price":19.0,"quantity_allowed":79,"flavor":null,"quantity_allowed_all_variants":158,"purchase_limit":null,"shareable":false,"attributes_string":"medium, orange","url":"/items/snoop-medium-orange","display_price":19.0,"viewability":"full","grid_images":[{"original_url":"https://s3.amazonaws.com/barkshop_production/items/442fdc09a1f4ce2925f7453c1f729829c4da0c0b.jpg?1443469958","is_dark":false}],"badges":[{"name":"Puppy Playtime Friendly","image_url":"https://s3.amazonaws.com/barkshop_production/items/f1e05f83b50b219b0ee68c65812982d1f6589b51.png?1412177663"},{"name":"Made in USA","image_url":"https://s3.amazonaws.com/barkshop_production/items/fe987d684960b30bca7b6e369ad144c57de94b55.png?1412177947"},{"name":"Workout Friendly","image_url":"https://s3.amazonaws.com/barkshop_production/items/ecf2d3aef8cb7863baa024d5336128485df657b9.png?1412178154"}]},{"id":3635,"barkbox_id":4751,"sku":"203241","name":"BeneBone Bacon Flavor","slug":"benebone-bacon-flavor-small","description":"Thank dog - the chew we've all been wishing for has finally arrived! Pup owners know how easily their precious pooches can choke. Why risk it with a biscuit? The Benebone is engineered for safe and long lasting chewing.. Benebone chews are made in the USA and every sale supports animal welfare.","bark_labs":"---\r\n###Official Tester\r\n##Chloe\r\n---\r\n- Patented Curved Wishbone Design makes it easy to grab a bite\r\n- Real bacon flavor? Your pup won't be able to resist\r\n- Available in Small, Medium, and Large","bark_specs":"","tagline":"Savor safely with Benebone","size":"small","color":null,"price":10.0,"quantity_allowed":25041,"flavor":null,"quantity_allowed_all_variants":27803,"purchase_limit":null,"shareable":false,"attributes_string":"small","url":"/items/benebone-bacon-flavor-small","display_price":"10.00 - $18.00","viewability":"full","grid_images":[{"original_url":"https://s3.amazonaws.com/barkshop_production/items/32928c0ecac0f17d03424d70adfce62b6fb6e35e.jpg?1426708720","is_dark":false}],"badges":[{"name":"Heavy Chewer","image_url":"https://s3.amazonaws.com/barkshop_production/items/bde734caa946e6d625c58a575dced6a51d659b2c.png?1412177897"},{"name":"Made in USA","image_url":"https://s3.amazonaws.com/barkshop_production/items/fe987d684960b30bca7b6e369ad144c57de94b55.png?1412177947"},{"name":"BarkGood Approved","image_url":"https://s3.amazonaws.com/barkshop_production/items/173d276ecca1d1e50881c69c7714174b28812b79.png?1412178183"}]}]
    </script>
    <div class="header">
      <h4>Your pup might also love</h4>
    </div>
    <div class="cart-info">
      <div class="cart-item" ng-repeat="item in cartSuggestions | orderBy:'rank' | limitTo:3">
        <a ng-href="{{item.url}}" target="_self">
          <img ng-src="{{(item.grid_images.length > 0) ? item.grid_images[0].original_url : ''}}">
        </a>
        <div class="cart-item-name"><h5>{{ item.name }}</h5></div>
        <div class="cart-item-details">
          <span class="variants">{{ item.attributes_string }}</span>
          <span class="price">{{ item.price | currency:"$ "}}</span>
          <br>
          <button class="bs-btn-small" ng-click="addToCart(item)"> Add to Cart</button>
        </div>
      </div>
    </div>
  </div>

  <div ng-hide="isMobile">
    <div class="btn-bar">
      <h4 class="total">
        Total
        <div class="price">{{ cart.quote.subtotal | currency:"$"}}</div>
      </h4>
      <button class="btn left back" ng-click="hideModal()">
        <span>Continue Shopping</span>
      </button>
      <button class="btn right cta" ng-click="toCheckout()" ng-disabled="cart.items.length < 1">
        <span>Checkout</span>
      </button>
    </div>
  </div>
</div>

<div class="ng-hide" id="quick-view" ng-controller="QuickViewController" ng-show="modal.stateOpen('quick_view')">
<div class="exit fa fa-times-circle" ng-click="hideModal()"></div>
<div class="header" ng-show="isMobile">
<div class="back" ng-click="hideModal()">
<i class="fa fa-angle-left"></i>
</div>
<h3>{{selectedItem.name}}</h3>
</div>
<div id="item">
<div id="quick-view-wrapper">
<div class="column">
<h2 ng-hide="isMobile">{{selectedItem.name}}</h2>
<div class="tagline">{{selectedItem.tagline}}</div>
<div class="item-form">
<div class="price">{{ selectedItem.price | currency:"$ "}}</div>
<div class="bark-info" ng-if="selectedItem.bark_labs &amp;&amp; selectedItem.bark_specs">
<div class="tabs">
<div class="tab left" ng-class="{active: showSpecs == false}" ng-click="hideSpecsTab()">
BarkLabs
</div>
<div class="tab right" ng-class="{active: showSpecs == true}" ng-click="showSpecsTab()">
BarkSpecs
</div>
</div>
<div class="details">
<div class="labs" ng-bind-html="selectedItem.bark_labs | markdown" ng-class="{active: showSpecs == false}" ng-if="selectedItem.bark_labs"></div>
<div class="specs" ng-bind-html="selectedItem.bark_specs | markdown" ng-class="{active: showSpecs == true}" ng-if="selectedItem.bark_specs"></div>
</div>
</div>
<div class="bark-info" ng-if="selectedItem.bark_labs &amp;&amp; !selectedItem.bark_specs">
<div class="details">
<div class="labs active" ng-bind-html="selectedItem.bark_labs | markdown"></div>
</div>
</div>
<img class="grid ng-hide" ng-show="isMobile" ng-src="{{image()}}">
<div class="variant" ng-repeat="key in variables" ng-show="availableOptions[key].length > 1">
<label for="{{key}}">{{key}}:</label>
<select id="{{key}}" ng-change="selectionChanged(key)" ng-model="currentSelections[key]">
<option label="{{o.label}}" ng-repeat="o in availableOptions[key] | orderBy: optionOrdering" ng-selected="{{o.value == selectedItem[key]}}" value="{{o.value}}"></option>
</select>
</div>
<div class="qty" ng-hide="maxQuantity == 0">
<label for="qty">Quantity:</label>
<select id="qty" ng-model="quantity" ng-options="x as x for x in quantityList | limitTo : maxQuantity"></select>
</div>
<div class="sold-out ng-hide" ng-hide="itemExists(selectedItem)">
<h4>Unavailable</h4>
</div>
<div class="sold-out ng-hide" ng-show="itemExists(selectedItem) &amp;&amp; itemIsSoldOut(selectedItem)">
<h4>Sold out</h4>
</div>
<button class="bs-btn-large" ng-click="addItemToCart()" ng-hide="!itemExists(selectedItem) || itemIsSoldOut(selectedItem)">Add to Cart</button>
</div>
</div>
<div class="column">
<img class="grid" ng-hide="isMobile" ng-src="{{image()}}">
<div class="social" id="social-share" ng-show="selectedItem.shareable">
<a ng-click="facebook()">
<i class="fa fa-fw fa-facebook"></i>
</a>
<a ng-click="pinterest()">
<i class="fa fa-fw fa-pinterest"></i>
</a>
<a ng-click="twitter()">
<i class="fa fa-fw fa-twitter"></i>
</a>
<a href="mailto:?body=http://barkbox.com/items/{{selectedItem.slug}}&amp;subject={{selectedItem.name}}">
<i class="fa fa-fw fa-envelope-o"></i>
</a>
</div>
<div class="badge" ng-repeat="badge in selectedItem.badges" ng-show="selectedItem.badges.length > 1">
<img ng-src="{{badge.image_url}}">
</div>
</div>
</div>
</div>
</div>

</div>
</div>
<div class="" id="main">
<div id="toast"></div>
<header class="bs-shrink" ng-class="{shrink: scrollHeight > 150}" ng-controller="HeaderController">
<div id="top-nav">
<div id="logo">
<a href="/" target="_self">
<img alt="BarkShop" src="//dv4pc7nwcrrvy.cloudfront.net/assets/logo-black-cadd43f44e8770964e0793ffd2d9475b.png">
</a>
</div>
<div id="menu-toggle" ng-click="toggleMenu()">
<i class="fa fa-bars"></i>
</div>
<nav ng-class="{'menu-expanded':isMenuShowing}">
<ul>
<li>
<a target="_self" href="/collections">Collections</a>
<ul>
<li class="triangle">
<a target="_self" href="/collections/happy-howloween">Happy Howloween</a>
</li>
<li class="triangle">
<a target="_self" href="/collections/new-arrivals">Brand Wagging New </a>
</li>
<li class="triangle">
<a target="_self" href="/collections/buster-activity-mat">BUSTER ActivityMat</a>
</li>
<li class="triangle">
<a target="_self" href="/collections/french-bulldog">Viva La French (Bulldog)!</a>
</li>
<li class="triangle">
<a target="_self" href="/collections/must-ruv-dogs">Must Ruv Dogs</a>
</li>
<li class="triangle">
<a target="_self" href="/collections/ultimate-doggie-gift-guide">The Ultimate Doggie Gift Guide</a>
</li>
<li class="triangle">
<a target="_self" href="/collections/essentials">Essentials</a>
</li>
<li class="triangle">
<a target="_self" href="/collections/barkmade">BarkMade</a>
</li>
</ul>
</li>
<li>
<a target="_self" href="/categories">Categories</a>
<ul>
<li class="triangle">
<a target="_self" href="/categories/toys">Toys</a>
</li>
<li class="triangle">
<a target="_self" href="/categories/treats">Treats</a>
</li>
<li class="triangle">
<a target="_self" href="/categories/accessories">Accessories</a>
</li>
<li class="triangle">
<a target="_self" href="/categories/chews">Chews</a>
</li>
</ul>
</li>
<li>
<a target="_self" href="/boxes">Shop the Box</a>
<ul>
<li class="triangle">
<a target="_self" href="/collections/bedtime-story">Bedtime Story</a>
</li>
<li class="triangle">
<a target="_self" href="/collections/block-party">Block Party</a>
</li>
<li class="triangle">
<a target="_self" href="/collections/flea-circus">Flea Circus</a>
</li>
<li class="triangle">
<a target="_self" href="/collections/space-camp">Space Camp</a>
</li>
<li class="triangle">
<a target="_self" href="/collections/garden-party">Garden Party</a>
</li>
</ul>
</li>
</ul>
<ul>
<li class="chat">
<a class="ng-hide" ng-click="toggleChat()" ng-show="isMobile">
Chat with us
<div class="fa fa-comment-o"></div>
</a>
<a class="ng-hide fa fa-comment-o" ng-click="toggleChat()" ng-show="!isMobile"></a>
</li>
<li class="search" ng-hide="isMobile">
<a class="fa fa-search" ng-click="toggleSearch()"></a>
<ul class="ng-hide" ng-show="showSearch" off-click-filter="li.search" off-click-if="isTablet" off-click="showSearch = false">
<li class="triangle">
<input class="ng-hide" ng-change="search()" ng-model="term" ng-show="showSearch" placeholder="Search...">
</li>
<li class="result" ng-repeat="result in results">
<a href="{{result.url}}" target="_self">
<img ng-src="{{result.grid_images[0].original_url}}">
<div>
<h5>{{result.name}}</h5>
<span class="variants">{{result.attributes_string}}</span>
</div>
</a>
</li>
<li class="see-all" ng-show="results.length">
<a href="/items?q={{term}}" target="_self">See all results</a>
</li>
</ul>
</li>
<li>
<a ng-click="showModal('roadblock')">Login</a>
</li>
<li>
<a ng-click="modal.setState('cart')">
Cart
<span class="cart-count">
<span>{{ cart.count }}</span>
</span>
</a>
</li>
</ul>
</nav>
<a class="toggle-search fa fa-search" ng-click="toggleSearch()"></a>
<a class="cart-count" ng-click="modal.setState('cart')">
<span>{{ cart.count }}</span>
</a>
<form class="search-form ng-hide" ng-show="isMobile &amp;&amp; showSearch" ng-submit="submitSearch()">
<input ng-change="search()" ng-model="term" placeholder="Search...">
</form>
</div>
<div id="banner">
<p>
Free U.S. Shipping on all orders over
$35.00
plus free returns
</p>
</div>
</header>

<div id="privacy">
<div class="wrap">
<h3>Bark&amp;Co <br>Privacy Policy</h3>
<p>We respect the privacy of our users.  This Privacy Policy (“Policy”) describes our privacy practices concerning information collected in connection with the Bark &amp; Co family of websites, including without limitation BarkBox (located at <a traget="_blank" href="http://www.barkbox.com">www.barkbox.com</a>), BarkPost (including the BarkShop) (located at <a traget="_blank" href="http://www.barkpost.com">www.barkpost.com</a>), and BarkBuddy (<a traget="_blank" href="http://www.barkbuddy.com">www.barkbuddy.com</a>) (the “Sites”).  This Policy also describes our privacy practices with respect to any downloadable applications that Bark &amp; Co makes available, including without limitation BarkBuddy, BarkPost and BarkCam (the “Apps” and, together with the Sites, the “Platforms”).</p>
<p>This Policy is intended to explain the conditions under which Bark &amp; Co collects, uses, and discloses personal and other information in connection with the Platforms, and your rights in relation to that information.  By visiting our Sites, downloading or using our Apps, and/or using the features made available to you through the Platforms, you are agreeing to the terms of this Policy.</p>
<p>The personal and other information that we collect about you is controlled by Barkbox, Inc., which is headquartered in the United States at 221 Canal Street, Floor 6, New York, New York 10013.</p>
<h6>What personal and other information we collect about you</h6>
<p>Bark &amp; Co collects both “personal information” and “non-personal information” about Platform users.  For purposes of this Policy, “non-personal information” is information that Bark &amp; Co cannot directly associate with a specific person without the aid of additional information.  By contrast, “personal information,” is information such as a name or email address that Bark &amp; Co can directly associate with a specific person or entity without additional information.  When we combine non-personal information with personal information, we treat all of the combined information as personal information.</p>
<p><strong><em>Personal information.</em></strong>  You can visit the Sites and download many of the Apps without submitting any personal information.  However, in order to subscribe to our services or use many features of our Platforms, you will be required to provide personal information.  For example:</p>
<p class="shift"><em>Registration.</em>  In order to use some features of the Platforms, you must first subscribe to the applicable Bark &amp; Co service.  During registration, you are required to provide certain personal information (such as name, email address, shipping address, and credit card number and expiration date) in accordance with our terms of use.</p>
<p class="shift"><em>Facebook.</em> Certain applications, including BarkBuddy, may require you to log in through your Facebook account. If you link your Facebook account to a Bark &amp; Co service, this allows us to obtain information from those accounts (such as your friends or contacts). The information we obtain from those services often depends on your settings or their privacy policies, so be sure to check what those are.</p>
<p class="shift"><em>Orders.</em>  If you purchase a product or service from us, including through the BarkShop, we request certain personal information from you on our order form.  You must provide personal contact information (such as name, email address, and shipping address) and financial information (such as a credit card number and expiration date).</p>
<p class="shift"><em>Posted Content.</em>  Certain of our Platforms enable users to submit additional information that may be made accessible to other users or the general public.  To post content, you may be required to first register by providing information such as an email address, display name, and password.  Registrants also may choose to voluntarily provide additional information, including an avatar image, a biography, and/or information about their location.  And, of course, registrants may disclose personal and other information through their posted content.</p>
<p class="shift"><em>Feedback.</em>  Our online contact form also contains a “message” field through which you may submit additional personal information.</p>
<p>We may combine personal information collected through the Platforms with other information that we or third parties collect about you in other contexts—such as our communications with you via email or phone, or your customer service records.  We will treat such combined information as personal information and protect it in accordance with this Policy.</p>
<p><strong><em>Surveys, Contests, and Promotions.</em></strong>  From time to time, Bark &amp; Co may ask Platform users to participate in surveys, contests, or promotions.  Such surveys, contests, and promotions may be used to collect both personal and non-personal information.  Participation is completely voluntary, and you therefore have a choice whether or not to disclose your information.</p>
<p><strong><em>Log data.</em></strong>  When you use the Platforms, we automatically receive and record certain information from your computer (or other device) and your browser.  This may include such data as your IP address and domain name, the pages you visit or the features you use on the Platforms, the date and time of your visit, the files that you download, the URLs from the websites you visit before and after navigating to the Platforms, your software and hardware attributes (including device IDs), your general geographic location (e.g., your city, state, or metropolitan region), and certain cookie information (see below).  To obtain such information, we may use web logs or applications that recognize your computer or device and gather information about its online activity.</p>
<p><strong><em>Cookies.</em></strong>  We also use cookies in conjunction with the Platforms.  Cookies are small files that are stored on your computer or other device by your web browser.  A cookie allows the Platforms to recognize whether you have visited before and may store user preferences and other information.  For example, cookies can be used to collect information about your use of the Platforms during your current session and over time (including the pages you view and the files you download), the operating system and browser type of your computer or other device, your Internet service provider, your domain name and IP address, your general geographic location, the website that you visited before navigating to the Platforms, and the link you used to leave the Platforms.  If you are concerned about having cookies on your computer or device, you can set your browser to refuse all cookies or to indicate when a cookie is being set, allowing you to decide whether to accept it.  You can also delete cookies from your computer or device.  However, if you choose to block or delete cookies, certain features of the Platforms may not operate correctly.</p>
<p><strong><em>Web beacons.</em></strong>  We also may use an application known as a “web beacon” (also known as a “clear gif” or “web bug”).  A web beacon is an electronic file that usually consists of a single-pixel image.  It can be embedded in a web page or in an email to transmit information, which could include personal information.  For example, it allows an email sender to determine whether a user has opened a particular email.</p>
<p><strong><em>Third-party online tracking and behavioral advertising.</em></strong>  We also may partner with certain third parties to collect, analyze, and use some of the personal and non-personal information described in this section.  For example, we may allow third parties to set cookies or use web beacons on the Platforms or in email communications from Bark &amp; Co.  This information may be used for a variety of purposes, including online behavioral advertising, as discussed below (see the section entitled “How we share personal and non-personal information with third parties”).</p>
<h6>How we use the personal and non-personal information that we collect</h6>
<p>Bark &amp; Co uses the information that we collect for a variety of purposes.  If we have personal information about you, we may use it, for example:  to respond to your questions or requests concerning the Platforms or other services offered by Bark &amp; Co or our partners; to fulfill the terms of any agreement you have with us; to fulfill your requests for our services and orders for products or otherwise complete a transaction that you initiate; to send you information about our services, the status of any orders, and other topics that are likely to be of interest to you, including newsletters, updates, or other communications; to authenticate billing and identification information; to deliver confirmations, account information, notifications, awards, service-related announcements, and similar operational communications; to improve or personalize your user experience; to improve the quality of our products and services; to comply with legal and/or regulatory requirements; and to manage our business.</p>
<p>We use the non-personal information that we collect for such purposes as:  counting and recognizing users of the Platforms; analyzing users’ demographics, interests, and behavior, including how they use the Platforms and various Platform features; improving the Platforms and enhancing users’ experiences with the Platforms; researching and creating new products and services or improving our existing products and services; enabling additional website and application analytics and research concerning the Platforms; and managing our business.  Bark &amp; Co may link non-personal information gathered using cookies and web beacons with personal information.  But in that event, we will treat the combined information as personal information.</p>
<p>We also may use the personal and non-personal information that we collect to send you promotional communications, including emails or postal mail about the products and services offered by Bark &amp; Co or our partners.  Although we hope you will find our promotional emails of interest, you may opt out of receiving them by sending an email to support@barkbox.com with “optout” in the subject line, or by clicking on the “unsubscribe” link in any promotional email.  Promotional emails will also have instructions for opting out of that type of communication in the future.</p>
<p>We also provide you the opportunity to opt-out of having your personal information used for certain purposes when we ask for this information.  For example, if you purchase a product/service but do not wish to receive any additional marketing material from us, you can indicate your preference on our order form.</p>
<p>If you choose to use our referral service to tell a friend about our products or services, we will ask you for your friend’s name and email address.  We will automatically send your friend a one-time email inviting him or her to visit the Platforms.  This personal information may be used to track the success of our referral program.  Your friend may contact us at support@barkbox.com to request that we remove this information from our database.</p>
<h6>How we share personal and non-personal information with third parties</h6>
<p>We share your personal information and non-personal information with other parties for a variety of purposes, as described below.</p>
<p><strong><em>Analytics and online behavioral advertising.</em></strong>  We partner with certain third parties to collect the non-personal information discussed above and to engage in analysis, auditing, research, and reporting.  These third parties may use web logs or web beacons, and they may set and access cookies on your computer or other device.  In particular, as of the effective date of this Policy, certain of the Sites and Apps use such third party services as Google Analytics, Chartbeat, SimpleReach, Facebook retargeting, and Perfect Audience to help collect and analyze certain information for the purposes discussed above.</p>
<p>The Platforms also enable third-party tracking mechanisms to collect your non-personal information for use in online behavioral advertising.  For example, third parties may use the fact that you visited the Platforms to target online ads for Bark &amp; Co services to you on non-Bark &amp; Co websites or services.  In addition, our third-party advertising networks might use information about your use of the Platforms to help target non-Bark &amp; Co advertisements based on your online behavior in general.  For information about behavioral advertising practices, including privacy and confidentiality, visit the <a href="http://www.networkadvertising.org/understanding-online-advertising">Network Advertising Initiative website</a> or the <a href="http://www.aboutads.info">Digital Advertising Alliance website</a>.</p>
<p>The use of online tracking mechanisms by third parties is subject to those third parties’ own privacy policies, and not this Policy.  If you prefer to prevent third parties from setting and accessing cookies on your computer, you may set your browser to block cookies.  Additionally, you may remove yourself from the targeted advertising of companies within the Network Advertising Initiative by <a href="http://www.networkadvertising.org/choices/">opting out here</a>, or of companies participating in the Digital Advertising Alliance program by <a href="http://www.aboutads.info/choices">opting out here</a>.  Although our Platforms currently do not respond to “do not track” browser headers, you can limit tracking through these third-party programs and by taking the other steps discussed above.</p>
<p><strong><em>Third-party service providers and business partners.</em></strong>  Bark &amp; Co also uses other third-party service providers to help us manage and improve the Platforms and other Bark &amp; Co services.  These service providers may collect and/or use your personal or non-personal information to assist us in achieving the purposes discussed above in the section entitled “How we use the personal and non-personal information that we collect.”  For example, we use third parties to help us target and implement our email communications and direct mailings, to verify your identity and address for shipping purposes, to ship our products, and to process your credit card information.  We also use third-party platforms to help us manage our relationships with the people and companies that use our services.</p>
<p>We also may share your personal or non-personal information with other third parties when necessary to fulfill your requests for services; to complete a transaction that you initiate; to meet the terms of any agreement that you have with us or our partners; or to manage our business.</p>
<p><strong><em>Your direct sharing of information on the Platforms.</em></strong>  Certain features of our Platforms make it possible for you to share comments or feedback publicly with all other users of the Platforms.  Any information that you submit through such features will be available to the public at large and potentially accessible through third-party search engines.  Such information can be read, collected, and/or used by others, and it could be used to send you unsolicited messages if you disclose personal information.  Accordingly, please take care when using these features of the Platforms.</p>
<p><strong><em>Your direct sharing of personal information through third-party websites and services.</em></strong>  The Platforms may enable you to share directly personal information with websites or online services operated by third parties.  For example, the Platforms contain links to third-party websites that incorporate comment and social media features.  The Platforms may also contain a Facebook “like” button, a Twitter “follow” button, or similar features.  If you choose to use these features, you may disclose your personal information not just to those third-party websites and services, but also to their users and the public more generally.  Because these third-party websites and services are not operated by Bark &amp; Co, we are not responsible for the content or practices of those websites or services.  The collection, use, and disclosure of your personal and non-personal information will be subject to the privacy policies of the third party websites or services, and not this Policy.</p>
<p><strong><em>Third-party plugins.</em></strong>  The Platforms integrate certain third-party plug-ins (such as a Facebook “like” button).  Even if you do not click on these plug-ins, they may collect information about you, such as your IP address and the pages that you view.  They also may set and/or access a cookie.  These plugins are governed by the privacy policy of the company providing them.</p>
<p><strong><em>Legal purposes.</em></strong>  We also may use or share your personal or non-personal information with third parties when we believe, in our sole discretion, that doing so is necessary:</p>
<ul>
<li>to comply with applicable law or a court order, subpoena, or other legal process;</li>
<li>to investigate, prevent, or take action regarding illegal activities, suspected fraud, violations of our terms and conditions, or situations involving threats to our property or the property or physical safety of any person or third party;</li>
<li>to establish, protect, or exercise our legal rights or defend against legal claims; or</li>
<li>to facilitate the actual or proposed financing, securitization, insuring, sale, assignment, bankruptcy, or other disposal of all or part of our business or assets.</li>
</ul>
<p><strong><em>Aggregated information.</em></strong>  From time to time, Bark &amp; Co may also share de-identified and aggregated information about Platform users, such as by publishing a report on trends in the usage of the Platforms.</p>
<h6>Security</h6>
<p>Bark &amp; Co uses commercially reasonable physical, electronic, and procedural safeguards to protect your personal information against loss or unauthorized access, use, modification, or deletion.  When you enter sensitive information (such as credit card number and/or social security number) on our registration or order forms, we encrypt that information using secure socket layer technology (SSL).  However, no security program is foolproof, and thus we cannot guarantee the absolute security of your personal or other information.</p>
<h6>Reviewing and updating your information</h6>
<p>If you want to learn more about the personal information that Bark &amp; Co has about you, or you would like to update or change that information, or deactivate your account, please contact us by email at <a href="mailto:support@barkbox.com">support@barkbox.com</a>.</p>
<p>Note that deactivating your account does not cause your account information to be deleted from our servers. You can request such deletion by emailing our Customer Support team at <a href="mailto:support@barkbox.com">support@barkbox.com</a>.</p>
<h6>Information for Platform users from outside the United States</h6>
<p>The personal and non-personal information that we collect through or in connection with the Platforms is transferred to and processed in the United States for the purposes described above.  Bark &amp; Co also may subcontract the processing of your data to, or otherwise share your data with, affiliates or third parties in the United States or countries other than your country of residence.  The data-protection laws in these countries may be different from, and less stringent than, those in your country of residence.  By using the Platforms or by providing any personal or non-personal information to us, you expressly consent to such transfer and processing.</p>
<h6>Children’s Privacy</h6>
<p>The Platforms are not directed to children under the age of 13, and Bark &amp; Co will never knowingly collect personal or other information from anyone it knows is under the age of 13. Persons over 13 but under 18 years of age may use the Platforms only in conjunction with and under the supervision of a parent or legal guardian.</p>
<h6>Changes to this Policy</h6>
<p>We reserve the right to amend this policy at any time.  We will post all changes to this policy on this website, so you should review the policy periodically.  Any such amendments to this policy may apply to information we collect in the future as well as any information we obtained prior to such amendment.  If we make a material change to this policy, we will provide appropriate notice as required by law.</p>
<h6>Questions or comments</h6>
<p>If you have any questions or comments regarding our Policy, please contact us at:</p>
<p>221 Canal Street, Floor <br>New York, New York 10013 <br>Phone: 855-520-BARK <br>E-mail: <a href="mailto:support@barkbox.com">support@barkbox.com</a>.</p>
<p>Effective date:  September 30, 2014.</p>
</div>
</div>

</div>
<footer>
<nav class="wrap">
<section>
<h5>
<a href="/collections">Collections</a>
</h5>
<ul>
<li>
<a target="_self" href="/collections/happy-howloween">Happy Howloween</a>
</li>
<li>
<a target="_self" href="/collections/new-arrivals">Brand Wagging New </a>
</li>
<li>
<a target="_self" href="/collections/bedtime-story">Bedtime Story</a>
</li>
<li>
<a target="_self" href="/collections/barkmade">BarkMade</a>
</li>
</ul>
</section>
<section class="social">
<h5>Sniff Our Butt</h5>
<ul>
<li>
<a href="http://facebook.com/thebarkshop" target="_blank">
<i class="fa fa-fw fa-facebook"></i>
<span>Facebook</span>
</a>
</li>
<li>
<a href="https://twitter.com/barkshop" target="_blank">
<i class="fa fa-fw fa-twitter"></i>
<span>Twitter</span>
</a>
</li>
<li>
<a href="http://instagram.com/thebarkshop" target="_blank">
<i class="fa fa-fw fa-instagram"></i>
<span>Instagram</span>
</a>
</li>
<li>
<a href="http://pinterest.com/barkshop" target="_blank">
<i class="fa fa-fw fa-pinterest"></i>
<span>Pinterest</span>
</a>
</li>
</ul>
</section>
<section class="about">
<h5>About Us</h5>
<ul>
<li>
<a target="_self" href="/about">Who Are We?</a>
</li>
<li>
<a target="_blank" href="http://bark.co/jobs">Jobs</a>
</li>
<li>
<a target="_self" href="/returns">Returns</a>
</li>
<li>
<a target="_self" href="/privacy">Privacy Policy</a>
</li>
<li>
<a target="_self" href="/terms">Terms &amp; Conditions</a>
</li>
</ul>
</section>
<section>
<h5>Bark &amp; Co Family</h5>
<ul class="familia">
<li>
<a target="_blank" href="http://bark.co/">Bark &amp; Co</a>
</li>
<li>
<a target="_blank" href="https://www.barkbox.com/">BarkBox</a>
</li>
<li>
<a target="_blank" href="http://barkpost.com/">BarkPost</a>
</li>
</ul>
</section>
</nav>
<div>
<div class="wrap">
<h3 class="logo">
<a href="/" target="_self">
<img src="//dv4pc7nwcrrvy.cloudfront.net/assets/logo-white-56c73e1321d8f90f875b907c9b43bb65.png" alt="Logo white">
</a>
</h3>
<p>Made with <i class="fa fa-heart"></i> in NYC</p>
</div>
</div>
</footer>

<script>
  window.free_shipping_minimum = 35
</script>
<script>
  window.current_user = null;
</script>

<!--Start of Zopim Live Chat Script-->
<script type="text/javascript">
window.$zopim||(function(d,s){var z=$zopim=function(c){z._.push(c)},$=z.s=
d.createElement(s),e=d.getElementsByTagName(s)[0];z.set=function(o){z.set.
_.push(o)};z._=[];z.set._=[];$.async=!0;$.setAttribute("charset","utf-8");
$.src="//v2.zopim.com/?31hwtwabcV8aIaGpPCG4YPfC8ycOymAn";z.t=+new Date;$.
type="text/javascript";e.parentNode.insertBefore($,e)})(document,"script");

$zopim( function() {
  $zopim.livechat.departments.filter('BarkShop');
  $zopim.livechat.departments.setVisitorDepartment('BarkShop');

  function check(status) {
    var dep = $zopim.livechat.departments.getDepartment('BarkShop');
    if ( (typeof dep === 'undefined') || (dep.status === status) ) {
      return
    }
    else if (dep.status === 'offline') {
      $zopim.livechat.setStatus('offline');
      if (!$zopim.livechat.isChatting()){
        $zopim.livechat.hideAll();
      }
    }
    else if (dep.status === 'online') {
      $zopim.livechat.setStatus('online');
      if ($zopim.livechat.isChatting() && $.cookie('zopimOpen') == 'true' ){
        $zopim.livechat.window.show();
      }
      else {
        $zopim.livechat.window.hide();
      }
    }
    $zopim.livechat.window.setPosition('br');
  }

  $zopim.livechat.window.onShow(
    function(){
      $.cookie('zopimOpen', 'true', { path: '/' });
    }
  )

  $zopim.livechat.window.onHide(
    function(){
      $.cookie('zopimOpen', 'false', { path: '/' });
    }
  )

  $zopim.livechat.setOnStatus(check);
  $zopim.livechat.setOnConnected(check);

});
</script>
<!--End of Zopim Live Chat Script-->

<!--   // <script src="//d79i1fxsrar4t.cloudfront.net/jquery.liveaddress/2.5/jquery.liveaddress.min.js"></script> -->
<script>
  /**
    LiveAddress API jQuery Plugin
    by SmartyStreets - smartystreets.com
    (c) 2012-2013 SmartyStreets
    LICENSED UNDER THE GNU GENERAL PUBLIC LICENSE VERSION 3
    (http://opensource.org/licenses/gpl-3.0.html)
    Documentation:      http://smartystreets.com/kb/liveaddress-api/website-forms
    Version:        (See variable below for version)
    Minified:       (See documentation or GitHub repository for minified script file)
    Latest stable version:  (See documentation)
    Bleeding-edge release:  https://github.com/smartystreets/jquery.liveaddress
    Feel free to contribute to this project on GitHub by
    submitting pull requests and reporting issues.
  **/

  (function($, window, document) {
    "use strict";   //  http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/

    /*
      * PRIVATE MEMBERS
    */

    var instance;     // Contains public-facing functions and variables
    var ui = new UI;    // Internal use only, for UI-related tasks
    var version = "2.6.0";  // Version of this copy of the script

    var defaults = {
      candidates: 3,                              // Number of suggestions to show if ambiguous
      autocomplete: 10,                           // Number of autocomplete suggestions; set to 0 or false to disable
      requestUrl: "https://api.smartystreets.com/street-address",       // API endpoint
      timeout: 5000,                              // How long to wait before the request times out (5000 = 5 seconds)
      speed: "medium",                            // Animation speed
      ambiguousMessage: "Choose the correct address",             // Message when address is ambiguous
      invalidMessage: "Address not verified",                 // Message when address is invalid
      fieldSelector: "input[type=text], input:not([type]), textarea, select", // Selector for possible address-related form elements
      submitSelector: "[type=submit], [type=image], [type=button]:last, button:last"  // Selector to find a likely submit button or submit image (in a form)
    };
    var config = {};        // Configuration settings as set by the user or just the defaults
    var forms = [];         // List of forms (which hold lists of addresses)
    var defaultSelector = 'body'; // Default selector which should be over the whole page (must be compatible with the .find() function; not document)
    var mappedAddressCount = 0;   // The number of currently-mapped addresses
    var acceptableFields = ["street", "street2", "secondary", "city", "state", "zipcode", "lastline", "addressee", "urbanization", "country"]; // API input field names

    /*
      * ENTRY POINT
    */
    
    $.LiveAddress = function(arg)
    {
      return $(defaultSelector).LiveAddress(arg);
    };

    $.fn.LiveAddress = function(arg)
    {
      if (instance)
        return instance;

      var matched = this, wasChained = matched.prevObject ? !!matched.prevObject.prevObject : false;

      // Make sure the jQuery version is compatible
      var vers = $.fn.jquery.split(".");
      if (vers.length >= 2)
      {
        if (vers[0] < 1 || (vers[0] == 1 && vers[1] < 5))
        {
          console.log("jQuery version "+$.fn.jquery+" found, but LiveAddress requires jQuery version 1.5 or higher. Aborting.");
          return false;
        }
      }
      else
        return false;

      if (arg.debug)
        console.log("LiveAddress API jQuery Plugin version "+version+" (Debug mode)");

      // Mapping fields requires that the document be fully loaded in order to attach UI elements
      if (document.readyState === "complete")
        window.loaded = true;
      else
        $(window).load(function() { window.loaded = true; });

      // Determine if user passed in an API key or a settings/config object
      if (typeof arg === 'string')
      {
        // Use the default configuration
        config = { key: arg, candidates: defaults.candidates };
      }
      else if (typeof arg === 'object')
      {
        // Persist the user's configuration
        config = $.extend(config, arg);
      }

      // Enforce some defaults
      config.candidates = config.candidates || defaults.candidates;
      config.ui = typeof config.ui === 'undefined' ? true : config.ui;
      config.autoMap = typeof config.autoMap === 'undefined' ? true : config.autoMap;
      config.autoVerify = typeof config.autoVerify === 'undefined' ? true : config.autoVerify;
      config.submitVerify = typeof config.submitVerify === 'undefined' ? true : config.submitVerify;
      config.timeout = config.timeout || defaults.timeout;
      config.ambiguousMessage = config.ambiguousMessage || defaults.ambiguousMessage;
      config.invalidMessage = config.invalidMessage || defaults.invalidMessage;
      config.fieldSelector = config.fieldSelector || defaults.fieldSelector;
      config.submitSelector = config.submitSelector || defaults.submitSelector;
      config.requestUrl = config.requestUrl || defaults.requestUrl;
      config.autocomplete = typeof config.autocomplete === 'undefined' ? defaults.autocomplete : config.autocomplete;
      config.cityFilter = typeof config.cityFilter === 'undefined' ? "" : config.cityFilter;
      config.stateFilter = typeof config.stateFilter === 'undefined' ? "" : config.stateFilter;
      config.cityStatePreference = typeof config.cityStatePreference === 'undefined' ? "" : config.cityStatePreference;
      config.geolocate = typeof config.geolocate === 'undefined' ? true : config.geolocate;

      config.candidates = config.candidates < 1 ? 0 : (config.candidates > 10 ? 10 : config.candidates);

      if (typeof config.autocomplete === 'number')
        config.autocomplete = config.autocomplete < 1 ? false : (config.autocomplete > 10 ? 10 : config.autocomplete);

      /*
        * EXPOSED (PUBLIC) FUNCTIONS
      */
      instance = {
        events: EventHandlers,
        on: function(eventType, userHandler)
        {
          if (!EventHandlers[eventType] || typeof userHandler !== 'function')
            return false;

          var previousHandler = EventHandlers[eventType];
          EventHandlers[eventType] = function(event, data) {
            userHandler(event, data, previousHandler);
          };
        },
        mapFields: function(map)
        {
          var doMap = function(map)
          {
            if (map === "auto")
              return ui.automap(matched);
            else if (typeof map === 'object')
              return ui.mapFields(map, matched);
            else if (!map && typeof config.addresses === 'object')
              return ui.mapFields(config.addresses, matched)
            else if (config.autoMap)
              return ui.automap(matched);
            else
              return false;
          };
          if ($.isReady)
            doMap(map);
          else
            $(function() {
              if (!wasChained)
                matched = $(matched.selector);
              doMap(map);
            });
        },
        makeAddress: function(addressData)
        {
          if (typeof addressData !== "object")
            return instance.getMappedAddressByID(addressData) || new Address({ street: addressData });
          else
            return new Address(addressData);
        },
        verify: function(input, callback)
        {
          var addr = instance.makeAddress(input);     // Below means, force re-verify even if accepted/unchanged.
          trigger("VerificationInvoked", { address: addr, verifyAccepted: true, invoke: callback });
        },
        getMappedAddresses: function()
        {
          var addr = [];
          for (var i = 0; i < forms.length; i++)
            for (var j = 0; j < forms[i].addresses.length; j++)
              addr.push(forms[i].addresses[j]);
          return addr;
        },
        getMappedAddressByID: function(id)
        {
          for (var i = 0; i < forms.length; i++)
            for (var j = 0; j < forms[i].addresses.length; j++)
              if (forms[i].addresses[j].id() == id)
                return forms[i].addresses[j];
        },
        setKey: function(htmlkey)
        {
          config.key = htmlkey;
        },
        setCityFilter: function(cities)
        {
          config.cityFilter = cities;
        },
        setStateFilter: function(states)
        {
          config.stateFilter = states;
        },
        setCityStatePreference: function(pref)
        {
          config.cityStatePreference = pref;
        },
        activate: function(addressID)
        {
          var addr = instance.getMappedAddressByID(addressID);
          if (addr)
            addr.active = true;
        },
        deactivate: function(addressID)
        {
          if (!addressID)
            return ui.clean();
          var addr = instance.getMappedAddressByID(addressID);
          if (addr)
            addr.active = false;
        },
        autoVerify: function(setting)
        {
          if (typeof setting === 'undefined')
            return config.autoVerify;
          else if (setting === "disable" || setting === "off" || !setting)
            config.autoVerify = false;
          else
            config.autoVerify = true;
        },
        version: version
      };

      
      // Bind each handler to an event
      for (var prop in EventHandlers)
        bind(prop);

      // Map the fields
      instance.mapFields();

      return instance;
    };



    /*
      * PRIVATE FUNCTIONS / OBJECTS
    */



    /*
      The UI object auto-maps the fields and controls
      interaction with the user during the address
      verification process.
    */
    function UI()
    {
      var submitHandler;        // Function which is later bound to handle form submits
      var mapMeta = {
        formDataProperty: "smarty-form",  // Indicates whether we've stored the form already
        identifiers: {
          streets: {        // both street1 and street2, separated later.
            names: [      // Names are hidden from the user; "name" and "id" attributes
              'street',
              'address',    // This ("address") is a dangerous inclusion; but we have a strong set of exclusions below to prevent false positives.
              'address1',   // If there are automapping issues (specifically if it is too greedy when mapping fields) it will be because
              'address2',   // of these arrays for the "streets" fields, namely the "address" entry right around here, or potentially others.
              'addr1',
              'addr2',
              'address-1',
              'address-2',
              'address_1',
              'address_2',
              'line',
              'primary'
            ],
            labels: [     // Labels are visible to the user (labels and placeholder texts)
              'street',
              'address',    // hazardous (e.g. "Email address") -- but we deal with that later
              'line ',
              ' line'
            ]
          },
          secondary: {
            names: [
              'suite',
              'apartment',
              'primary',
              //'box',    // This false-positives fields like "searchBox" ...
              'pmb',
              //'unit',   // I hesitate to allow this, since "Units" (as in quantity) might be common...
              'secondary'
            ],
            labels: [
              'suite',
              'apartment',
              'apt:',
              'apt.',
              'ste:',
              'ste.',
              'unit:',
              'unit.',
              'unit ',
              'box',
              'pmb'
            ]
          },
          city: {
            names: [
              'city',
              'town',
              'village',
              'cityname',
              'city-name',
              'city_name',
              'cities'
            ],
            labels: [
              'city',
              'town',
              'city name'
            ]
          },
          state: {
            names: [
              'state',
              'province',
              'region',
              'section',
              'territory'
            ],
            labels: [
              'state',
              'province',
              'region',
              'section',
              'territory'
            ]
          },
          zipcode: {
            names: [
              'zip',
              'zipcode',
              'zip-code',
              'zip_code',
              'postal_code',
              'postal-code',
              'postalcode',
              'postcode',
              'post-code',
              'post_code',
              'postal',
              'zcode'
            ],
            labels: [
              'zip',
              'zip code',
              'postal code',
              'postcode',
              'locality'
            ]
          },
          lastline: {
            names: [
              'lastline',
              'last-line',
              'citystatezip',
              'city-state-zip',
              'city_state_zip'
            ],
            labels: [
              'last line',
              'city/state/zip',
              'city / state / zip',
              'city - state - zip',
              'city-state-zip',
              'city, state, zip'
            ]
          },
          country: {        // We only use country to see if we should submit to the API
            names: [
              'country',
              'nation',
              'sovereignty'
            ],
            labels: [
              'country',
              'nation',
              'sovereignty'
            ]
          }
        },  // We'll iterate through these (above) to make a basic map of fields, then refine:
        street1exacts: {    // List of case-insensitive EXACT matches for street1 field
          names: [
            'address',
            'street',
            'address1',
            'streetaddress',
            'street-address',
            'street_address',
            'streetaddr',
            'street-addr',
            'street_addr',
            'str',
            'str1',
            'street1',
            'addr'
          ]
        },
        street2: {      // Terms which would identify a "street2" field
          names: [
            'address2',
            'address_2',
            'address-2',
            'street2',
            'addr2',
            'addr_2',
            'line2',
            'str2',
            'second',
            'two'
          ],
          labels: [
            ' 2',
            'second ',
            'two'
          ]
        },
        exclude: {      // Terms we look for to exclude an element from the mapped set to prevent false positives
          names: [    // The intent is to keep non-address elements from being mapped accidently.
            'email',
            'e-mail',
            'e_mail',
            'firstname',
            'first-name',
            'first_name',
            'lastname',
            'last-name',
            'last_name',
            'fname',
            'lname',
            'name',     // Sometimes problematic ("state_name" ...) -- also see same label value below
            'eml',
            'type',
            'township',
            'zip4',
            'plus4',
            'method',
            'location',
            'store',
            'save',
            'keep',
            'phn',
            'phone',
            'cardholder', // I hesitate to exclude "card" because of common names like: "card_city" or something...
            'security',
            'comp',
            'firm',
            'org',
            'addressee',
            'addresses',
            'group',
            'gate',
            'fax',
            'cvc',
            'cvv',
            'file',
            'search',
            'list'      // AmeriCommerce cart uses this as an "Address Book" dropdown to choose an entire address...
          ],
          labels: [
            'email',
            'e-mail',
            'e mail',
            ' type',
            'save ',
            'keep',
            'name',
            'method',
            'phone',
            'organization',
            'company',
            'addressee',
            'township',
            'firm',
            'group',
            'gate',
            'cardholder',
            'cvc',
            'cvv',
            'search',
            'file',
            ' list',
            'fax',
            'book'
          ]
        }
      };

      var autocompleteResponse;   // The latest response from the autocomplete server
      var autocplCounter = 0;     // A counter so that only the most recent JSONP request is used
      var autocplRequests = [];   // The array that holds autocomplete requests in order
      var loaderWidth = 24, loaderHeight = 8;   // TODO: Update these if the image changes
      var uiCss = "<style>"
        + ".smarty-dots { display: none; position: absolute; z-index: 999; width: "+loaderWidth+"px; height: "+loaderHeight+"px; background-image: url('data:image/gif;base64,R0lGODlhGAAIAOMAALSytOTi5MTCxPTy9Ly6vPz6/Ozq7MzKzLS2tOTm5PT29Ly+vPz+/MzOzP///wAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQJBgAOACwAAAAAGAAIAAAEUtA5NZi8jNrr2FBScQAAYVyKQC6gZBDkUTRkXUhLDSwhojc+XcAx0JEGjoRxCRgWjcjAkqZr5WoIiSJIaohIiATqimglg4KWwrDBDNiczgDpiAAAIfkECQYAFwAsAAAAABgACACEVFZUtLK05OLkxMbE9PL0jI6MvL68bG5s7Ors1NbU/Pr8ZGJkvLq8zM7MXFpctLa05ObkzMrM9Pb0nJqcxMLE7O7s/P78////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABWDgZVWQcp2nJREWmhLSKRWOcySoRAWBEZ8IBi+imAAcxwXhZODxDCfFwxloLI6A7OBCoPKWEG/giqxRuOLKRSA2lpVM6kM2dTZmyBuK0Aw8fhcQdQMxIwImLiMSLYkVPyEAIfkECQYAFwAsAAAAABgACACEBAIEpKak1NbU7O7svL68VFZU/Pr8JCIktLK05OLkzMrMDA4M9Pb0vLq87Ors9PL0xMLEZGZk/P78tLa05ObkzM7MFBIU////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABWLgJVGCcZ2n9DASmq7nUwDAQaAPhCAEgzqNncIQodEWgxNht7tdDBMmorIw0gKXh3T3uCSYgV3VitUiwrskZTspGpFKsJMRRVdkNBuKseT5Tg4TUQo+BgkCfygSDCwuIgN/IQAh+QQJBgAXACwAAAAAGAAIAIRUVlS0srTk4uR8enz08vTExsRsbmzs6uyMjoz8+vzU1tRkYmS8urzMzsxcWly0trTk5uR8fnz09vTMyszs7uycmpz8/vz///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFYOBlUVBynad1QBaaEtIpIY5jKOgxAM5w5IxAYJKo8HgLwmnnAAAGsodQ2FgcnYUL5Nh0QLTTqbXryB6cXcBPEBYaybEL0wm9SNqFWfOWY0Z+JxBSAXkiFAImLiolLoZxIQAh+QQJBgAQACwAAAAAGAAIAIQEAgS0srTc2tz08vTMyszk5uT8+vw0MjS8ury0trTk4uT09vTMzszs6uz8/vw0NjT///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFWiAELYMjno4gmCfkDItoEEGANKfwAMAjnA1EjWBg1I4G14HHO5gMiWOAEZUqIAIm86eQeo/XrBbA/RqlMceS6RxVa4xZLVHI7QCHn6hQRbAWDSwoKoIiLzEQIQAh+QQJBgAXACwAAAAAGAAIAIRUVlS0srTk4uR8enz08vTExsRsbmzs6uyMjoz8+vzU1tRkYmS8urzMzsxcWly0trTk5uR8fnz09vTMyszs7uycmpz8/vz///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFY+B1SYQlntYBmeeVQJSZTEHAHCcUOUCEiwqDw4GQNGrIhGgA4DkGIsIC0ARUHsia4AKpOiGXghewyGq5YwCu4Gw6jlnJ0gu9SKvWRKH2AIt0TQN+F0FNRSISMS0XKSuLCQKKIQAh+QQJBgAXACwAAAAAGAAIAIQEAgSkpqTU1tTs7uy8vrxUVlT8+vwkIiS0srTk4uTMyswMDgz09vS8urzs6uz08vTEwsRkZmT8/vy0trTk5uTMzswUEhT///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFZOB1MY8knhJpnpchUKahIEjjnAxEE8xJHABA4VGhGQ0ighFBEA0swWBkYgxMEpfHkva4BKLBxRaBHdACCHT3C14U0VbkRWlsXgYLcERGJQxOD3Q8PkBCfyMDKygMDIoiDAIJJiEAIfkECQYAFwAsAAAAABgACACEVFZUtLK05OLkxMbE9PL0jI6MvL68bG5s7Ors1NbU/Pr8ZGJkvLq8zM7MXFpctLa05ObkzMrM9Pb0nJqcxMLE7O7s/P78////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABWPgdUmEJZ4WaZ6XAlWmEgUBg5wSRRvSmRwOR0HSoBkVIoMxYBARFgBHdPJYBgSXijVAuAykUsBii5VsK96oelFc9i5K40MkgYInigHtAcHFH28XP1EFXSMwLBcWFRIrJwoCiCEAOw=='); }"
        + ".smarty-ui { position: absolute; z-index: 99999; text-shadow: none; text-align: left; text-decoration: none; }"
        + ".smarty-popup { border: 3px solid #4C4C4C; padding: 0; background: #F6F6F6; box-shadow: 0px 10px 35px rgba(0, 0, 0, .8); }"
        + ".smarty-popup-header { background: #DDD; height: 12px; text-transform: uppercase; font: bold 12px/1em 'Arial Black', sans-serif; padding: 12px; }"
        + ".smarty-popup-ambiguous-header { color: #333; }"
        + ".smarty-popup-invalid-header { color: #CC0000; }"
        + ".smarty-popup-close { color: #CC0000 !important; text-decoration: none !important; position: absolute; right: 15px; top: 10px; display: block; padding: 4px 6px; text-transform: uppercase; }"
        + ".smarty-popup-close:hover { color: #FFF !important; background: #CC0000; }"
        + ".smarty-choice-list .smarty-choice { background: #FFF; padding: 10px 15px; color: #1A1A1A; }"
        + ".smarty-choice { display: block; font: 300 14px/1.5em sans-serif; text-decoration: none !important; border-top: 1px solid #CCC; }"
        + ".smarty-choice-list .smarty-choice:hover { color: #EEE !important; background: #333; text-decoration: none !important; }"
        + ".smarty-choice-alt { border-top: 1px solid #4C4C4C; background: #F6F6F6 !important; box-shadow: inset 0 4px 15px -5px rgba(0, 0, 0, .45); }"
        + ".smarty-choice-alt .smarty-choice-abort, .smarty-choice-override { padding: 6px 15px; color: #B3B3B3 !important; font-size: 12px; text-decoration: none !important; }"
        + ".smarty-choice-alt .smarty-choice:first-child { border-top: 0; }"
        + ".smarty-choice-abort:hover { color: #333 !important; }"
        + ".smarty-choice-override:hover { color: #CC0000 !important; }"
        + ".smarty-tag { position: absolute; display: block; overflow: hidden; font: 15px/1.2em sans-serif; text-decoration: none !important; width: 20px; height: 18px; border-radius: 25px; transition: all .25s; -moz-transition: all .25s; -webkit-transition: all .25s; -o-transition: all .25s; }"
        + ".smarty-tag:hover { width: 70px; text-decoration: none !important; color: #999; }"
        + ".smarty-tag:hover .smarty-tag-text { color: #000 !important; }"
        + ".smarty-tag-grayed { border: 1px solid #B4B4B4 !important; color: #999 !important; background: #DDD !important; box-shadow: inset 0 9px 15px #FFF; }"
        + ".smarty-tag-green { border: 1px solid #407513 !important; color: #407513 !important; background: #A6D187 !important; box-shadow: inset 0 9px 15px #E3F6D5; }"
        + ".smarty-tag-grayed:hover { border-color: #333 !important; }"
        + ".smarty-tag-check { padding-left: 4px; text-decoration: none !important; }"
        + ".smarty-tag-text { font-size: 12px !important; position: absolute; top: 0; left: 16px; width: 50px !important; text-align: center !important; }"
        + ".smarty-autocomplete { border: 1px solid #777; background: white; overflow: hidden; white-space: nowrap; box-shadow: 1px 1px 3px #555; }"
        + ".smarty-suggestion { display: block; color: #444; text-decoration: none !important; font-size: 12px; padding: 1px 5px; }"
        + ".smarty-active-suggestion { background: #EEE; color: #000; border: none; outline: none; }"
        + ".smarty-no-suggestions { padding: 1px 5px; font-size: 12px; color: #AAA; font-style: italic; }"
        + "</style>";


      this.postMappingOperations = function()
      {
        // Injects materials into the DOM, binds to form submit events, etc... very important.

        if (config.ui)
        {
          // Prepend CSS to head tag to allow cascading and give their style rules priority
          $('head').prepend(uiCss);

          // For each address on the page, inject the loader and "address verified" markup after the last element
          var addresses = instance.getMappedAddresses();
          for (var i = 0; i < addresses.length; i++)
          {
            var id = addresses[i].id();
            $('body').append('<div class="smarty-ui"><div title="Loading..." class="smarty-dots smarty-addr-'+id+'"></div></div>');
            var offset = uiTagOffset(addresses[i].corners(true));
            $('body').append('<div class="smarty-ui" style="top: '+offset.top+'px; left: '+offset.left+'px;"><a href="javascript:" class="smarty-tag smarty-tag-grayed smarty-addr-'+id+'" title="Address not verified. Click to verify." data-addressid="'+id+'"><span class="smarty-tag-check">&#10003;</span><span class="smarty-tag-text">Verify</span></a></div>');
            
            // Move the UI elements around when browser window is resized
            $(window).resize({ addr: addresses[i] }, function(e)
            {
              var addr = e.data.addr;
              var offset = uiTagOffset(addr.corners(true)); // Position of lil' tag
              $('.smarty-tag.smarty-addr-'+addr.id())
                .parent('.smarty-ui')
                .css('top', offset.top+'px')
                .css('left', offset.left+'px');

              var addrOffset = addr.corners();        // Position of any popup windows
              $('.smarty-popup.smarty-addr-'+addr.id())
                .parent('.smarty-ui')
                .css('top', addrOffset.top+'px')
                .css('left', addrOffset.left+'px');

              if (config.autocomplete)            // Position of autocomplete boxes
              {
                var containerUi = $('.smarty-autocomplete.smarty-addr-'+addr.id()).closest('.smarty-ui');
                var domFields = addr.getDomFields();
                if (domFields['street'])
                {
                  containerUi.css({
                    "left": $(domFields['street']).offset().left + "px",
                    "top": ($(domFields['street']).offset().top + $(domFields['street']).outerHeight(false)) + "px"
                  });
                }
              }
            });

            // Disable for addresses defaulting to a foreign/non-US value
            if (!addresses[i].isDomestic())
            {
              var uiTag = $('.smarty-ui .smarty-tag.smarty-addr-'+id)
              if (uiTag.is(':visible'))
                uiTag.hide();
              addresses[i].accept({ address: addresses[i] }, false);
            }
          }

          $('body').delegate('.smarty-tag-grayed', 'click', function(e)
          {
            // "Verify" clicked -- manually invoke verification
            var addrId = $(this).data('addressid');
            instance.verify(addrId);
          });

          $('body').delegate('.smarty-undo', 'click', function(e)
          {
            // "Undo" clicked -- replace field values with previous input
            var addrId = $(this).parent().data('addressid');
            var addr = instance.getMappedAddressByID(addrId);
            addr.undo(true);
            // If fields are re-mapped after an address was verified, it loses its "accepted" status even if no values were changed.
            // Thus, in some rare occasions, the undo link and the "verified!" text may not disappear when the user clicks "Undo",
            // The undo functionality still works in those cases, but with no visible changes, the address doesn't fire "AddressChanged"...
          });



          // Prepare autocomplete UI
          if (config.autocomplete && config.key)
          {
            // For every mapped address, wire up autocomplete
            for (var i = 0; i < forms.length; i++)
            {
              var f = forms[i];

              for (var j = 0; j < f.addresses.length; j++)
              {
                var addr = f.addresses[j];
                var domFields = addr.getDomFields();

                if (domFields['street'])
                {
                  var strField = $(domFields['street']);
                  var containerUi = $('<div class="smarty-ui"></div>');
                  var autoUi = $('<div class="smarty-autocomplete"></div>');

                  autoUi.addClass('smarty-addr-' + addr.id());
                  containerUi.data("addrID", addr.id())
                  containerUi.append(autoUi);
                  
                  containerUi.css({
                    "position": "absolute",
                    "left": strField.offset().left + "px",
                    "top": (strField.offset().top + strField.outerHeight(false)) + "px"
                  });

                  containerUi.hide().appendTo("body");

                  containerUi.delegate(".smarty-suggestion", "click", { addr: addr, containerUi: containerUi }, function(event) {
                    var sugg = autocompleteResponse.suggestions[$(this).data('suggIndex')];
                    useAutocompleteSuggestion(event.data.addr, sugg, event.data.containerUi);
                  });

                  containerUi.delegate(".smarty-suggestion", "mouseover", function() {
                    $('.smarty-active-suggestion').removeClass('smarty-active-suggestion');
                    $(this).addClass('smarty-active-suggestion');
                  });

                  containerUi.delegate(".smarty-active-suggestion", "mouseleave", function() {
                    $(this).removeClass('smarty-active-suggestion');
                  });


                  strField.attr("autocomplete", "off"); // Tell Firefox to keep quiet

                  strField.blur({ containerUi: containerUi }, function(event) {
                    setTimeout( (function(event) { return function() { if (event.data) event.data.containerUi.hide(); }; })(event), 300); // This line is proudly IE9-compatible
                  });

                  strField.keydown({ containerUi: containerUi, addr: addr }, function(event) {
                    var suggContainer = $('.smarty-autocomplete', event.data.containerUi);
                    var currentChoice = $('.smarty-active-suggestion:visible', suggContainer).first();
                    var choiceSelectionIsNew = false;

                    if (event.keyCode == 9)     // Tab key
                    {
                      if (currentChoice.length > 0)
                      {
                        var domFields = event.data.addr.getDomFields();
                        if (domFields['zipcode'])
                          $(domFields['zipcode']).focus();
                        else
                          $(domFields['street']).blur();
                        useAutocompleteSuggestion(event.data.addr, autocompleteResponse.suggestions[currentChoice.data("suggIndex")], event.data.containerUi);
                        return addr.isFreeform() ? true : suppress(event);
                      }
                      else
                        event.data.containerUi.hide();
                      return;
                    }
                    else if (event.keyCode == 40) // Down arrow
                    {
                      if (!currentChoice.hasClass('smarty-suggestion'))
                      {
                        currentChoice = $('.smarty-suggestion', suggContainer).first().mouseover();
                        choiceSelectionIsNew = true;
                      }

                      if (!choiceSelectionIsNew)
                      {
                        if (currentChoice.next('.smarty-addr-'+event.data.addr.id()+' .smarty-suggestion').length > 0)
                          currentChoice.next('.smarty-suggestion').mouseover();
                        else
                          currentChoice.removeClass('smarty-active-suggestion');
                      }

                      moveCursorToEnd(this);
                      return;
                    }
                    else if (event.keyCode == 38) // Up arrow
                    {
                      if (!currentChoice.hasClass('smarty-suggestion'))
                      {
                        currentChoice = $('.smarty-suggestion', suggContainer).last().mouseover();
                        choiceSelectionIsNew = true;
                      }

                      if (!choiceSelectionIsNew)
                      {
                        if (currentChoice.prev('.smarty-addr-'+event.data.addr.id()+' .smarty-suggestion').length > 0)
                          currentChoice.prev('.smarty-suggestion').mouseover();
                        else
                          currentChoice.removeClass('smarty-active-suggestion');
                      }

                      moveCursorToEnd(this);
                      return;
                    }
                  });

                  // Flip the on switch!
                  strField.keyup({ form: f, addr: addr, streetField: strField, containerUi: containerUi }, doAutocomplete);
                }
              }

              $(document).keyup(function(event) {
                if (event.keyCode == 27)  // Esc key
                  $('.smarty-autocomplete').closest('.smarty-ui').hide();
              });
            }

            // Try .5 and 1.5 seconds after the DOM loads to re-position UI elements; hack for Firefox.
            setTimeout(function() { $(window).resize(); }, 500);
            setTimeout(function() { $(window).resize(); }, 1500);
          }
        }
        
        if (config.submitVerify)
        {
          // Bind to form submits through form submit and submit button click events
          for (var i = 0; i < forms.length; i++)
          {
            var f = forms[i];
    
            submitHandler = function(e)
            {
              // Don't invoke verification if it's already processing or autocomplete is open and the user was pressing Enter to use a suggestion
              if ((e.data.form && e.data.form.processing) || $('.smarty-active-suggestion:visible').length > 0)
                return suppress(e);

              /*
                IMPORTANT!
                Prior to version 2.4.8, the plugin would call syncWithDom() at submit-time
                in case programmatic changes were made to the address input fields, including
                browser auto-fills. The sync function would detect those changes and force
                a re-verification to not let invalid addresses through. Unfortunately, this
                frequently caused infinite loops (runaway lookups), ultimately preventing
                form submission, which is unacceptable. As a safety measure to protect our
                customer's subscriptions, we've removed syncWithDom(). The website owner is
                responsible for making sure that any changes to address field values raise the
                "change" event on that element. Example: $('#city').val('New City').change();
              */
    
              if (!e.data.form.allActiveAddressesAccepted())
              {
                // We could verify all the addresses at once, but that can overwhelm the user.
                // An API request is usually quick, so let's do one at a time: it's much cleaner.
                var unaccepted = e.data.form.activeAddressesNotAccepted();
                if (unaccepted.length > 0)
                  trigger("VerificationInvoked", { address: unaccepted[0], invoke: e.data.invoke, invokeFn: e.data.invokeFn });
                return suppress(e);
              }
            };
    
            // Performs the tricky operation of uprooting existing event handlers that we have references to
            // (either by jQuery's data cache or HTML attributes) planting ours, then laying theirs on top
            var bindSubmitHandler = function(domElement, eventName)
            {
              if (!domElement || !eventName)
                return;
    
              var oldHandlers = [], eventsRef = $._data(domElement, 'events');
    
              // If there are previously-bound-event-handlers (from jQuery), get those.
              if (eventsRef && eventsRef[eventName] && eventsRef[eventName].length > 0)
              {
                // Get a reference to the old handlers previously bound by jQuery
                oldHandlers = $.extend(true, [], eventsRef[eventName]);
              }
    
              // Unbind them...
              $(domElement).unbind(eventName);
    
              // ... then bind ours first ...
              $(domElement)[eventName]({ form: f, invoke: domElement, invokeFn: eventName }, submitHandler);
    
              // ... then bind theirs last:
              // First bind their onclick="..." or onsubmit="..." handles...
              if (typeof domElement['on'+eventName] === 'function')
              {
                var temp = domElement['on'+eventName];
                domElement['on'+eventName] = null;
                $(domElement)[eventName](temp);
              }
    
              // ... then finish up with their old jQuery handles.
              for (var j = 0; j < oldHandlers.length; j++)
                $(domElement)[eventName](oldHandlers[j].data, oldHandlers[j].handler);
            };
    
            // Take any existing handlers (bound via jQuery) and re-bind them for AFTER our handler(s).
            var formSubmitElements = $(config.submitSelector, f.dom);
    
            // Form submit() events are apparently invoked by CLICKING the submit button (even jQuery does this at its core for binding)
            // (but jQuery, when raising a form submit event with .submit() will NOT necessarily click the submit button)
            formSubmitElements.each(function(idx) {
              bindSubmitHandler(this, 'click'); // These get fired first
            });
    
            // These fire after button clicks, so these need to be bound AFTER binding to the submit button click events
            bindSubmitHandler(f.dom, 'submit');
          }
        }

        trigger("MapInitialized");
      };

      function doAutocomplete(event)
      {
        var addr = event.data.addr;
        var streetField = event.data.streetField;
        var input = $.trim(event.data.streetField.val());
        var containerUi = event.data.containerUi;
        var suggContainer = $('.smarty-autocomplete', containerUi);

        if (!input)
        {
          addr.lastStreetInput = input;
          suggContainer.empty();
          containerUi.hide();
        }

        if (event.keyCode == 13)  // Enter/return
        {
          if ($('.smarty-active-suggestion:visible').length > 0)
            useAutocompleteSuggestion(addr, autocompleteResponse.suggestions[$('.smarty-active-suggestion:visible').first().data('suggIndex')], containerUi);
          containerUi.hide();
          streetField.blur();
          return suppress(event);
        }

        if (event.keyCode == 40)  // Down arrow
        {
          moveCursorToEnd(streetField[0]);
          return;
        }

        if (event.keyCode == 38)  // Up arrow
        {
          moveCursorToEnd(streetField[0]);
          return;
        }

        if (!input || input == addr.lastStreetInput || !addr.isDomestic())
          return;

        addr.lastStreetInput = input; // Used so that autocomplete only fires on real changes (i.e. not just whitespace)

        trigger('AutocompleteInvoked', {
          containerUi: containerUi,
          suggContainer: suggContainer,
          streetField: streetField,
          input: input,
          addr: addr
        });
      }

      this.requestAutocomplete = function(event, data)
      {
        if (data.input && data.addr.isDomestic() && autocompleteResponse)
          data.containerUi.show();

        var autocplrequest = {
          callback: function(counter, json)
          {
            autocompleteResponse = json;
            data.suggContainer.empty();

            if (!json.suggestions || json.suggestions.length == 0)
            {
              data.suggContainer.html('<div class="smarty-no-suggestions">No suggestions</div>');
              return;
            }

            for (var j = 0; j < json.suggestions.length; j++)
            {
              var link = $('<a href="javascript:" class="smarty-suggestion">' + json.suggestions[j].text.replace(/<|>/g, "") + '</a>');
              link.data("suggIndex", j);
              data.suggContainer.append(link);
            }

            data.suggContainer.css({
              "width": Math.max(data.streetField.outerWidth(false), 250) + "px"
            });

            data.containerUi.show();

            // Delete all older callbacks so they don't get executed later because of latency
            autocplRequests.splice(0, counter);
          },
          number: autocplCounter++
        };

        autocplRequests[autocplrequest.number] = autocplrequest;

        $.getJSON("https://autocomplete-api.smartystreets.com/suggest?callback=?", {
          "auth-id": config.key,
          prefix: data.input,
          city_filter: config.cityFilter,
          state_filter: config.stateFilter,
          prefer: config.cityStatePreference,
          suggestions: config.autocomplete,
          geolocate: config.geolocate
        }, function(json)
        {
          trigger("AutocompleteReceived", $.extend(data, {
            json: json,
            autocplrequest: autocplrequest
          }));
        });
      };

      this.showAutocomplete = function(event, data)
      {
        if (autocplRequests[data.autocplrequest.number])
          autocplRequests[data.autocplrequest.number].callback(data.autocplrequest.number, data.json);
      };

      function useAutocompleteSuggestion(addr, suggestion, containerUi)
      {
        var domfields = addr.getDomFields();
        containerUi.hide();   // It's important that the suggestions are hidden before AddressChanged event fires

        if (addr.isFreeform())
          $(domfields['street']).val(suggestion.text).change();
        else
        {
          if(domfields['zipcode'])
            $(domfields['zipcode']).val("").change();
          if (domfields['street'])
            $(domfields['street']).val(suggestion.street_line).change();
          // State filled in before city so autoverify is not invoked without finishing using the suggestion
          if (domfields['state'])
          {
            if(domfields['state'].options) // Checks for dropdown
            {
              for(var i = 0; i < domfields['state'].options.length; i++)
              {
                // Checks for abbreviation match and maps full state name to abbreviation
                if(domfields['state'].options[i].text.toUpperCase() === suggestion.state || allStatesByName[domfields['state'].options[i].text.toUpperCase()] === suggestion.state)
                {
                  $(domfields['state'])[0].selectedIndex = i;
                  $(domfields['state']).change();
                  break;
                }
              }
            }
            else
              $(domfields['state']).val(suggestion.state).change();
          }
          if (domfields['city'])
            $(domfields['city']).val(suggestion.city).change();
          if (domfields['lastline'])
            $(domfields['lastline']).val(suggestion.city + " " + suggestion.state).change();
        }
        trigger("AutocompleteUsed", {address: addr, suggestion: suggestion});
      }

      // Computes where the little checkmark tag of the UI goes, relative to the boundaries of the last field
      function uiTagOffset(corners)
      {
        return {
          top: corners.top + corners.height / 2 - 10,
          left: corners.right - 6
        };
      }

      // This function is used to find and properly map elements to their field type
      function filterDomElement(domElement, names, labels)
      {
        /*
          Where we look to find a match, in this order:
          name, id, <label> tags, placeholder, title
          Our searches first conduct fairly liberal "contains" searches:
          if the attribute even contains the name or label, we map it.
          The names and labels we choose to find are very particular.
         */

        var name = lowercase(domElement.name);
        var id = lowercase(domElement.id);
        var selectorSafeID = id.replace(/[\[|\]|\(|\)|\:|\'|\"|\=|\||\#|\.|\!|\||\@|\^|\&|\*]/g, '\\\\$&');
        var placeholder = lowercase(domElement.placeholder);
        var title = lowercase(domElement.title);

        // First look through name and id attributes of the element, the most common
        for (var i = 0; i < names.length; i++)
          if (name.indexOf(names[i]) > -1 || id.indexOf(names[i]) > -1)
            return true;

        // If we can't find it in name or id, look at labels associated to the element.
        // Webkit automatically associates labels with form elements for us. But for other
        // browsers, we have to find them manually, which this next block does.
        if (!('labels' in domElement))
        {
          var lbl = $('label[for="' + selectorSafeID + '"]')[0] || $(domElement).parents('label')[0];
          domElement.labels = !lbl ? [] : [lbl];
        }

        // Iterate through the <label> tags now to search for a match.
        for (var i = 0; i < domElement.labels.length; i++)
        {
          // This inner loop compares each label value with what we're looking for
          for (var j = 0; j < labels.length; j++)
            if ($(domElement.labels[i]).text().toLowerCase().indexOf(labels[j]) > -1)
              return true;
        }

        // Still not found? Then look in "placeholder" or "title"...
        for (var i = 0; i < labels.length; i++)
        if (placeholder.indexOf(labels[i]) > -1 || title.indexOf(labels[i]) > -1)
          return true;

        // Got all the way to here? Probably not a match then.
        return false;
      };

      // User aborted the verification process (X click or esc keyup)
      function userAborted(uiPopup, e)
      {
        // Even though there may be more than one bound, and this disables the others,
        // this is for simplicity: and I figure, it won't happen too often.
        // (Otherwise "Completed" events are raised by pressing Esc even if nothing is happening)
        $(document).unbind('keyup');
        $(uiPopup).slideUp(defaults.speed, function() { $(this).parent('.smarty-ui').remove(); });
        trigger("Completed", e.data);
      }

      // When we're done with a "pop-up" where the user chooses what to do,
      // we need to remove all other events bound on that whole "pop-up"
      // so that it doesn't interfere with any future "pop-ups".
      function undelegateAllClicks(selectors)
      {
        for (var selector in selectors)
          $('body').undelegate(selectors[selector], 'click');
      }

      // Utility function
      function moveCursorToEnd(el)  // Courtesy of http://css-tricks.com/snippets/javascript/move-cursor-to-end-of-input/
      {
        if (typeof el.selectionStart == "number")
          el.selectionStart = el.selectionEnd = el.value.length;
        else if (typeof el.createTextRange != "undefined")
        {
          el.focus();
          var range = el.createTextRange();
          range.collapse(false);
          range.select();
        }
      }


      // If anything was previously mapped, this resets it all for a new mapping.
      this.clean = function()
      {
        if (forms.length == 0)
          return;

        if (config.debug)
          console.log("Cleaning up old form map data and bindings...");

        // Spare none alive!

        for (var i = 0; i < forms.length; i++)
        {
          $(forms[i].dom).data(mapMeta.formDataProperty, '');

          // Clean up each form's DOM by resetting the address fields to the way they were
          for (var j = 0; j < forms[i].addresses.length; j++)
          {
            var doms = forms[i].addresses[j].getDomFields();
            for (var prop in doms)
            {
              if (config.debug)
                $(doms[prop]).css('background', 'none').attr('placeholder', '');
              $(doms[prop]).unbind('change');
            }
            if (doms['street'])
              $(doms['street']).unbind('keyup').unbind('keydown').unbind('blur');
          }

          // Unbind our form submit and submit-button click handlers
          $.each(forms, function(idx) { $(this.dom).unbind('submit', submitHandler); });
          $(config.submitSelector, forms[i].dom).each(function(idx) { $(this).unbind('click', submitHandler); });
        }

        $('.smarty-ui').undelegate('.smarty-suggestion', 'click').undelegate('.smarty-suggestion', 'mouseover').undelegate('.smarty-suggestion', 'mouseleave').remove();
        $('body').undelegate('.smarty-undo', 'click');
        $('body').undelegate('.smarty-tag-grayed', 'click');
        $(window).unbind('resize');
        $(document).unbind('keyup');

        forms = [];
        mappedAddressCount = 0;

        if (config.debug)
          console.log("Done cleaning up; ready for new mapping.");
      };

      function disableBrowserAutofill(dom) {
        //Does not disable autofill if config.autocomplete is disabled
        if(config.autocomplete > 0) {
          for (var i = 0; i < dom.getElementsByTagName("input").length; i++) {
            dom.getElementsByTagName("input")[i].autocomplete = "smartystreets";
          }
        }
      }

      function addDefaultToStateDropdown(dom) {
        if (dom.getElementsByTagName("option").length > 0) {
          if (arrayContains(stateNames, dom.getElementsByTagName("option")[0].text.toUpperCase()) ||
            arrayContains(stateAbbreviations, dom.getElementsByTagName("option")[0].text.toUpperCase())) {
            var option = document.createElement("OPTION");
            option.innerText = "State";
            option.selected = true;
            $(dom.getElementsByTagName("select")[0]).prepend(option);
            $(dom).change();
          }
        }
      }

      // ** AUTOMAPPING ** //
      this.automap = function(context)
      {
        if (config.debug)
          console.log("Automapping fields...");

        this.clean();

        //$('form').add($('iframe').contents().find('form')).each(function(idx)   // Include forms in iframes, but they must be hosted on same domain (and iframe must have already loaded)
        $('form').each(function(idx)   // For each form ...
        {
          var form = new Form(this);
          var potential = {};

          // Look for each type of field in this form
          for (var fieldName in mapMeta.identifiers)
          {
            var names = mapMeta.identifiers[fieldName].names;
            var labels = mapMeta.identifiers[fieldName].labels;

            // Find matching form elements and store them away
            potential[fieldName] = $(config.fieldSelector, this)
              .filter(function()
              {
                // This potential address input element must be within the user's set of selected elements
                return $(context).has(this).length > 0; // (Using has() is compatible with as low as jQuery 1.4)
              })
              .filter(':visible')   // No "hidden" input fields allowed
              .filter(function()
              {
                var name = lowercase(this.name), id = lowercase(this.id);

                // "Street address line 1" is a special case because "address" is an ambiguous
                // term, so we pre-screen this field by looking for exact matches.
                if (fieldName == "streets")
                {
                  for (var i = 0; i < mapMeta.street1exacts.names.length; i++)
                    if (name == mapMeta.street1exacts.names[i] || id == mapMeta.street1exacts.names[i])
                      return true;
                }

                // Now perform the main filtering.
                // If this is TRUE, then this form element is probably a match for this field type.
                var filterResult = filterDomElement(this, names, labels);

                if (fieldName == "streets")
                {
                  // Looking for "address" is a very liberal search, so we need to see if it contains another
                  // field name, too... this helps us find freeform addresses (SLAP).
                  var otherFields = ["secondary", "city", "state", "zipcode", "country", "lastline"];
                  for (var i = 0; i < otherFields.length; i ++)
                  {
                    // If any of these filters turns up true, then it's
                    // probably neither a "street" field, nor a SLAP address.
                    if (filterDomElement(this, mapMeta.identifiers[otherFields[i]].names,
                        mapMeta.identifiers[otherFields[i]].labels))
                      return false;
                  }
                }

                return filterResult;
              })
              .not(function()
              {
                // The filter above can be a bit liberal at times, so we need to filter out
                // results that are actually false positives (fields that aren't part of the address)
                // Returning true from this function excludes the element from the result set.
                var name = lowercase(this.name), id = lowercase(this.id);
                if (name == "name" || id == "name") // Exclude fields like "First Name", et al.
                  return true;
                return filterDomElement(this, mapMeta.exclude.names, mapMeta.exclude.labels);
              })
              .toArray();
          }

          // Now prepare to differentiate between street1 and street2.
          potential.street = [], potential.street2 = [];

          // If the ratio of 'street' fields to the number of addresses in the form
          // (estimated by number of city or zip fields) is about the same, it's all street1.
          if (potential.streets.length <= potential.city.length * 1.5
            || potential.streets.length <= potential.zipcode.length * 1.5)
          {
            potential.street = potential.streets;
          }
          else
          {
            // Otherwise, differentiate between the two
            for (var i = 0; i < potential.streets.length; i++)
            {
              // Try to map it to a street2 field first. If it fails, it's street1.
              // The second condition is for naming schemes like "street[]" or "address[]", where the names
              // are the same: the second one is usually street2.
              var current = potential.streets[i];
              if (filterDomElement(current, mapMeta.street2.names, mapMeta.street2.labels)
                || (i > 0 && current.name == potential.streets[i-1].name))
              {
                // Mapped it to street2
                potential.street2.push(current);
              }
              else  // Could not map to street2, so put it in street1
                potential.street.push(current);
            }
          }

          delete potential.streets; // No longer needed; we've moved them into street/street2.

          if (config.debug)
            console.log("For form " + idx + ", the initial scan found these fields:", potential);



          // Now organize the mapped fields into addresses

          // The number of addresses will be the number of street1 fields,
          // and in case we support it in the future, maybe street2, or
          // in case a mapping went a little awry.
          var addressCount = Math.max(potential.street.length, potential.street2.length);

          if (config.debug && addressCount == 0)
            console.log("No addresses were found in form " + idx + ".");

          for (var i = 0; i < addressCount; i++)
          {
            var addrObj = {};
            for (var field in potential)
            {
              var current = potential[field][i];
              if (current)
                addrObj[field] = current;
            }

            // Don't map the address if there's not enough fields for a complete address
            var hasCityAndStateOrZip = addrObj.zipcode || (addrObj.state && addrObj.city);
            var hasCityOrStateOrZip = addrObj.city || addrObj.state || addrObj.zipcode;
            if ((!addrObj.street && hasCityAndStateOrZip) || (addrObj.street && !hasCityAndStateOrZip && hasCityOrStateOrZip))
            {
              if (config.debug)
                console.log("Form " + idx + " contains some address input elements that could not be resolved to a complete address.");
              continue;
            }

            form.addresses.push(new Address(addrObj, form, "auto" + (++mappedAddressCount)));
          }

          // Save the form we just finished mapping
          disableBrowserAutofill(form.dom);
          addDefaultToStateDropdown(form.dom);
          forms.push(form);

          if (config.debug)
            console.log("Form " + idx + " is finished:", form);
        });

        if (config.debug)
          console.log("Automapping complete.");
        
        trigger("FieldsMapped");
      };


      // ** MANUAL MAPPING ** //
      this.mapFields = function(map, context)
      {
        // "map" should be an array of objects mapping field types
        // to a field by selector, all supplied by the user.
        // "context" should be the set of elements in which fields will be mapped
        // Context can be acquired like: $('#something').not('#something-else').LiveAddress( ... ); ...

        if (config.debug)
          console.log("Manually mapping fields given this data:", map);
        
        this.clean();
        var formsFound = [];
        map = map instanceof Array ? map : [map];

        for (var addrIdx in map)
        {
          var address = map[addrIdx];

          if (!address.street)
            continue;

          // Convert selectors into actual DOM references
          for (var fieldType in address)
          {
            if (fieldType != "id")
            {
              if (!arrayContains(acceptableFields, fieldType))
              { // Make sure the field name is allowed
                if (config.debug)
                  console.log("NOTICE: Field named " + fieldType + " is not allowed. Skipping...");
                delete address[fieldType];
                continue;
              }
              var matched = $(address[fieldType], context);
              if (matched.length == 0)
              { // Don't try to map an element that couldn't be matched or found at all
                if (config.debug)
                  console.log("NOTICE: No matches found for selector " + address[fieldType] + ". Skipping...");
                delete address[fieldType];
                continue;
              }
              else if (matched.parents('form').length == 0)
              { // We should only map elements inside a <form> tag; otherwise we can't bind to submit handlers later
                if (config.debug)
                  console.log("NOTICE: Element with selector \"" + address[fieldType] + "\" is not inside a <form> tag. Skipping...");
                delete address[fieldType];
                continue;
              }
              else
                address[fieldType] = matched[0];
            }
          }

          if (!((address.street) && (((address.city) && (address.state)) || (address.zipcode) || (address.lastline)
             || (!address.street2 && !address.city && !address.state && !address.zipcode && !address.lastline))))
          {
            if (config.debug)
              console.log("NOTICE: Address map (index "+addrIdx+") was not mapped to a complete street address. Skipping...");
            continue;
          }

          // Acquire the form based on the street address field (the required field)
          var formDom = $(address.street).parents('form')[0];
          var form = new Form(formDom);
          
          // Persist a reference to the form if it wasn't acquired before
          if (!$(formDom).data(mapMeta.formDataProperty))
          {
            // Mark the form as mapped then add it to our list
            $(formDom).data(mapMeta.formDataProperty, 1);
            disableBrowserAutofill(form.dom);
            addDefaultToStateDropdown(form.dom);
            formsFound.push(form);
          }
          else
          {
            // Find the form in our list since we already put it there
            for (var i = 0; i < formsFound.length; i++)
            {
              if (formsFound[i].dom == formDom)
              {
                form = formsFound[i];
                break;
              }
            }
          }

          // Add this address to the form
          mappedAddressCount ++;
          form.addresses.push(new Address(address, form, address.id));

          if (config.debug)
            console.log("Finished mapping address with ID: "+form.addresses[form.addresses.length-1].id());
        }

        forms = formsFound;
        trigger("FieldsMapped");
      };


      this.disableFields = function(address)
      {
        // Given an address, disables the input fields for the address, also the submit button
        if (!config.ui)
          return;

        var fields = address.getDomFields();
        for (var field in fields)
          $(fields[field]).prop ? $(fields[field]).prop('disabled', true) :  $(fields[field]).attr('disabled', 'disabled');

        // Disable submit buttons
        if (address.form && address.form.dom)
        {
          var buttons = $(config.submitSelector, address.form.dom);
          buttons.prop ? buttons.prop('disabled', true) :  buttons.attr('disabled', 'disabled');
        }
      };

      this.enableFields = function(address)
      {
        // Given an address, re-enables the input fields for the address
        if (!config.ui)
          return;

        var fields = address.getDomFields();
        for (var field in fields)
          $(fields[field]).prop ? $(fields[field]).prop('disabled', false) : $(fields[field]).removeAttr('disabled');

        // Enable submit buttons
        if (address.form && address.form.dom)
        {
          var buttons = $(config.submitSelector, address.form.dom);
          buttons.prop ? buttons.prop('disabled', false) : buttons.removeAttr('disabled');
        }
      };

      this.showLoader = function(addr)
      {
        if (!config.ui || !addr.hasDomFields())
          return;

        // Get position information now instead of earlier in case elements shifted since page load
        var lastFieldCorners = addr.corners(true);
        var loaderUI = $('.smarty-dots.smarty-addr-'+addr.id()).parent();

        loaderUI.css("top", (lastFieldCorners.top + lastFieldCorners.height / 2 - loaderHeight / 2) + "px")
              .css("left", (lastFieldCorners.right - loaderWidth - 10) + "px");
        $('.smarty-dots', loaderUI).show();
      };

      this.hideLoader = function(addr)
      {
        if (config.ui)
          $('.smarty-dots.smarty-addr-'+addr.id()).hide();
      };

      this.markAsValid = function(addr)
      {
        if (!config.ui || !addr)
          return;
        
        var domTag = $('.smarty-tag.smarty-tag-grayed.smarty-addr-'+addr.id());
        domTag.removeClass('smarty-tag-grayed').addClass('smarty-tag-green').attr("title", "Address verified! Click to undo.");
        $('.smarty-tag-text', domTag).text('Verified').hover(function () {
          $(this).text('Undo');
        }, function() {
          $(this).text('Verified');
        }).addClass('smarty-undo');
      };

      this.unmarkAsValid = function(addr)
      {
        var validSelector = '.smarty-tag.smarty-addr-'+addr.id();
        if (!config.ui || !addr || $(validSelector).length == 0)
          return;
        
        var domTag = $('.smarty-tag.smarty-tag-green.smarty-addr-'+addr.id());
        domTag.removeClass('smarty-tag-green').addClass('smarty-tag-grayed').attr("title", "Address not verified. Click to verify.");
        $('.smarty-tag-text', domTag).text('Verify').unbind('mouseenter mouseleave').removeClass('smarty-undo');
      };

      this.showAmbiguous = function(data)
      {
        if (!config.ui || !data.address.hasDomFields())
          return;

        var addr = data.address;
        var response = data.response;
        var corners = addr.corners();
        corners.width = Math.max(corners.width, 300);   // minimum width
        corners.height = Math.max(corners.height, response.length * 63 + 119);  // minimum height

        var html = '<div class="smarty-ui" style="top: '+corners.top+'px; left: '+corners.left+'px; width: '+corners.width+'px; height: '+corners.height+'px;">'
          + '<div class="smarty-popup smarty-addr-'+addr.id()+'" style="width: '+(corners.width - 6)+'px; height: '+(corners.height - 3)+'px;">'
          + '<div class="smarty-popup-header smarty-popup-ambiguous-header">'+config.ambiguousMessage+'<a href="javascript:" class="smarty-popup-close smarty-abort" title="Cancel">x</a></div>'
          + '<div class="smarty-choice-list">';

        for (var i = 0; i < response.raw.length; i++)
        {
          var line1 = response.raw[i].delivery_line_1, city = response.raw[i].components.city_name,
            st = response.raw[i].components.state_abbreviation,
            zip = response.raw[i].components.zipcode + "-" + response.raw[i].components.plus4_code;
          html += '<a href="javascript:" class="smarty-choice" data-index="'+i+'">'+line1+'<br>'+city+', '+st+' '+zip+'</a>';
        }

        html += '</div><div class="smarty-choice-alt">';
        html += '<a href="javascript:" class="smarty-choice smarty-choice-abort smarty-abort">Click here to change your address</a>';
        html += '<a href="javascript:" class="smarty-choice smarty-choice-override">Click here to certify the address is correct<br>('+addr.toString()+')</a>';
        html += '</div></div></div>';
        $(html).hide().appendTo('body').show(defaults.speed);

        // Scroll to it if needed
        if ($(document).scrollTop() > corners.top - 100
          || $(document).scrollTop() < corners.top - $(window).height() + 100)
        {
          $('html, body').stop().animate({
            scrollTop: $('.smarty-popup.smarty-addr-'+addr.id()).offset().top - 100
          }, 500);
        }

        data.selectors = {
          goodAddr: '.smarty-popup.smarty-addr-'+addr.id()+' .smarty-choice-list .smarty-choice',
          useOriginal: '.smarty-popup.smarty-addr-'+addr.id()+' .smarty-choice-override',
          abort: '.smarty-popup.smarty-addr-'+addr.id()+' .smarty-abort'
        };

        // User chose a candidate address
        $('body').delegate(data.selectors.goodAddr, 'click', data, function(e)
        {
          $('.smarty-popup.smarty-addr-'+addr.id()).slideUp(defaults.speed, function()
          {
            $(this).parent('.smarty-ui').remove();
            $(this).remove();
          });

          undelegateAllClicks(e.data.selectors);
          delete e.data.selectors;

          trigger("UsedSuggestedAddress", {
            address: e.data.address,
            response: e.data.response,
            invoke: e.data.invoke,
            invokeFn: e.data.invokeFn,
            chosenCandidate: response.raw[$(this).data('index')]
          });
        });

        // User wants to revert to what they typed (forced accept)
        $('body').delegate(data.selectors.useOriginal, 'click', data, function(e)
        {
          $(this).parents('.smarty-popup').slideUp(defaults.speed, function()
          {
            $(this).parent('.smarty-ui').remove();
            $(this).remove();
          });

          undelegateAllClicks(e.data.selectors);
          delete e.data.selectors;
          trigger("OriginalInputSelected", e.data);
        });

        // User presses Esc key
        $(document).keyup(data, function(e)
        {
          if (e.keyCode == 27) //Esc
          {
            undelegateAllClicks(e.data.selectors);
            delete e.data.selectors;
            userAborted($('.smarty-popup.smarty-addr-'+e.data.address.id()), e);
            suppress(e);
          }
        });

        // User clicks "x" in corner or chooses to try a different address (same effect as Esc key)
        $('body').delegate(data.selectors.abort, 'click', data, function(e)
        {
          undelegateAllClicks(e.data.selectors);
          delete e.data.selectors;
          userAborted($(this).parents('.smarty-popup'), e);
        });
      };


      this.showInvalid = function(data)
      {
        if (!config.ui || !data.address.hasDomFields())
          return;

        var addr = data.address;
        var response = data.response;
        var corners = addr.corners();
        corners.width = Math.max(corners.width, 300);   // minimum width
        corners.height = Math.max(corners.height, 180); // minimum height

        var html = '<div class="smarty-ui" style="top: '+corners.top+'px; left: '+corners.left+'px; width: '+corners.width+'px; height: '+corners.height+'px;">'
          + '<div class="smarty-popup smarty-addr-'+addr.id()+'" style="width: '+(corners.width - 6)+'px; height: '+(corners.height - 3)+'px;">'
          + '<div class="smarty-popup-header smarty-popup-invalid-header">'+config.invalidMessage+'<a href="javascript:" class="smarty-popup-close smarty-abort" title="Cancel">x</a></div>'
          + '<div class="smarty-choice-list"><a href="javascript:" class="smarty-choice smarty-choice-abort smarty-abort">Click here to change your address</a></div>'
          + '<div class="smarty-choice-alt"><a href="javascript:" class="smarty-choice smarty-choice-override">Click here to certify the address is correct<br>('+addr.toString()+')</a></div>'
          + '</div></div>';

        $(html).hide().appendTo('body').show(defaults.speed);

        data.selectors = {
          useOriginal: '.smarty-popup.smarty-addr-'+addr.id()+' .smarty-choice-override ',
          abort: '.smarty-popup.smarty-addr-'+addr.id()+' .smarty-abort'
        }

        // Scroll to it if necessary
        if ($(document).scrollTop() > corners.top - 100
          || $(document).scrollTop() < corners.top - $(window).height() + 100)
        {
          $('html, body').stop().animate({
            scrollTop: $('.smarty-popup.smarty-addr-'+addr.id()).offset().top - 100
          }, 500);
        }

        // User rejects original input and agrees to double-check it
        $('body').delegate(data.selectors.abort, 'click', data, function(e)
        {
          userAborted('.smarty-popup.smarty-addr-'+e.data.address.id(), e);
          delete e.data.selectors;
          trigger("InvalidAddressRejected", e.data);
        });

        // User certifies that what they typed is correct
        $('body').delegate(data.selectors.useOriginal, 'click', data, function(e)
        {
          userAborted('.smarty-popup.smarty-addr-'+e.data.address.id(), e);
          delete e.data.selectors;
          trigger("OriginalInputSelected", e.data);
        });

        // User presses esc key
        $(document).keyup(data, function(e)
        {
          if (e.keyCode == 27) //Esc
          {
            $(data.selectors.abort).click();
            undelegateAllClicks(e.data.selectors);
            userAborted('.smarty-popup.smarty-addr-'+e.data.address.id(), e);
          }
        });
      };

      this.isDropdown = function(dom)
      {
        return dom && ((dom.tagName || dom.nodeName || "").toUpperCase() == "SELECT");
      };
    }

    var allStatesByName = {
      "ALABAMA":"AL","ALASKA":"AK","AMERICAN SAMOA":"AS","ARIZONA":"AZ","ARKANSAS":"AR","CALIFORNIA":"CA","COLORADO":"CO","CONNECTICUT":"CT","DELAWARE":"DE","DISTRICT OF COLUMBIA":"DC","FEDERATED STATES OF MICRONESIA":"FM","FLORIDA":"FL","GEORGIA":"GA","GUAM":"GU","HAWAII":"HI","IDAHO":"ID","ILLINOIS":"IL","INDIANA":"IN","IOWA":"IA","KANSAS":"KS","KENTUCKY":"KY","LOUISIANA":"LA","MAINE":"ME","MARSHALL ISLANDS":"MH","MARYLAND":"MD","MASSACHUSETTS":"MA","MICHIGAN":"MI","MINNESOTA":"MN","MISSISSIPPI":"MS","MISSOURI":"MO","MONTANA":"MT","NEBRASKA":"NE","NEVADA":"NV","NEW HAMPSHIRE":"NH","NEW JERSEY":"NJ","NEW MEXICO":"NM","NEW YORK":"NY","NORTH CAROLINA":"NC","NORTH DAKOTA":"ND","NORTHERN MARIANA ISLANDS":"MP","OHIO":"OH","OKLAHOMA":"OK","OREGON":"OR","PALAU":"PW","PENNSYLVANIA":"PA","PUERTO RICO":"PR","RHODE ISLAND":"RI","SOUTH CAROLINA":"SC","SOUTH DAKOTA":"SD","TENNESSEE":"TN","TEXAS":"TX","UTAH":"UT","VERMONT":"VT","VIRGIN ISLANDS":"VI","VIRGINIA":"VA","WASHINGTON":"WA","WEST VIRGINIA":"WV","WISCONSIN":"WI","WYOMING":"WY",
      "ARMED FORCES EUROPE, THE MIDDLE EAST, AND CANADA":"AE","ARMED FORCES CANADA":"AE","ARMED FORCES THE MIDDLE EAST":"AE","ARMED FORCES EUROPE":"AE","ARMED FORCES PACIFIC":"AP","ARMED FORCES AMERICAS (EXCEPT CANADA)":"AA","ARMED FORCES AMERICAS":"AA"
    };
    // this listing of stateNames has West Virginia before Virginia and the Virgin Islands (most specific to least specific)
    var stateNames = ["ALABAMA","ALASKA","AMERICAN SAMOA","ARIZONA","ARKANSAS","CALIFORNIA","COLORADO","CONNECTICUT","DELAWARE","DISTRICT OF COLUMBIA","FEDERATED STATES OF MICRONESIA","FLORIDA","GEORGIA","GUAM","HAWAII","IDAHO","ILLINOIS","INDIANA","IOWA","KANSAS","KENTUCKY","LOUISIANA","MAINE","MARSHALL ISLANDS","MARYLAND","MASSACHUSETTS","MICHIGAN","MINNESOTA","MISSISSIPPI","MISSOURI","MONTANA","NEBRASKA","NEVADA","NEW HAMPSHIRE","NEW JERSEY","NEW MEXICO","NEW YORK","NORTH CAROLINA","NORTH DAKOTA","NORTHERN MARIANA ISLANDS","OHIO","OKLAHOMA","OREGON","PALAU","PENNSYLVANIA","PUERTO RICO","RHODE ISLAND","SOUTH CAROLINA","SOUTH DAKOTA","TENNESSEE","TEXAS","UTAH","VERMONT","WEST VIRGINIA","VIRGINIA","VIRGIN ISLANDS","WASHINGTON","WISCONSIN","WYOMING","ARMED FORCES EUROPE, THE MIDDLE EAST, AND CANADA","ARMED FORCES CANADA","ARMED FORCES THE MIDDLE EAST","ARMED FORCES EUROPE","ARMED FORCES PACIFIC","ARMED FORCES AMERICAS (EXCEPT CANADA)","ARMED FORCES AMERICAS"];
    var stateAbbreviations = ["AL","AK","AS","AZ","AR","CA","CO","CT","DE","DC","FM","FL","GA","GU","HI","ID","IL","IN","IA","KS","KY","LA","ME","MH","MD","MA","MI","MN","MS","MO","MT","NE","NV","NH","NJ","NM","NY","NC","ND","MP","OH","OK","OR","PW","PA","PR","RI","SC","SD","TN","TX","UT","VT","VI","VA","WA","WV","WI","WY","AE","AP","AA"];

    /*
      Represents an option in a state dropdown menu. We look for any clues in the value or text
      as to what state the option might represent so that when a verified result comes back we
      can update the dropdown accordingly. Also allows us to submit the correct value to the server.
      In many cases the value is a key that is only meaningful to the server-side code.
    */
    function StateDropdownOption(option)
    {
      var self = this; // Pointer to self so that internal functions can reference its parent

      this.standard = function() {

        for (var x in stateNames) {
          var name = stateNames[x];

          // look in the option.text for the full state name...
          var text = option.text.toUpperCase();
          if (text.indexOf(name) > -1)
            return allStatesByName[name];

          // look in the option.value for the full state name...
          var value = option.value.toUpperCase();
          if (value.indexOf(name) > -1)
            return allStatesByName[name];
        }

        for (var x in stateAbbreviations) {
          var abbreviation = stateAbbreviations[x];

          // look in the option.text for a state abbreviation...
          var words = option.text.split(/[ ,]+/);
          for (var y in words) {
            var word = words[y].toUpperCase();
            if (abbreviation === word)
              return abbreviation;
          }

          // look in the option.value for a state abbreviation...
          var words = option.value.split(/[ ,]+/);
          for (var y in words) {
            var word = words[y].toUpperCase();
            if (abbreviation === word)
              return abbreviation;
          }
        }

        return '';
      }

      this.value = function() {
        return option.value ? option.value : option.text;
      }
    }

    /*
      Represents an address inputted by the user, whether it has been verified yet or not.
      formObj must be a Form OBJECT, not a <form> tag... and the addressID is optional.
    */
    function Address(domMap, formObj, addressID)
    {
      // PRIVATE MEMBERS //

      var self = this;              // Pointer to self so that internal functions can reference its parent
      var fields;                 // Data values and references to DOM elements
      var id;                   // An ID by which to classify this address on the DOM
      var statesOptions = {};           // Stores the actual state dropdown option values that correspond to the option names
      var totalStatesOptions = 0;         // Total number of options in the state dropdown

      var state = "accepted";           // Can be: "accepted" or "changed"
      // Example of a field:  street: { value: "123 main", dom: DOMElement, undo: "123 mai"}
      // Some of the above fields will only be mapped manually, not automatically.
      
      // Private method that actually changes the address. The keepState parameter is
      // used by the results of verification after an address is chosen; (or an "undo"
      // on a freeform address), otherwise an infinite loop of requests is executed
      // because the address keeps changing! (Set "suppressAutoVerify" to true when coming from the "Undo" link)  
      var doSet = function(key, value, updateDomElement, keepState, sourceEvent, suppressAutoVerify)
      {
        if (!arrayContains(acceptableFields, key))  // Skip "id" and other unacceptable fields
          return false;

        if (!fields[key])
          fields[key] = {};

        value = value.replace(/<|>/g, "");  // prevents script injection attacks (< and > aren't in addresses, anyway)

        var differentVal = fields[key].value != value;

        fields[key].undo = fields[key].value || "";
        fields[key].value = value;

        if (updateDomElement && fields[key].dom) {

          // figure out which state dropdown option should be selected, if any...
          if (key === 'state' && totalStatesOptions > 0 && value in statesOptions) {
            value = statesOptions[value].value();
          }

          $(fields[key].dom).val(value);
        }

        var eventMeta = {
          sourceEvent: sourceEvent, // may be undefined
          field: key,
          address: self,
          value: value,
          suppressAutoVerification: suppressAutoVerify || false
        };

        if (differentVal && !keepState)
        {
          ui.unmarkAsValid(self);
          var uiTag = config.ui ? $('.smarty-ui .smarty-tag.smarty-addr-'+id) : undefined;
          if (self.isDomestic())
          {
            if (uiTag && !uiTag.is(':visible'))
              uiTag.show(); // Show checkmark tag if address is in US
            self.unaccept();
            trigger("AddressChanged", eventMeta);
          }
          else
          {
            if (uiTag && uiTag.is(':visible'))
              uiTag.hide(); // Hide checkmark tag if address is non-US
            self.accept({ address: self }, false);
          }
        }

        return true;
      };

      // PUBLIC MEMBERS //

      this.form = formObj;  // Reference to the parent form object (NOT THE DOM ELEMENT)
      this.verifyCount = 0; // Number of times this address was submitted for verification
      this.lastField;     // The last field found (last to appear in the DOM) during mapping, or the order given
      this.active = true;   // If true, verify the address. If false, pass-thru entirely.
      this.lastStreetInput = "";  // Used by autocomplete to detect changes

      // Constructor-esque functionality (save the fields in this address object)
      this.load = function(domMap, addressID)
      {
        fields = {};
        id = addressID ? addressID.replace(/[^a-z0-9_\-]/ig, '') : randomInt(1, 99999);   // Strips non-selector-friendly characters

        if (typeof domMap === 'object') // can be an actual map to DOM elements or just field/value data
        {
          // Find the last field likely to appear on the DOM (used for UI attachments)
          this.lastField = domMap.lastline || domMap.zipcode || domMap.state || domMap.city || domMap.street;

          var isEmpty = true; // Whether the address has data in it (pre-populated) -- first assume it is empty.

          for (var prop in domMap)
          {
            if (!arrayContains(acceptableFields, prop)) // Skip "id" and any other unacceptable field
              continue;

            var elem, val, elemArray, isData;
            try
            {
              elem = $(domMap[prop]);
              elemArray = elem.toArray();
              isData = elemArray ? elemArray.length == 0 : false;
            }
            catch (e) { isData = true; }

            if (isData) // Didn't match an HTML element, so treat it as an address string ("street1" data) instead
              val = domMap[prop] || "";
            else
              val = elem.val() || "";

            // Here we analyze the state dropdown so we can update it with verified address results later.
            if (prop === "state" && elemArray[0] != undefined && elemArray[0].length != undefined) { // Is there a better way to detect a state dropdown from here?
              $('option', elem).each(function(i){
                var option = new StateDropdownOption(this);
                var standardized = option.standard();
                statesOptions[standardized] = option;
                totalStatesOptions++;
              });
            }

            fields[prop] = {};
            fields[prop].value = val;
            fields[prop].undo = val;
            isEmpty = isEmpty ? val.length == 0 || ui.isDropdown(domMap[prop]) : false;  // dropdowns could have an initial value, yet the address may be "empty" (<option value="None" selected>(Select state)</option>) ...

            if (!isData)
            {
              if (config.debug)
              {
                elem.css('background', '#FFFFCC');
                elem.attr('placeholder', prop + ":" + id);
              }
              fields[prop].dom = domMap[prop];
            }


            // This has to be passed in at bind-time; they cannot be obtained at run-time
            var data = {
              address: this,
              field: prop,
              value: val
            };
            
            // Bind the DOM element to needed events, passing in the data above
            // NOTE: When the user types a street, city, and state, then hits Enter without leaving
            // the state field, this change() event fires before the form is submitted, and if autoVerify is
            // on, the verification will not invoke form submit, because it didn't come from a form submit.
            // This is known behavior and is actually proper functioning in this uncommon edge case.
            !isData && $(domMap[prop]).change(data, function(e)
            {
              e.data.address.set(e.data.field, e.target.value, false, false, e, false);
            });
          }

          if (!isEmpty)
            state = "changed";
        }
      };

      // Run the "constructor" to load up the address
      this.load(domMap, addressID);


      this.set = function(key, value, updateDomElement, keepState, sourceEvent, suppressAutoVerify)
      {
        if (typeof key === 'string' && arguments.length >= 2)
          return doSet(key, value, updateDomElement, keepState, sourceEvent, suppressAutoVerify);
        else if (typeof key === 'object')
        {
          var successful = true;
          for (var prop in key)
            successful = doSet(prop, key[prop], updateDomElement, keepState, sourceEvent, suppressAutoVerify) ? successful : false;
          return successful;
        }
      };

      this.replaceWith = function(resp, updateDomElement, e)
      {
        // Given the response from an API request associated with this address,
        // replace the values in the address... and if updateDomElement is true,
        // then change the values in the fields on the page accordingly.
        
        if (typeof resp === 'array' && resp.length > 0)
          resp = resp[0];

        if (self.isFreeform())
        {
          var singleLineAddr = (resp.addressee ? resp.addressee + " " : "") +
            (resp.delivery_line_1 ? resp.delivery_line_1 + " " : "") +
            (resp.delivery_line_2 ? resp.delivery_line_2 + " " : "") +
            (resp.components.urbanization ? resp.components.urbanization + " " : "") +
            (resp.last_line ? resp.last_line : "");

          self.set("street", singleLineAddr, updateDomElement, true, e, false);
        }
        else
        {
          if (resp.addressee)
            self.set("addressee", resp.addressee, updateDomElement, true, e, false);
          if (resp.delivery_line_1)
            self.set("street", resp.delivery_line_1, updateDomElement, true, e, false);
          if (resp.last_line && fields["lastline"])
            self.set("lastline", resp.last_line, updateDomElement, true, e, false);
          self.set("street2", resp.delivery_line_2 || "", updateDomElement, true, e, false);  // Rarely used; must otherwise be blank.
          self.set("secondary", "", updateDomElement, true, e, false);  // Not used in standardized addresses
          if (resp.components.urbanization)
            self.set("urbanization", resp.components.urbanization, updateDomElement, true, e, false);
          if (resp.components.city_name)
            self.set("city", resp.components.city_name, updateDomElement, true, e, false);
          if (resp.components.state_abbreviation)
            self.set("state", resp.components.state_abbreviation, updateDomElement, true, e, false);
          if (resp.components.zipcode && resp.components.plus4_code)
            self.set("zipcode", resp.components.zipcode + "-" + resp.components.plus4_code, updateDomElement, true, e, false);
        }
      };

      this.corners = function(lastField)
      {
        var corners = {};

        if (!lastField)
        {
          for (var prop in fields)
          {
            if (!fields[prop].dom || !$(fields[prop].dom).is(':visible'))
              continue;

            var dom = fields[prop].dom;
            var offset = $(dom).offset();
            offset.right = offset.left + $(dom).outerWidth(false);
            offset.bottom = offset.top + $(dom).outerHeight(false);

            corners.top = !corners.top ? offset.top : Math.min(corners.top, offset.top);
            corners.left = !corners.left ? offset.left : Math.min(corners.left, offset.left);
            corners.right = !corners.right ? offset.right : Math.max(corners.right, offset.right);
            corners.bottom = !corners.bottom ? offset.bottom : Math.max(corners.bottom, offset.bottom);
          }
        }
        else
        {
          var jqDom = $(self.lastField);
          corners = jqDom.offset();
          corners.right = corners.left + jqDom.outerWidth(false);
          corners.bottom = corners.top + jqDom.outerHeight(false);
        }

        corners.width = corners.right - corners.left;
        corners.height = corners.bottom - corners.top;

        return corners;
      };

      this.verify = function(invoke, invokeFn)
      {
        // Invoke contains the element to "click" on once we're all done, or is a user-defined callback function (may also be undefined)
        if (!invoke && !self.enoughInput())
        {
          if (config.debug)
            console.log("NOTICE: The address does not have enough input to verify. Since no callback is specified, there is nothing to do.");
          return trigger("Completed", { address: self, invoke: invoke, invokeFn: invokeFn, response: new Response([]) });
        }

        if (!self.enoughInput())
          return trigger("AddressWasInvalid", { address: self, response: new Response([]), invoke: invoke, invokeFn: invokeFn });

        ui.disableFields(self);
        self.verifyCount ++;
        var addrData = self.toRequest();
        var credentials = config.token ? "auth-id="+encodeURIComponent(config.key)+"&auth-token="+encodeURIComponent(config.token) : "auth-token="+encodeURIComponent(config.key);

        $.ajax(
        {
          url: config.requestUrl+"?"+credentials+"&plugin="+encodeURIComponent(instance.version)+(config.debug ? "_debug" : "")+"&callback=?",
          dataType: "jsonp",
          data: addrData,
          timeout: config.timeout
        })
        .done(function(response, statusText, xhr)
        {
          trigger("ResponseReceived", { address: self, response: new Response(response), invoke: invoke, invokeFn: invokeFn });
        })
        .fail(function(xhr, statusText)
        {
          trigger("RequestTimedOut", { address: self, status: statusText, invoke: invoke, invokeFn: invokeFn });
          self.verifyCount --;      // Address verification didn't actually work, so don't count it
        });

        // Remember, the above callbacks happen later and this function is
        // executed immediately afterward, probably before a response is received.
        trigger("RequestSubmitted", { address: self });
      };

      this.enoughInput = function()
      {
        var stateText;

        // Checks for state dropdown
        if(fields.state)
        {
          stateText = fields.state.value;
          if(fields.state.dom !== undefined && fields.state.dom.length !== undefined)
          {
            if(fields.state.dom.selectedIndex < 1)
              stateText = "";
            else
              stateText = fields.state.dom.options[fields.state.dom.selectedIndex].text;
          }
        }
        return (fields.street && fields.street.value)
          && (
            (
              (fields.city && fields.city.value)
              && (fields.state && stateText.length > 0)
            )
            || (fields.zipcode && fields.zipcode.value)
            || (fields.lastline && fields.lastline.value)
            || (!fields.street2 && !fields.city && !fields.state && !fields.zipcode && !fields.lastline) // Allow freeform addresses (only a street field)
             );
      };

      this.toRequest = function()
      {
        var obj = {};
        if(fields.hasOwnProperty("lastline") && fields.hasOwnProperty("city") && fields.hasOwnProperty("state") && fields.hasOwnProperty("zipcode")) {
              delete fields.city;
              delete fields.state;
              delete fields.zipcode
            }
        for (var key in fields)
        {
          var keyval = {};
          if(key === "state" && fields[key].dom.length > 0)
            keyval[key] = fields[key].dom[fields[key].dom.selectedIndex].text;
          else 
            keyval[key] = fields[key].value.replace(/\r|\n/g, " "); // Line breaks to spaces
          $.extend(obj, keyval);
        }
        return $.extend(obj, {candidates: config.candidates});
      };

      this.toString = function()
      {
        if(fields.state){
          var stateText = fields.state.value;

          // Sets state to text from dropdown, opposed to the value
          console.log('fields.state:')
          console.log(fields.state)
          console.log('fields.state.dom:')
          console.log(fields.state.dom)
          if(fields.state.dom.length > 0)
          {
            stateText = fields.state.dom[fields.state.dom.selectedIndex].text;
          }
        }
        return (fields.street ? fields.street.value + " " : "")
          + (fields.street2 ? fields.street2.value + " " : "")
          + (fields.secondary ? fields.secondary.value + " " : "")
          + (fields.city ? fields.city.value + " " : "")
          + (fields.state ? stateText + " " : "")
          + (fields.zipcode ? fields.zipcode.value : "");
      }

      this.abort = function(event, keepAccept)
      {
        keepAccept = typeof keepAccept === 'undefined' ? false : keepAccept;
        if (!keepAccept)
          self.unaccept();
        delete self.form.processing;
        return suppress(event);
      }

      // Based on the properties in "fields," determines if this is a single-line address
      this.isFreeform = function()
      {
        return fields.street && !fields.street2 && !fields.secondary
            && !fields.addressee && !fields.city && !fields.state
            && !fields.zipcode && !fields.urbanization && !fields.lastline;
      }
      
      this.get = function(key)
      {
        return fields[key] ? fields[key].value : null
      };

      this.undo = function(updateDomElement)
      {
        updateDomElement = typeof updateDomElement === 'undefined' ? true : updateDomElement;
        for (var key in fields)
          this.set(key, fields[key].undo, updateDomElement, false, undefined, true);
      };

      this.accept = function(data, showValid)
      {
        showValid = typeof showValid === 'undefined' ? true : showValid;
        state = "accepted";
        ui.enableFields(self);
        if (showValid)  // If user chooses original input or the request timed out, the address wasn't "verified"
          ui.markAsValid(self);
        trigger("AddressAccepted", data);
      };

      this.unaccept = function()
      {
        state = "changed";
        ui.unmarkAsValid(self);
        return self;
      };

      this.getUndoValue = function(key)
      {
        return fields[key].undo;
      };

      this.status = function()
      {
        return state;
      };

      this.getDomFields = function()
      {
        // Gets just the DOM elements for each field
        var obj = {};
        for (var prop in fields)
        {
          var ext = {};
          ext[prop] = fields[prop].dom;
          $.extend(obj, ext);
        }
        return obj;
      };

      this.hasDomFields = function()
      {
        for (var prop in fields)
          if (fields[prop].dom)
            return true;
      }

      this.isDomestic = function()
      {
        if (!fields.country)
          return true;
        var countryValue = fields.country.value.toUpperCase().replace(/\.|\s|\(|\)|\\|\/|-/g, "");
        var usa = ["", "0", "1", "COUNTRY", "NONE", "US", "USA", "USOFA", "USOFAMERICA", "AMERICAN", // 1 is AmeriCommerce
              "UNITEDSTATES", "UNITEDSTATESAMERICA",  "UNITEDSTATESOFAMERICA", "AMERICA",
              "840", "223", "AMERICAUNITEDSTATES", "AMERICAUS", "AMERICAUSA"];  // 840 is ISO: 3166; and 223 is some shopping carts
        return arrayContains(usa, countryValue) || fields.country.value == "-1";
      }

      this.autocompleteVisible = function()
      {
        return config.ui && config.autocomplete && $('.smarty-autocomplete.smarty-addr-'+self.id()).is(':visible');
      }

      this.id = function()
      {
        return id;
      };
    }


    /*
      Represents a <form> tag which contains mapped fields.
    */
    function Form(domElement)
    {
      this.addresses = [];
      this.dom = domElement;

      this.activeAddressesNotAccepted = function()
      {
        var addrs = [];
        for (var i = 0; i < this.addresses.length; i++)
        {
          var addr = this.addresses[i];
          if (addr.status() != "accepted" && addr.active)
            addrs.push(addr);
        }
        return addrs;
      };

      this.allActiveAddressesAccepted = function()
      {
        return this.activeAddressesNotAccepted().length == 0;
      };
    }


    /*
      Wraps output from the API in an easier-to-handle way
    */

    function Response(json)
    {
      // PRIVATE MEMBERS //

      var checkBounds = function(idx)
      {
        // Ensures that an index is within the number of candidates
        if (idx >= json.length || idx < 0)
        {
          if (json.length == 0)
            throw new Error("Candidate index is out of bounds (no candidates returned; requested " + idx + ")");
          else
            throw new Error("Candidate index is out of bounds (" + json.length + " candidates; indicies 0 through " + (json.length - 1) + " available; requested " + idx + ")");
        }
      };
      
      var maybeDefault = function(idx)
      {
        // Assigns index to 0, the default value, if no value is passed in
        return typeof idx === 'undefined' ? 0 : idx;
      };


      // PUBLIC-FACING MEMBERS //

      this.raw = json;
      this.length = json.length;

      this.isValid = function()
      {
        return this.length == 1;
      };

      this.isInvalid = function()
      {
        return this.length == 0;
      };

      this.isAmbiguous = function()
      {
        return this.length > 1;
      };

      // These next functions are not comprehensive, but helpful for common tasks.

      this.isMissingSecondary = function(idx)
      {
        idx = maybeDefault(idx); checkBounds(idx);
        return this.raw[idx].analysis.dpv_footnotes.indexOf("N1") > -1
            || this.raw[idx].analysis.dpv_footnotes.indexOf("R1") > -1
            || (this.raw[idx].analysis.footnotes && this.raw[idx].analysis.footnotes.indexOf("H#") > -1);
      };

      this.isBadSecondary = function(idx)
      {
        idx = maybeDefault(idx); checkBounds(idx);
        return this.raw[idx].analysis.footnotes && this.raw[idx].analysis.footnotes.indexOf("S#") > -1;
      }

      this.componentChanged = function(idx)
      {
        idx = maybeDefault(idx); checkBounds(idx);
        return this.raw[idx].analysis.footnotes && this.raw[idx].analysis.footnotes.indexOf("L#") > -1;
      }

      this.betterAddressExists = function(idx)
      {
        idx = maybeDefault(idx); checkBounds(idx);
        return this.raw[idx].analysis.footnotes && this.raw[idx].analysis.footnotes.indexOf("P#") > -1;
      }

      this.isExactMatch = function(idx)
      {
        idx = maybeDefault(idx); checkBounds(idx);
        return this.raw[idx].analysis.footnotes && this.raw[idx].analysis.dpv_footnotes == "AABB";
      }

      this.isUniqueZipCode = function(idx)
      {
        idx = maybeDefault(idx); checkBounds(idx);
        return this.raw[idx].analysis.dpv_footnotes.indexOf("U1") > -1
            || (this.raw[idx].analysis.footnotes && this.raw[idx].analysis.footnotes.indexOf("Q#") > -1);
      }

      this.fixedAbbreviations = function(idx)
      {
        idx = maybeDefault(idx); checkBounds(idx);
        return this.raw[idx].analysis.footnotes && this.raw[idx].analysis.footnotes.indexOf("N#") > -1;
      }

      this.fixedZipCode = function(idx)
      {
        idx = maybeDefault(idx); checkBounds(idx);
        return this.raw[idx].analysis.footnotes && this.raw[idx].analysis.footnotes.indexOf("A#") > -1;
      }

      this.fixedSpelling = function(idx)
      {
        idx = maybeDefault(idx); checkBounds(idx);
        return this.raw[idx].analysis.footnotes.indexOf("B#") > -1
          || (this.raw[idx].analysis.footnotes && this.raw[idx].analysis.footnotes.indexOf("M#") > -1);
      }

      this.isBuildingDefault = function(idx)
      {
        idx = maybeDefault(idx); checkBounds(idx);
        return this.raw[idx].metadata.building_default_indicator;
      }

      this.isMilitary = function(idx)
      {
        idx = maybeDefault(idx); checkBounds(idx);
        return this.raw[idx].analysis.dpv_footnotes.indexOf("F1") > -1;
      }

      this.hasExtraSecondary = function(idx)
      {
        idx = maybeDefault(idx); checkBounds(idx);
        return this.raw[idx].analysis.dpv_footnotes.indexOf("CC") > -1;
      }

      this.isLacsLink = function(idx)
      {
        idx = maybeDefault(idx); checkBounds(idx);
        return this.raw[idx].analysis.lacslink_code == "A";
      }

      this.isCommercial = function(idx)
      {
        idx = maybeDefault(idx); checkBounds(idx);
        return this.raw[idx].metadata.rdi == "Commercial";
      }

      this.isResidential = function(idx)
      {
        idx = maybeDefault(idx); checkBounds(idx);
        return this.raw[idx].metadata.rdi == "Residential";
      }
    }
    

    /*
     *  EVENT HANDLER "SHTUFF"
     */


    /*
      Called every time a LiveAddress event is raised.
      This allows us to maintain the binding even if the
      callback function is changed later.
      "event" is the actual event object, and
      "data" is anything extra to pass to the event handler.
    */
    function HandleEvent(event, data)
    {
      var handler = EventHandlers[event.type];
      if (handler)
        handler(event, data);
    }

    // Submits a form by calling `click` on a button element or `submit` on a form element
    var submitForm = function(invokeOn, invokeFunction)
    {
      if (invokeOn && typeof invokeOn !== 'function' && invokeFunction)
        if (invokeFunction == "click")
          $(invokeOn).trigger('click'); // Very particular: we MUST fire the native 'click' event!
        else if (invokeFunction == "submit")
          $(invokeOn).submit(); // For submit(), we have to use jQuery's, so that all its submit handlers fire.
    };

    var EventHandlers = {
      FieldsMapped: function(event, data)
      {
        if (config.debug)
          console.log("EVENT:", "FieldsMapped", "(Fields mapped to their respective addresses)", event, data);

        // We wait until the window is all loaded in case some elements are still loading
        window.loaded ? ui.postMappingOperations() : $(window).load(ui.postMappingOperations);
      },

      MapInitialized: function(event, data)
      {
        if (config.debug)
          console.log("EVENT:", "MapInitialized", "(Mapped fields have been wired up to the window"+(config.ui ? ", document, and UI" : " and document")+")", event, data);
      },

      AutocompleteInvoked: function(event, data)
      {
        if (config.debug)
          console.log("EVENT:", "AutocompleteInvoked", "(A request is about to be sent to the autocomplete service)", event, data);
        ui.requestAutocomplete(event, data);
      },

      AutocompleteReceived: function(event, data)
      {
        if (config.debug)
          console.log("EVENT:", "AutocompleteReceived", "(A response has just been received from the autocomplete service)", event, data);
        ui.showAutocomplete(event, data);
      },

      AutocompleteUsed: function(event, data)
      {
        if (config.debug)
          console.log("EVENT:", "AutocompleteUsed", "(A suggested address was used from the autocomplete service)", event, data);
      },

      AddressChanged: function(event, data)
      {
        if (config.debug)
          console.log("EVENT:", "AddressChanged", "(Address changed)", event, data);
        
        // If autoVerify is on, AND there's enough input in the address,
        // AND it hasn't been verified automatically before -OR- it's a freeform address,
        // AND autoVerification isn't suppressed (from an Undo click, even on a freeform address)
        // AND it has a DOM element (it's not just a programmatic Address object)
        // AND the address is "active" for verification
        // AND the autocomplete suggestions aren't visible
        // AND the form, if any, isn't already chewing on an address...
        // THEN verification has been invoked.
        if (config.autoVerify && data.address.enoughInput()
          && (data.address.verifyCount == 0 || data.address.isFreeform())
          && !data.suppressAutoVerification
          && data.address.hasDomFields()
          && data.address.active
          && !data.address.autocompleteVisible()
          && (data.address.form && !data.address.form.processing))
          trigger("VerificationInvoked", { address: data.address });
      },

      VerificationInvoked: function(event, data)
      {
        if (config.debug)
          console.log("EVENT:", "VerificationInvoked", "(Address verification invoked)", event, data);
        
        // Abort now if an address in the same form is already being processed
        if (!data.address || (data.address && data.address.form && data.address.form.processing))
        {
          if (config.debug)
            console.log("NOTICE: VerificationInvoked event handling aborted. Address is missing or an address in the same form is already processing.");
          return;
        }
        else if (data.address.status() == "accepted" && !data.verifyAccepted)
        {
          if (config.debug)
            console.log("NOTICE: VerificationInvoked raised on an accepted or un-changed address. Nothing to do.");
          return trigger("Completed", data);
        }
        else if (data.address.form)
          data.address.form.processing = true;

        data.address.verify(data.invoke, data.invokeFn);
      },

      RequestSubmitted: function(event, data)
      {
        if (config.debug)
          console.log("EVENT:", "RequestSubmitted", "(Request submitted to server)", event, data);
        
        ui.showLoader(data.address);
      },

      ResponseReceived: function(event, data)
      {
        if (config.debug)
          console.log("EVENT:", "ResponseReceived", "(Response received from server, but has not been inspected)", event, data);

        ui.hideLoader(data.address);
        
        if (typeof data.invoke === "function")
          data.invoke(data.response); // User-defined callback function; we're all done here.
        else
        {
          if (data.response.isInvalid())
            trigger("AddressWasInvalid", data);
          else if (data.response.isValid())
            trigger("AddressWasValid", data);
          else
            trigger("AddressWasAmbiguous", data);
        }
      },

      RequestTimedOut: function(event, data)
      {
        if (config.debug)
          console.log("EVENT:", "RequestTimedOut", "(Request timed out)", event, data);

        if (data.address.form)
          delete data.address.form.processing;  // Tell the potentially duplicate event handlers that we're done.

        // If this was a form submit, don't let a network failure hold them back; just accept it and move on
        if (data.invoke)
          data.address.accept(data, false);

        ui.enableFields(data.address);
        ui.hideLoader(data.address);
      },

      AddressWasValid: function(event, data)
      {
        if (config.debug)
          console.log("EVENT:", "AddressWasValid", "(Response indicates input address was valid)", event, data);

        var addr = data.address;
        var resp = data.response;

        data.response.chosen = resp.raw[0];
        addr.replaceWith(resp.raw[0], true, event);
        addr.accept(data);
      },

      AddressWasAmbiguous: function(event, data)
      {
        if (config.debug)
          console.log("EVENT:", "AddressWasAmbiguous", "(Response indiciates input address was ambiguous)", event, data);

        ui.showAmbiguous(data);
      },

      AddressWasInvalid: function(event, data)
      {
        if (config.debug)
          console.log("EVENT:", "AddressWasInvalid", "(Response indicates input address was invalid)", event, data);

        ui.showInvalid(data);
      },

      OriginalInputSelected: function(event, data)
      {
        if (config.debug)
          console.log("EVENT:", "OriginalInputSelected", "(User chose to use original input)", event, data);

        data.address.accept(data, false);
      },

      UsedSuggestedAddress: function(event, data)
      {
        if (config.debug)
          console.log("EVENT:", "UsedSuggestedAddress", "(User chose to a suggested address)", event, data);

        data.response.chosen = data.chosenCandidate;
        data.address.replaceWith(data.chosenCandidate, true, event);
        data.address.accept(data);
      },

      InvalidAddressRejected: function(event, data)
      {
        if (config.debug)
          console.log("EVENT:", "InvalidAddressRejected", "(User chose to correct an invalid address)", event, data);
        
        if (data.address.form)
          delete data.address.form.processing;  // We're done with this address and ready for the next, potentially

        trigger("Completed", data);
      },

      AddressAccepted: function(event, data)
      {
        if (config.debug)
          console.log("EVENT:", "AddressAccepted", "(Address marked accepted)", event, data);

        if (!data)
          data = {};

        if (data.address && data.address.form)
          delete data.address.form.processing;  // We're done with this address and ready for the next, potentially
        
        // If this was the result of a form submit, re-submit the form (whether by clicking the button or raising form submit event)
        if (data.invoke && data.invokeFn)
          submitForm(data.invoke, data.invokeFn);

        trigger("Completed", data);
      },

      Completed: function(event, data)
      {
        if (config.debug)
          console.log("EVENT:", "Completed", "(All done)", event, data);

        if (data.address)
        {
          ui.enableFields(data.address);
          if (data.address.form)
            delete data.address.form.processing;  // We're done with this address and ready for the next, potentially
        }
      }
    };


    /*
     *  MISCELLANEOUS
     */

    function arrayContains(array, subject)
    {
      // See if an array contains a particular value
      for (var i in array)
        if (array[i] === subject) return true;
      return false;
    }

    function randomInt(min, max)
    {
      // Generate a random integer between min and max
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function lowercase(string)
    {
      // Return an empty string if not defined, or a lowercase string with '[]' stripped.
      return string ? string.toLowerCase().replace('[]', '') : '';
    }

    function trigger(eventType, metadata)
    {
      // Raise an event (in our case, a custom event)
      $(document).triggerHandler(eventType, metadata);
    }

    function bind(eventType)
    {
      // Bind a custom handler to an event
      $(document).bind(eventType, HandleEvent);
    }

    function suppress(event)
    {
      // Used to prevent form submits, and stop other events if needed
      if (!event) return false;
      if (event.preventDefault) event.preventDefault();
      if (event.stopPropagation) event.stopPropagation();
      if (event.stopImmediatePropagation) event.stopImmediatePropagation();
      event.cancelBubble = true;
      return false;
    }

  })(jQuery, window, document);
</script>


</body></html>