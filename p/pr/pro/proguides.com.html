<!--The following is the downloaded HTML source of the proguides.com privacy policy that was archived on 2019-10-01.
 Please check the original snapshot on the Wayback Machine (https://web.archive.org/web/20191001044929id_/https%3A//www.proguides.com/privacy_policy) for the most accurate reproduction.-->

<!DOCTYPE html><html lang="en"><head>
<title>Privacy Policy | ProGuides</title>

<meta charset="utf-8"><script src="https://js-agent.newrelic.com/nr-1130.min.js"></script><script async="" src="https://cdn.userleap.com/shim.js?id=pY1uiEs0qA"></script><script type="text/javascript" async="" src="https://cdn.amplitude.com/libs/amplitude-4.4.0-min.gz.js"></script><script async="" src="//static.ads-twitter.com/uwt.js"></script><script async="" src="https://sc-static.net/scevent.min.js"></script><script async="" src="https://connect.facebook.net/en_US/fbevents.js"></script><script async="" src="//www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.NREUM||(NREUM={}),__nr_require=function(e,n,t){function r(t){if(!n[t]){var o=n[t]={exports:{}};e[t][0].call(o.exports,function(n){var o=e[t][1][n];return r(o||n)},o,o.exports)}return n[t].exports}if("function"==typeof __nr_require)return __nr_require;for(var o=0;o<t.length;o++)r(t[o]);return r}({1:[function(e,n,t){function r(){}function o(e,n,t){return function(){return i(e,[c.now()].concat(u(arguments)),n?null:this,t),n?void 0:this}}var i=e("handle"),a=e(3),u=e(4),f=e("ee").get("tracer"),c=e("loader"),s=NREUM;"undefined"==typeof window.newrelic&&(newrelic=s);var p=["setPageViewName","setCustomAttribute","setErrorHandler","finished","addToTrace","inlineHit","addRelease"],d="api-",l=d+"ixn-";a(p,function(e,n){s[n]=o(d+n,!0,"api")}),s.addPageAction=o(d+"addPageAction",!0),s.setCurrentRouteName=o(d+"routeName",!0),n.exports=newrelic,s.interaction=function(){return(new r).get()};var m=r.prototype={createTracer:function(e,n){var t={},r=this,o="function"==typeof n;return i(l+"tracer",[c.now(),e,t],r),function(){if(f.emit((o?"":"no-")+"fn-start",[c.now(),r,o],t),o)try{return n.apply(this,arguments)}catch(e){throw f.emit("fn-err",[arguments,this,e],t),e}finally{f.emit("fn-end",[c.now()],t)}}}};a("actionText,setName,setAttribute,save,ignore,onEnd,getContext,end,get".split(","),function(e,n){m[n]=o(l+n)}),newrelic.noticeError=function(e,n){"string"==typeof e&&(e=new Error(e)),i("err",[e,c.now(),!1,n])}},{}],2:[function(e,n,t){function r(e,n){if(!o)return!1;if(e!==o)return!1;if(!n)return!0;if(!i)return!1;for(var t=i.split("."),r=n.split("."),a=0;a<r.length;a++)if(r[a]!==t[a])return!1;return!0}var o=null,i=null,a=/Version\/(\S+)\s+Safari/;if(navigator.userAgent){var u=navigator.userAgent,f=u.match(a);f&&u.indexOf("Chrome")===-1&&u.indexOf("Chromium")===-1&&(o="Safari",i=f[1])}n.exports={agent:o,version:i,match:r}},{}],3:[function(e,n,t){function r(e,n){var t=[],r="",i=0;for(r in e)o.call(e,r)&&(t[i]=n(r,e[r]),i+=1);return t}var o=Object.prototype.hasOwnProperty;n.exports=r},{}],4:[function(e,n,t){function r(e,n,t){n||(n=0),"undefined"==typeof t&&(t=e?e.length:0);for(var r=-1,o=t-n||0,i=Array(o<0?0:o);++r<o;)i[r]=e[n+r];return i}n.exports=r},{}],5:[function(e,n,t){n.exports={exists:"undefined"!=typeof window.performance&&window.performance.timing&&"undefined"!=typeof window.performance.timing.navigationStart}},{}],ee:[function(e,n,t){function r(){}function o(e){function n(e){return e&&e instanceof r?e:e?f(e,u,i):i()}function t(t,r,o,i){if(!d.aborted||i){e&&e(t,r,o);for(var a=n(o),u=v(t),f=u.length,c=0;c<f;c++)u[c].apply(a,r);var p=s[y[t]];return p&&p.push([b,t,r,a]),a}}function l(e,n){h[e]=v(e).concat(n)}function m(e,n){var t=h[e];if(t)for(var r=0;r<t.length;r++)t[r]===n&&t.splice(r,1)}function v(e){return h[e]||[]}function g(e){return p[e]=p[e]||o(t)}function w(e,n){c(e,function(e,t){n=n||"feature",y[t]=n,n in s||(s[n]=[])})}var h={},y={},b={on:l,addEventListener:l,removeEventListener:m,emit:t,get:g,listeners:v,context:n,buffer:w,abort:a,aborted:!1};return b}function i(){return new r}function a(){(s.api||s.feature)&&(d.aborted=!0,s=d.backlog={})}var u="nr@context",f=e("gos"),c=e(3),s={},p={},d=n.exports=o();d.backlog=s},{}],gos:[function(e,n,t){function r(e,n,t){if(o.call(e,n))return e[n];var r=t();if(Object.defineProperty&&Object.keys)try{return Object.defineProperty(e,n,{value:r,writable:!0,enumerable:!1}),r}catch(i){}return e[n]=r,r}var o=Object.prototype.hasOwnProperty;n.exports=r},{}],handle:[function(e,n,t){function r(e,n,t,r){o.buffer([e],r),o.emit(e,n,t)}var o=e("ee").get("handle");n.exports=r,r.ee=o},{}],id:[function(e,n,t){function r(e){var n=typeof e;return!e||"object"!==n&&"function"!==n?-1:e===window?0:a(e,i,function(){return o++})}var o=1,i="nr@id",a=e("gos");n.exports=r},{}],loader:[function(e,n,t){function r(){if(!E++){var e=x.info=NREUM.info,n=l.getElementsByTagName("script")[0];if(setTimeout(s.abort,3e4),!(e&&e.licenseKey&&e.applicationID&&n))return s.abort();c(y,function(n,t){e[n]||(e[n]=t)}),f("mark",["onload",a()+x.offset],null,"api");var t=l.createElement("script");t.src="https://"+e.agent,n.parentNode.insertBefore(t,n)}}function o(){"complete"===l.readyState&&i()}function i(){f("mark",["domContent",a()+x.offset],null,"api")}function a(){return O.exists&&performance.now?Math.round(performance.now()):(u=Math.max((new Date).getTime(),u))-x.offset}var u=(new Date).getTime(),f=e("handle"),c=e(3),s=e("ee"),p=e(2),d=window,l=d.document,m="addEventListener",v="attachEvent",g=d.XMLHttpRequest,w=g&&g.prototype;NREUM.o={ST:setTimeout,SI:d.setImmediate,CT:clearTimeout,XHR:g,REQ:d.Request,EV:d.Event,PR:d.Promise,MO:d.MutationObserver};var h=""+location,y={beacon:"bam.nr-data.net",errorBeacon:"bam.nr-data.net",agent:"js-agent.newrelic.com/nr-1130.min.js"},b=g&&w&&w[m]&&!/CriOS/.test(navigator.userAgent),x=n.exports={offset:u,now:a,origin:h,features:{},xhrWrappable:b,userAgent:p};e(1),l[m]?(l[m]("DOMContentLoaded",i,!1),d[m]("load",r,!1)):(l[v]("onreadystatechange",o),d[v]("onload",r)),f("mark",["firstbyte",u],null,"api");var E=0,O=e(5)},{}]},{},["loader"]);</script>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">

<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-color/2.1.2/jquery.color.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/semantic-ui@2.3.1/dist/semantic.min.css">
<script src="https://cdn.jsdelivr.net/npm/semantic-ui@2.3.1/dist/semantic.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js"></script>

<link rel="stylesheet" media="all" type="text/css" href="https://www.proguides.com/public/css/style.css?v=2.3.1o">
<link rel="stylesheet" media="all" type="text/css" href="https://www.proguides.com/public/css/carousel.css">
<link rel="icon" type="image/x-icon" href="https://www.proguides.com/favicon.png">
<link href="//fonts.googleapis.com/css?family=Open+Sans:400,300,600,700,800" rel="stylesheet" type="text/css">
<script type="text/javascript" src="https://www.proguides.com/public/js/modernizr.js"></script>
<script type="text/javascript" src="https://www.proguides.com/public/js/detectizr.js"></script>
<script type="text/javascript" src="https://www.proguides.com/public/js/carousel.js"></script>
<script type="text/javascript" src="https://www.proguides.com/public/js/announcements.js"></script>
<script type="text/javascript" src="https://www.proguides.com/public/js/RetentionScience.js"></script>
<script type="text/javascript" src="https://www.proguides.com/public/js/common.js"></script>
<script type="text/javascript" src="https://www.proguides.com/public/js/fancypauper.js"></script>
<script type="text/javascript" src="https://www.proguides.com/public/js/pgpoints/spend-points.js"></script>
<script type="text/javascript" src="https://www.proguides.com/public/js/module/user_notifications.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bodymovin/4.13.0/bodymovin.min.js" integrity="sha256-q0n+9D8QsUkzE5U/IH/sSEE3dpXs6tz44QyFkQjkd+w=" crossorigin="anonymous"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-63817350-1', 'auto');
  ga('send', 'pageview');
</script>

<script async="" src="https://www.googletagmanager.com/gtag/js?id=AW-838421344"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'AW-838421344');
</script>

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
(adsbygoogle = window.adsbygoogle || []).push({
google_ad_client: "ca-pub-2118398706367621",
enable_page_level_ads: false
});
</script>



<script>
    var SITE_URL = 'https://www.proguides.com/';
</script>

<script>
  !function(f,b,e,v,n,t,s)
  {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
  n.callMethod.apply(n,arguments):n.queue.push(arguments)};
  if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
  n.queue=[];t=b.createElement(e);t.async=!0;
  t.src=v;s=b.getElementsByTagName(e)[0];
  s.parentNode.insertBefore(t,s)}(window, document,'script',
  'https://connect.facebook.net/en_US/fbevents.js');
</script>
<script>
    var FBPixels = {};
            FBPixels['leagueoflegends'] = '1785431391763861';
        fbq('init', '1785431391763861');
            FBPixels['fortnite'] = '287110702120305';
        fbq('init', '287110702120305');
            FBPixels['hearthstone'] = '130859994260736';
        fbq('init', '130859994260736');
            FBPixels['super-smash-bros-ultimate'] = '2579566232056219';
        fbq('init', '2579566232056219');
            FBPixels['csgo'] = '373627316660173';
        fbq('init', '373627316660173');
            FBPixels['overwatch'] = '2358960351043919';
        fbq('init', '2358960351043919');
    </script>


<script>
    (function(win, doc, sdk_url){
        if(win.snaptr) return;
        var tr=win.snaptr=function(){
            tr.handleRequest? tr.handleRequest.apply(tr, arguments):tr.queue.push(arguments);
        };
        tr.queue = [];
        var s='script';
        var new_script_section=doc.createElement(s);
        new_script_section.async=!0;
        new_script_section.src=sdk_url;
        var insert_pos=doc.getElementsByTagName(s)[0];
        insert_pos.parentNode.insertBefore(new_script_section, insert_pos);
    })(window, document, 'https://sc-static.net/scevent.min.js');

    snaptr('init','72f51ef0-b8a0-4ab0-b143-f9b4e29dffd4',{
        });
</script>


<script>
!function(e,t,n,s,u,a){e.twq||(s=e.twq=function(){s.exe?s.exe.apply(s,arguments):s.queue.push(arguments);
},s.version='1.1',s.queue=[],u=t.createElement(n),u.async=!0,u.src='//static.ads-twitter.com/uwt.js',
a=t.getElementsByTagName(n)[0],a.parentNode.insertBefore(u,a))}(window,document,'script');
// Insert Twitter Pixel ID and Standard Event data below
twq('init','o0dhz');
twq('track','PageView');
</script>


<script>
    var retSciArr = [];
    var userId = '';
    var userEmail = "";
    fireRetSciPixel(userId, userEmail, retSciArr);
</script>


<script type="text/javascript">
  (function(e,t){var n=e.amplitude||{_q:[],_iq:{}};var r=t.createElement("script")
  ;r.type="text/javascript";r.async=true
  ;r.src="https://cdn.amplitude.com/libs/amplitude-4.4.0-min.gz.js"
  ;r.onload=function(){if(e.amplitude.runQueuedFunctions){
  e.amplitude.runQueuedFunctions()}else{
  console.log("[Amplitude] Error: could not load SDK")}}
  ;var i=t.getElementsByTagName("script")[0];i.parentNode.insertBefore(r,i)
  ;function s(e,t){e.prototype[t]=function(){
  this._q.push([t].concat(Array.prototype.slice.call(arguments,0)));return this}}
  var o=function(){this._q=[];return this}
  ;var a=["add","append","clearAll","prepend","set","setOnce","unset"]
  ;for(var u=0;u<a.length;u++){s(o,a[u])}n.Identify=o;var c=function(){this._q=[]
  ;return this}
  ;var l=["setProductId","setQuantity","setPrice","setRevenueType","setEventProperties"]
  ;for(var p=0;p<l.length;p++){s(c,l[p])}n.Revenue=c
  ;var d=["init","logEvent","logRevenue","setUserId","setUserProperties","setOptOut","setVersionName","setDomain","setDeviceId","setGlobalUserProperties","identify","clearUserProperties","setGroup","logRevenueV2","regenerateDeviceId","logEventWithTimestamp","logEventWithGroups","setSessionId","resetSessionId"]
  ;function v(e){function t(t){e[t]=function(){
  e._q.push([t].concat(Array.prototype.slice.call(arguments,0)))}}
  for(var n=0;n<d.length;n++){t(d[n])}}v(n);n.getInstance=function(e){
  e=(!e||e.length===0?"$default_instance":e).toLowerCase()
  ;if(!n._iq.hasOwnProperty(e)){n._iq[e]={_q:[]};v(n._iq[e])}return n._iq[e]}
  ;e.amplitude=n})(window,document);

  amplitude.getInstance().init("06e70798662c2ec89bf20bd68881103a")
  var identify = new amplitude.Identify().setOnce('First Seen Date', moment().format('YYYY-MM-DDTHH:mm:ss'))
    amplitude.getInstance().identify(identify)
</script>

<script type="text/javascript">
//Base snippet that loads asynchronously
(function(l,e,a,p) {
    window.UserLeap = function(){U._queue.push(arguments)}
    let U = window.UserLeap;U.appId = a;U._queue = [];
    a=l.createElement('script');
    a.async=1;a.src=e+'?id='+U.appId;
    p=l.getElementsByTagName('script')[0];
    p.parentNode.insertBefore(a, p);
})(document, 'https://cdn.userleap.com/shim.js', 'pY1uiEs0qA');

</script>
<script>
    window.localStorage.setItem('client_credentials', '')
    window.localStorage.setItem('refresh_token', '')
</script>
<link rel="stylesheet" type="text/css" media="print" href="/public/css/print.css">
</head>
<body class="banner-page legal">
<div class="page-container">
<div id="top-navbar" class="top-navbar">
<div class="top-navbar--left">
<div id="hamburger-menu" class="hamburger-menu">
<img src="https://www.proguides.com/public/media/side-nav/menu.svg">
</div>
<a class="item" href="https://www.proguides.com/dashboard">
<img src="https://www.proguides.com/public/media/logos/ProGuides_Logo_white.svg">
</a>
</div>
<div class="item login-button" id="signin--mobile" href="#" data-type="signin">
LOG IN
</div>
</div>
<div id="side-navbar" class="side-navbar">
<nav class="ui menu vertical borderless menu--sidenav">
<div class="menu-container">
<div id="side-nav__scrollable-menu" class="menu--sidenav menu--sidenav--mobile menu--scrollable">
<div class="menu-top-container">
<div class="title-container">
<a class="item" href="https://www.proguides.com/dashboard">
<img class="ui small image" src="https://www.proguides.com/public/media/logos/text_logo.png">
</a>
<div id="mobile-close-button" class="mobile-close-button">
<img class="ui small image" src="https://www.proguides.com/public/media/side-nav/cancel.svg">
</div>
</div>
</div>
<div class="ui secondary vertical menu wide">
<a class="item item--icon" id="signin" href="#" data-type="signin">
<i><img class="image--icon svg" src="https://www.proguides.com/public/media/side-nav/user-login-button.svg"></i>
<span>LOG IN</span>
</a>
<div class="ui modals">
<div id="login-modal" class="ui navbar-modal modal">
<i class="close icon"></i>
<div class="content signin-form">
<div class="signin-form__title">
Login </div>

<form id="login-form" class="ui form">
<div class="field">
<input type="email" name="email" placeholder="Email address">
</div>
<div class="field">
<input type="password" name="password" placeholder="Password">
</div>
<input type="hidden" name="recaptcha_response" class="recaptchaResponse">
<div class="additional-field field">
<div class="ui checkbox">
<input type="checkbox" name="remember_me" checked="">
<label>Remember Me</label>
</div>
<a id="forgot-password" href="#">Forgot your password?</a>
</div>
<div class="ui error message"></div>
<button type="submit" class="ui inverted blue fluid button">Start Your Journey</button>
</form>
</div>
<div class="signin-form__footer">
Don't have an Account? <a id="login-modal-signup" href="#">Sign Up</a>
</div>
</div>
<div id="register-modal" class="ui navbar-modal modal">
<i class="close icon"></i>
<div class="content signin-form">
<div class="signin-form__title">
Register </div>

<form id="registration-form" class="ui form">
<div class="field">
<input type="text" name="username" placeholder="Username">
</div>
<div class="field">
<input type="email" name="email" placeholder="Email address">
</div>
<div class="field">
<input type="password" name="password" placeholder="Password">
</div>
<div class="additional-field field">
<div class="ui checkbox">
<input type="checkbox" name="tos_pp_consent" placeholder="Terms Check">
<label>I agree to the <a href="/terms_and_conditions" target="_blank">Terms and Conditions</a> and <a href="/privacy_policy" target="_blank">Privacy Policy</a></label>
</div>
</div>
<input type="hidden" name="recaptcha_response" class="recaptchaResponse">
<div class="ui error message"></div>
<button type="submit" class="ui inverted blue fluid button" disabled="">Sign Up</button>
</form>
<div class="signin-form__footer-text">
</div>
</div>
<div class="signin-form__footer">
Already Registered? <a id="register-modal-login" href="#">Log In</a>
</div>
</div>
<div id="forgot-password-modal" class="ui navbar-modal modal">
<i class="close icon"></i>
<div class="content signin-form">
<div class="signin-form__title">
Forgot Password </div>
<form id="forgot-password-form" class="ui form">
<div class="field">
<input type="email" name="email" placeholder="Email address">
</div>
<div class="ui error message"></div>
<input type="hidden" name="recaptcha_response" class="recaptchaResponse">
<button type="submit" class="ui inverted blue fluid button">Submit</button>
</form>
</div>
</div>
<script>
    $(function() {
        $('#login-modal-signup').on('click', function() {
            $('#register-modal').modal('show');
        });

        $('#register-modal-login').on('click', function() {
            $('#login-modal').modal('show');
        });

        $('#forgot-password').on('click', function(e) {
            e.preventDefault();

            // Reset form
            let $form = $('#forgot-password-modal').find('form');
            $form[0].reset();
            $form.find('input').each(function() {
                $(this).prop('disabled', false).show();
            });
            $form.find('button[type="submit"]').prop('disabled', false).show();
            $form.find('.message').addClass('error');

            $('#forgot-password-modal').modal('show');
        });

        $('#login-form').form({
            fields: {
                email : ['email', 'empty'],
                password : 'empty'
            }
        });

        $('#login-form').on('submit', function(e) {
            e.preventDefault();

            if ($(this).form('is valid')) {
                let $submitButton = $(this).find('button[type="submit"]');
                $submitButton.prop('disabled', true);

                $.ajax({
                    'method': 'POST',
                    'url': '/functions/registration/login.php',
                    'context': this,
                    'data': {
                        'email': $(this).form('get value', 'email'),
                        'password': $(this).form('get value', 'password'),
                        'remember_me': $(this).form('get value', 'remember_me')
                    },
                    'dataType': 'json'
                }).done(response => {
                    if (response.status === 'success') {
                        location.reload();
                    } else {
                        $(this).form('add errors', [response.error]);
                    }
                }).always(() => {
                    $submitButton.prop('disabled', false);
                });
            }
        });

        $('#registration-form').form({
            fields: {
                username : ['empty', 'maxLength[30]'],
                email : ['email', 'empty'],
                password : ['minLength[7]', 'empty'],
                tos_pp_consent: 'checked'
            }
        });

        $('#registration-form input[name="tos_pp_consent"]').on('change', function() {
            $(this).closest('form').find('button[type="submit"]').prop('disabled', !$(this).is(':checked'));
        });

        $('#registration-form').on('submit', function(e) {
            e.preventDefault();

            if ($(this).form('is valid')) {
                let $submitButton = $(this).find('button[type="submit"]');
                $submitButton.prop('disabled', true);

                $.ajax({
                    'method': 'POST',
                    'url': '/functions/registration/register.php',
                    'context': this,
                    'data': {
                        'username': $(this).form('get value', 'username'),
                        'email': $(this).form('get value', 'email'),
                        'password': $(this).form('get value', 'password')
                    },
                    'dataType': 'json'
                }).done(response => {
                    if (response.status === 'success') {
                        if (fbq) {
                            // FB Pixel: Track 'Complete Registration'
                            fbq('track', 'CompleteRegistration');
                        }

                        if (snaptr) {
                            snaptr('track', 'SIGN_UP', {
                                'success': 1
                            });
                        }

                        window.location.href = '/store/subscriptions';
                    } else {
                        $(this).form('add errors', [response.error]);
                    }
                }).always(() => {
                    $submitButton.prop('disabled', false);
                });
            }
        });

        $('#forgot-password-form').form({
            fields: {
                email : ['email', 'empty']
            }
        });

        $('#forgot-password-form').on('submit', function(e) {
            e.preventDefault();

            if ($(this).form('is valid')) {
                let $formFields = $(this).find('input');
                $formFields.each(function() {
                    $(this).prop('disabled', true);
                });
                let $submitButton = $(this).find('button[type="submit"]');
                $submitButton.prop('disabled', true);

                $.ajax({
                    'method': 'POST',
                    'url': '/functions/registration/forgot-password.php',
                    'context': this,
                    'data': {
                        'email': $(this).form('get value', 'email')
                    },
                    'dataType': 'json'
                }).done(response => {
                    if (response.status === 'success') {
                        let successMessage = $('<p>').text(response.message);
                        $(this).find('.message').removeClass('error').addClass('success').append(successMessage).show();
                    } else {
                        $(this).form('add errors', [response.error]);
                        $formFields.each(function() {
                            $(this).prop('disabled', false);
                        });
                        $submitButton.prop('disabled', false);
                    }
                }).fail(() => {
                    $formFields.each(function() {
                        $(this).prop('disabled', false);
                    });
                    $submitButton.prop('disabled', false);
                });
            }
        });

        
        let facebookLogin = (cb) => {
            let response = {
                status: 'connected'
            };
            cb(response);
        };

        let checkConflictingEmail = (accessToken) => {
            return Promise.resolve({
                status: 'failure',
                reason: 'conflicting_email',
                email: 'conflicting_email@proguides.com'
            });
        }

        let sendVerificationCode = (email) => {
            return Promise.resolve({
                status: 'success',
                message: 'A 6-digit verification code has been sent to your email. Please enter it above to link your accounts.'
            });
        }

        $('.navbar-modal .signin-form__social-button[data-type="facebook"]').on('click', function() {
            let $signinForm = $(this).closest('.signin-form');
            let $accountLinkForm = $signinForm.find('.account-link-form');
            let $accountLinkSubmitButton = $accountLinkForm.find('button[type="submit"]');
            let $verificationForm = $signinForm.find('.verification-form');
            let $verificationSubmitButton = $verificationForm.find('button[type="submit"]');

            facebookLogin((response) => {
                switch (response.status) {
                    case 'connected':
                        let accessToken = response.accessToken;
                        checkConflictingEmail(accessToken).then((response) => {
                            if (response.status === 'success') {
                                console.log('User connected and no email conflict was found.');
                            } else {
                                $(this).hide();
                                switch (response.reason) {
                                    case 'conflicting_email':
                                        console.log('Email already in use.');
                                        let email = response.email;
                                        $signinForm.find('.signin-form__divider').hide();
                                        $signinForm.find('form').hide();

                                        $accountLinkSubmitButton.on('click', function(e) {
                                            e.preventDefault();
                                            $(this).addClass('loading').prop('disabled', true);
                                            $accountLinkForm.submit();
                                        });

                                        $accountLinkForm.on('submit', function(e) {
                                            e.preventDefault();
                                            sendVerificationCode(email).then((response) => {
                                                console.log('Verification code sent to email.');
                                                $accountLinkForm.hide();

                                                $verificationForm.form({
                                                    fields: {
                                                        'verification-code[]' : ['empty']
                                                    }
                                                });
                                                $verificationForm.find('.message').text(response.message).removeClass('hidden').addClass('visible');
                                                $verificationForm.show();
                                                $verificationForm.find('input[type="number"]').first().focus();

                                                $verificationSubmitButton.on('click', function(e) {
                                                    e.preventDefault();
                                                    $(this).addClass('loading').prop('disabled', true);
                                                    $verificationForm.submit();
                                                });

                                                $verificationForm.on('submit', function(e) {
                                                    e.preventDefault();
                                                    if ($verificationForm.form('is valid')) {
                                                        // Finish account link here
                                                    }
                                                    $verificationSubmitButton.prop('disabled', false).removeClass('loading');
                                                });
                                            }).catch(() => {
                                                $(this).find('.message').addClass('error').text('An unknown error occurred.').removeClass('hidden').addClass('visible');
                                            }).finally(() => {
                                                $accountLinkSubmitButton.prop('disabled', false).removeClass('loading');
                                            });
                                        });
                                        $accountLinkForm.show();
                                        break;
                                }
                            }
                        }).catch(() => {
                            $accountLinkForm.find('.message').addClass('error').text('An unknown error occurred.').removeClass('hidden').addClass('visible');
                            $accountLinkForm.find('button[type="submit"]').hide();
                            $accountLinkForm.show();
                        });
                        break;
                    case 'not_authorized':
                        break;
                    default:
                }
            });
        });

        $('.navbar-modal .signin-form .verification-code-fields input[type="text"]').on('input', function() {
            let $nextInput = $(this).parent().next('.field').find('input[type="text"]');
            if ($nextInput.length > 0) {
                $nextInput.focus();
            } else {
                $(this).blur();
            }
        });
    });
    </script>
</div>

<div class="game-sub-menu--desktop">
<div class="row">

<div class="" style="padding-left: 1.5rem; margin-top: 1.0rem;">
<div id="game-sub-menu" class="ui secondary vertical menu wide capitalize-menu">
<a class=" item" href="https://www.proguides.com/games">
SELECT GAME</a>
</div>
</div>
</div>
</div>
<div class="game-sub-menu--mobile ui menu secondary vertical wide capitalize-menu">
<a class=" item" href="https://www.proguides.com/games">
SELECT GAME</a>
<a class="ui item point-store-button" href="https://www.proguides.com/store/points">
<img src="/public/media/icons/store-icon.svg">
BUY POINTS </a>
<a class="ui item go-pro-button" href="https://www.proguides.com/store/subscriptions">GO PRO NOW!</a>
</div>
</div>
</div>
</div>
</nav>
<nav id="side-navbar__drawer--notifications" class="side-navbar__drawer">
<div class="side-navbar__drawer__header">
<div class="side-navbar__drawer__header__title">Notifications</div>
<div id="mobile-close-button--notifications" class="mobile-close-button">
<img class="ui small image" src="https://www.proguides.com/public/media/side-nav/cancel.svg">
</div>
</div>
<div class="ui menu wide vertical secondary notifications">
<div class="empty-notification-message">No notifications at this time.</div>
</div>
</nav>
<nav id="side-navbar__drawer--games" class="side-navbar__drawer side-navbar__drawer--games">
<div class="side-navbar__drawer__header">
<div class="side-navbar__drawer__header__title">Select a Game</div>
<a class="more-button item" href="https://www.proguides.com/games">View All</a>
<div id="mobile-close-button--games-list" class="mobile-close-button">
<img class="ui small image" src="https://www.proguides.com/public/media/side-nav/cancel.svg">
</div>
</div>
<nav class="ui secondary vertical menu wide">
<div class="ui secondary vertical menu wide">
<a href="https://www.proguides.com/leagueoflegends/dashboard" class="item item--icon">
<i>
<img class="image--icon" src="/public/media/games/leagueoflegends/game-icon.png">
<span id="notification_number" class="pro-badge ">
<img src="https://www.proguides.com/public/media/side-nav/PRO_label.svg">
</span>
</i>
<span>League of Legends</span>
</a>
<div class="horizontal-divider horizontal-divider--mobile"></div>
<a href="https://www.proguides.com/fortnite/dashboard" class="item item--icon">
<i>
<img class="image--icon" src="/public/media/games/fortnite/game-icon.png">
<span id="notification_number" class="pro-badge ">
<img src="https://www.proguides.com/public/media/side-nav/PRO_label.svg">
</span>
</i>
<span>Fortnite</span>
</a>
<div class="horizontal-divider horizontal-divider--mobile"></div>
<a href="https://www.proguides.com/super-smash-bros-ultimate/dashboard" class="item item--icon">
<i>
<img class="image--icon" src="/public/media/games/super-smash-bros-ultimate/game-icon.png">
<span id="notification_number" class="pro-badge ">
<img src="https://www.proguides.com/public/media/side-nav/PRO_label.svg">
</span>
</i>
<span>Super Smash Bros. Ultimate</span>
</a>
<div class="horizontal-divider horizontal-divider--mobile"></div>
<a href="https://www.proguides.com/csgo/dashboard" class="item item--icon">
<i>
<img class="image--icon" src="/public/media/games/csgo/game-icon.png">
<span id="notification_number" class="pro-badge ">
<img src="https://www.proguides.com/public/media/side-nav/PRO_label.svg">
</span>
</i>
<span>Counter-Strike: Global Offensive</span>
</a>
<div class="horizontal-divider horizontal-divider--mobile"></div>
<a href="https://www.proguides.com/overwatch/dashboard" class="item item--icon">
<i>
<img class="image--icon" src="/public/media/games/overwatch/game-icon.png">
<span id="notification_number" class="pro-badge ">
<img src="https://www.proguides.com/public/media/side-nav/PRO_label.svg">
</span>
</i>
<span>Overwatch</span>
</a>
<div class="horizontal-divider horizontal-divider--mobile"></div>
<a href="https://www.proguides.com/teamfight-tactics/guides/" class="item item--icon">
<i>
<img class="image--icon" src="/public/media/games/teamfight-tactics/TFTlogo1.png">
<span id="notification_number" class="pro-badge ">
<img src="https://www.proguides.com/public/media/side-nav/PRO_label.svg">
</span>
</i>
<span>Teamfight Tactics</span>
</a>
<div class="horizontal-divider horizontal-divider--mobile"></div>
<a href="https://www.proguides.com/hearthstone/dashboard" class="item item--icon">
<i>
<img class="image--icon" src="/public/media/games/hearthstone/game-icon.png">
<span id="notification_number" class="pro-badge ">
<img src="https://www.proguides.com/public/media/side-nav/PRO_label.svg">
</span>
</i>
<span>Hearthstone</span>
</a>
<div class="horizontal-divider horizontal-divider--mobile"></div>
<a href="https://www.proguides.com/wow/guides/" class="item item--icon">
<i>
<img class="image--icon" src="/public/media/games/world-of-warcraft/game-icon.png">
<span id="notification_number" class="pro-badge ">
<img src="https://www.proguides.com/public/media/side-nav/PRO_label.svg">
</span>
</i>
<span>World of Warcraft</span>
</a>
<div class="horizontal-divider horizontal-divider--mobile"></div>
<a href="https://www.proguides.com/magic-the-gathering/dashboard" class="item item--icon">
<i>
<img class="image--icon" src="/public/media/games/magic-the-gathering/game-icon.png">
<span id="notification_number" class="pro-badge ">
<img src="https://www.proguides.com/public/media/side-nav/PRO_label.svg">
</span>
</i>
<span>Magic: The Gathering Arena</span>
</a>
<div class="horizontal-divider horizontal-divider--mobile"></div>
 </div>
</nav>
</nav>
<nav id="side-navbar__drawer--settings" class="side-navbar__drawer side-navbar__drawer--settings">
<div class="side-navbar__drawer__header">
<div class="side-navbar__drawer__header__title">Settings</div>
<div id="mobile-close-button--settings" class="mobile-close-button">
<img class="ui small image" src="https://www.proguides.com/public/media/side-nav/cancel.svg">
</div>
</div>
<nav class="ui secondary vertical menu wide">
<div class="ui secondary vertical menu wide">
<a href="https://www.proguides.com/settings/account" class="item">Account Settings</a>
<a href="https://www.proguides.com/settings/connected_games" class="item">Connected Games</a>
<a href="https://www.proguides.com/settings/subscriptions" class="item">Plans Settings</a>
<a href="https://www.proguides.com/instapro/coach" class="item coach-only">InstaPRO Coach Dashboard</a>
<div class="horizontal-divider"></div>
<a href="https://www.proguides.com/registration/logout" class="item" id="logout-button">Logout</a>
</div>
</nav>
</nav>
<div id="side-navbar__dark-background" class="side-navbar__dark-background"></div>
<div id="side-navbar__mobile-coverup" class="side-navbar__mobile-coverup"></div>
</div>
<script>
$(function() {
    $('.side-navbar .ui.dropdown').dropdown();

    // On language change from the navbar
    $('.languages .language-options a').on('click', function() {
        $.ajax({
            method: "POST",
            url: "https://www.proguides.com/functions/set_language.php",
            data: {
                language : $(this).attr('data-value')
            },
            success: function(response) {
                location.reload();
            }
        });
    });

    $('#signin').on('click', function(e) {
        e.preventDefault();
        // $('#login-modal').modal('show');
        window.location = '/login'
    });
    $('#signin--mobile').on('click', function(e) {
        e.preventDefault();
        // $('#login-modal').modal('show');
        window.location = '/login'
    });

    // Amplitude Events
    if (typeof amplitude !== 'undefined') {
        $('.point-store-button').on('click', (e) => {
            amplitude.getInstance().logEvent('Clicked Navbar Points Store')
        })

        $('.go-pro-button').on('click', (e) => {
            amplitude.getInstance().logEvent('Clicked Navbar Go Pro')
        })
    }

    // clear tokens when user logs out
    const clearTokens = () => {
        window.localStorage.setItem('client_credentials', '')
        window.localStorage.setItem('refresh_token', '')
    }
    let logoutButton = document.getElementById('logout-button')
    logoutButton.addEventListener('keyup', (event) => {
        if (event.keyCode === 13) {
            clearTokens()
        }
    })
    logoutButton.addEventListener('click', () => {
        clearTokens()
    })
    let state = {
        notificationDrawerOpen: false,
        gamesDrawerOpen: false,
        settingsDrawerOpen: false
    }
    const closeAllDrawers = () => {
        state.notificationDrawerOpen = false
        state.gamesDrawerOpen = false
        state.settingsDrawerOpen = false
    }
        let gameListButton = document.getElementById('game-list-button')
    if (gameListButton) {
        gameListButton.addEventListener('click', () => {
            let open = !state.gamesDrawerOpen
            closeAllDrawers()
            state.gamesDrawerOpen = open
            checkState()
        })
    }
    try {
        document.getElementById('settings-button').addEventListener('click', () => {
            let open = !state.settingsDrawerOpen
            closeAllDrawers()
            state.settingsDrawerOpen = open
            checkState()
        })
        document.getElementById('mobile-close-button--settings').addEventListener('click', () => {
            closeAllDrawers()
            checkState()
        })
    } catch {
    }
    document.getElementById('side-navbar__dark-background').addEventListener('click', () => {
        closeAllDrawers()
        checkState()
    })
    document.getElementById('mobile-close-button--games-list').addEventListener('click', () => {
        closeAllDrawers()
        checkState()
    })
    const checkState = () => {
        try {
            if (state.notificationDrawerOpen) {
                document.getElementById('user-notifications').classList.add('active')
                document.getElementById('side-navbar__drawer--notifications').classList.add('side-navbar__drawer--open')
            } else {
                document.getElementById('user-notifications').classList.remove('active')
                document.getElementById('side-navbar__drawer--notifications').classList.remove('side-navbar__drawer--open')
            }
        } catch {
        }
        try {
            if (state.gamesDrawerOpen) {
                document.getElementById('game-list-button').classList.add('active')
                document.getElementById('side-navbar__drawer--games').classList.add('side-navbar__drawer--open')
            } else {
                document.getElementById('game-list-button').classList.remove('active')
                document.getElementById('side-navbar__drawer--games').classList.remove('side-navbar__drawer--open')
            }
        } catch {
        }
        try {
            if (state.settingsDrawerOpen) {
                document.getElementById('settings-button').classList.add('active')
                document.getElementById('side-navbar__drawer--settings').classList.add('side-navbar__drawer--open')
            } else {
                document.getElementById('settings-button').classList.remove('active')
                document.getElementById('side-navbar__drawer--settings').classList.remove('side-navbar__drawer--open')
            }
        } catch {
        }
        let drawerOpen = state.notificationDrawerOpen || state.gamesDrawerOpen || state.settingsDrawerOpen
        if (drawerOpen) {
            document.getElementById('side-navbar__dark-background').classList.add('side-navbar__dark-background--active')
        } else {
            document.getElementById('side-navbar__dark-background').classList.remove('side-navbar__dark-background--active')
        }
    }
    // If a button in the game's sub-menu is active, the game button will be 'semi-active'
    let gameSubMenu = document.getElementById('game-sub-menu')
    let gameButton = document.getElementById('game-list-button')
    if (gameSubMenu && gameButton) {
        for (var i = 0; i < gameSubMenu.children.length; i++) {
            if (gameSubMenu.children[i].classList.contains('active')) {
                gameButton.classList.add('semi-active')
            }
        }
    }
    // mobile view hamburger menu
    let hamburgerMenuButton = document.getElementById('hamburger-menu')
    // var scrollPos = 0 // save scroll position when nav drawer is opened is it can be returned to when its closed
    hamburgerMenuButton.addEventListener('click', () => {
        document.getElementById('side-navbar').classList.add('side-navbar--open')
        $('body').addClass('side-navbar__modal-open')
        document.getElementById('side-navbar__mobile-coverup').classList.add('side-navbar__mobile-coverup--active')
        // // record scroll position when drawer is opened
        // scrollPos = window.scrollY
        // // disable overflow after nav-drawer slides down (.5s transition time)
        // // disabling overflow automatically scrolls page to the top, so we need to save scroll Pos
        // // to return to spot the user was at
        // setTimeout(() => {
        //     $('.page-container').addClass('side-navbar__modal-open')
        // }, 501)
    })
    document.getElementById('mobile-close-button').addEventListener('click', () => {
        document.getElementById('side-navbar').classList.remove('side-navbar--open')
        $('body').removeClass('side-navbar__modal-open')
        document.getElementById('side-navbar__mobile-coverup').classList.remove('side-navbar__mobile-coverup--active')
        // $('.page-container').removeClass('side-navbar__modal-open')
        // Scroll back to position screen was at when drawer was opened
        // window.scrollTo(0, scrollPos)
    })
    // check on page load if box shadow should exist
    let menu = $('#side-nav__scrollable-menu')
    if (menu.get(0).scrollHeight > menu.outerHeight()) {
        let bottomMenu = $('#side-nav__bottom-menu')
        bottomMenu.addClass('bottom-menu--shadow')
    }
    // register resize listener to check if box shadow should exist
    $(window).resize(() => {
        let isScrollable = $('#side-nav__scrollable-menu').get(0).scrollHeight > menu.outerHeight()
        $('#side-nav__bottom-menu').toggleClass('bottom-menu--shadow', isScrollable)
    })

    // Side nav Coaching count event listener
    $(document).on('onlineCoachCountEvent', function(e) {
        let onlineCoachCount = e.detail.onlineCoachCount || 0
        $('.coaching-coach-count').text(onlineCoachCount).show()
    })

    // Coaching Tab Open Handles
    $('body').on('click', '.coaching-tab-open-handle', function(e) {
        e.preventDefault()

        $('.side-navbar').removeClass('side-navbar--open')
        $('.side-navbar__mobile-coverup').removeClass('side-navbar__mobile-coverup--active')

        if (typeof instaCoachWidget !== 'undefined') {
            instaCoachWidget.openInstacoachDrawer()
        }
    })

    let coachDrawerHighlightRemoveTimeout = null
    $('body').on('mousedown', '.coaching-tab-open-handle', function(e) {
        e.preventDefault()

        if (typeof instaCoachWidget !== 'undefined') {
            if (coachDrawerHighlightRemoveTimeout) {
                clearTimeout(coachDrawerHighlightRemoveTimeout)
            }
            instaCoachWidget.highlightInstacoachDrawer(true)
        }
    })

    $('body').on('mouseup', function() {
        if (coachDrawerHighlightRemoveTimeout) {
            clearTimeout(coachDrawerHighlightRemoveTimeout)
        }
        coachDrawerHighlightRemoveTimeout = setTimeout(() => {
            instaCoachWidget.highlightInstacoachDrawer(false)
        }, 200)
    })

    // Check display of Coaching entry in Side Nav
    let shouldShowCoachingLink = true
    shouldShowCoachingLink *= window.location.pathname !== '/store/subscriptions'
    shouldShowCoachingLink *= window.location.pathname !== '/store/points'
    shouldShowCoachingLink *= window.location.pathname !== '/settings/subscriptions'
    shouldShowCoachingLink *= window.location.pathname !== '/'
    let path = window.location.pathname.split('/')
    shouldShowCoachingLink *= !(path.length >= 5 && path[1] === 'courses')
    if (shouldShowCoachingLink) {
        $('.side-navbar .menu .item.coaching-tab-open-handle').show()
    }

    // Handle Instapro Messaging on the php end of the app
    InstaProMessaging.init()
});
</script>
<div class="main">
<div class="content">
<div class="banner with-text" data-game="leagueoflegends">
<div class="ui container">
</div>
</div>
<div class="ui container">
<div class="ui stackable grid">
<div class="sixteen wide column">
<div class="legal-text pg-container">
<div class="pg-container__header">
<div>
<h1 class="header">Privacy Policy</h1>
<div class="description">Last Updated: April 10, 2019</div>
</div>
</div>
<div class="pg-container__body">
<p>This Privacy Policy explains our practices regarding the collection, use and disclosure of information that we receive through our Services. This Privacy Policy does not apply to any third-party websites, services or applications, even if they are accessible through our Services. Also, please note that, unless we define a term in this Privacy Policy, all capitalized terms used in this Privacy Policy have the same meanings as in our Terms of Service. So, please make sure that you have read and understand our Terms of Service.</p>
<ul>
<li>
<h2>Revisions to this Privacy Policy</h2>
<p>Any information that is collected via our Services is covered by the Privacy Policy in effect at the time such information is collected. We may revise this Privacy Policy from time to time. If we make any material changes to this Privacy Policy, we’ll notify you of those changes by posting them on the Services or by sending you an email or other notification, and we’ll update the “Last Updated Date” above to indicate when those changes will become effective.</p>
</li>
<li>
<h2>Information Collected or Received from You</h2>
<p>Our primary goals in collecting information are to provide and improve our Services, to administer your use of the Services (including your Account, if you are an Account holder), and to enable you to enjoy and easily navigate our Services.</p>
<ul>
<li>
<p class="underline">Account Information</p>
<p>If you create an Account, we’ll collect certain information that can be used to identify you, such as your email address (“<b>PII</b>”).</p>
</li>
<li>
<p class="underline">Information Collected Using Cookies and other Web Technologies</p>
<p>Like many website owners and operators, we use automated data collection tools such as Cookies and Web Beacons to collect certain information.</p>
</li>
</ul>
<br>
<p>“<b>Cookies</b>” are small text files that are placed on your device by a web server when you access our Services. We may use both session Cookies and persistent Cookies to identify that you’ve logged in to the Services and to tell us how and when you interact with our Services. We may also use Cookies to monitor aggregate usage and web traffic routing on our Services and to customize and improve our Services. Unlike persistent Cookies, session Cookies are deleted when you log off from the Services and close your browser. Although most browsers automatically accept Cookies, you can change your browser options to stop automatically accepting Cookies or to prompt you before accepting Cookies. Please note, however, that if you don’t accept Cookies, you may not be able to access all portions or features of the Services. Some third-party services providers that we engage (including third-party advertisers) may also place their own Cookies on your device. Note that this Privacy Policy covers only our use of Cookies and does not include use of Cookies by such third parties.</p>
<p>“<b>Web Beacons</b>” (also known as web bugs, pixel tags or clear GIFs) are tiny graphics with a unique identifier that may be included on our Services for several purposes, including to deliver or communicate with Cookies, to track and measure the performance of our Services, to monitor how many visitors view our Services, and to monitor the effectiveness of our advertising. Unlike Cookies, which are stored on the device, Web Beacons are typically embedded invisibly on web pages (or in an e-mail).</p>
<p>“Log Data” means certain information about how a person uses our Services, including both Account holders and non-Account holders (either, a “User”). Log Data may include information such as a User’s Internet Protocol (IP) address, browser type, operating system, the web page that a User was visiting before accessing our Services, the pages or features of our Services to which a User browsed and the time spent on those pages or features, search terms, the links on our Services that a User clicked on and other statistics. We use Log Data to administer the Services and we analyze (and may engage third parties to analyze) Log Data to improve, customize and enhance our Services by expanding their features and functionality and tailoring them to our Users’ needs and preferences. We may use a person’s IP address to generate aggregate, non-identifying information about how our Services are used.</p>
<ul>
<li>
<p class="underline">Information Sent by Your Mobile Device</p>
<p>When you use our App, we may collect and store information about your location by converting your IP address into a rough geo-location or by accessing your mobile device’s GPS coordinates or coarse location if you enable location services on your device. We may use location information to improve and personalize our Services for you. If you do not want us to collect location information, you may disable that feature on your mobile device.</p>
</li>
<li>
<p class="underline">Location Information</p>
<p>Like many website owners and operators, we use automated data collection tools such as Cookies and Web Beacons to collect certain information.</p>
</li>
</ul>
</li>
<li>
<h2>Information that We Share with Third Parties</h2>
<p>We will not share any PII that we have collected from or regarding you except as described below:</p>
<ul>
<li>
<p class="underline">Information Shared with Our Services Providers</p>
<p>We may engage third-party services providers to work with us to administer and provide the Services. These third-party services providers have access to your PII only for the purpose of performing services on our behalf [and are expressly obligated not to disclose or use your PII for any other purpose.] We may share your PII and any necessary payment information, such as credit card number, expiration date and billing address, with our payment processing services providers in order to complete transactions that are initiated through the Services. We may also share your PII with our marketing service providers to help us better market our products and services to you. These marketing service providers may use your PII only for the purpose of helping us to provide relevant products and services information to you and are expressly obligated not to disclose your PII to others. If you don’t want us to use your PII for these marketing purposes, you can opt out by contacting us at <a href="mailto:support@proguides.com">support@proguides.com</a>.</p>
</li>
<li>
<p class="underline">Information Shared with other Third Parties</p>
<p>We may share anonymized or aggregated data we collect from the use of the Services, such as de-identified demographic information, de-identified location information, information about the computer or device from which you access the Services, market trends and other analysis that we create based on the information we receive from you and other users.</p>
</li>
<li>
<p class="underline">Information Shared with Web Analytics Services Providers</p>
<p><b>Google.</b>We use Google Analytics, a service provided by Google, Inc. (“<b>Google</b>”), to gather information about how users engage with our Site and Services. For more information about Google Analytics, please visit <a href="https://www.google.com/policies/privacy/partners/" target="_blank">www.google.com/policies/privacy/partners/</a>. You can opt out of Google’s collection and processing of data generated by your use of the Services by going to <a href="https://tools.google.com/dlpage/gaoptout" target="_blank">http://tools.google.com/dlpage/gaoptout</a>.</p>
<p><b>Facebook.</b>We may use certain tools offered by Facebook, Inc. (“<b>Facebook</b>”) that enable it to collect or receive information about actions users take on: (a) our Site and elsewhere on the internet through use of Cookies, Web Beacons and other storage technologies; or (b) our App and other mobile applications, in order to provide measurement services, targeted ads and other services. For more information regarding the collection and use of such information by Facebook, please see the Facebook Data Policy, available at: <a href="https://www.facebook.com/policy.php" target="_href">https://www.facebook.com/policy.php</a>.</p>
</li>
<li>
<p class="underline">Information Disclosed in Connection with Business Transactions</p>
<p>Information that we collect from our users, including PII, is considered to be a business asset. Thus, if we are acquired by a third party as a result of a transaction such as a merger, acquisition or asset sale or if our assets are acquired by a third party in the event we go out of business or enter bankruptcy, some or all of our assets, including your PII, may be disclosed or transferred to a third party acquirer in connection with the transaction.</p>
</li>
 <li>
<p class="underline">Information Disclosed for Our Protection and the Protection of Others</p>
<p>We cooperate with government and law enforcement officials or private parties to enforce and comply with the law. We may disclose any information about you to government or law enforcement officials or private parties as we, in our sole discretion, believe necessary or appropriate: (i) to respond to claims, legal process (including subpoenas); (ii) to protect our property, rights and safety and the property, rights and safety of a third party or the public in general; and (iii) to stop any activity that we consider illegal, unethical or legally actionable activity.</p>
</li>
</ul>
</li>
<li>
<h2>Your Choices</h2>
<p>We offer you choices regarding the collection, use and sharing of your PII and we’ll respect the choices you make. Please note that if you decide not to provide us with the PII that we request, you may not be able to access all of the features of the Services.</p>
<ul>
<li>
<p class="underline">Opt-Out of our Mailings</p>
<p>We may periodically send you free newsletters and e-mails that directly promote our Services. When you receive such promotional communications from us, you will have the opportunity to “opt-out” (either through your Account or by following the unsubscribe instructions provided in the e-mail you receive). We do need to send you certain communications regarding the Services and you will not be able to opt out of those communications – e.g., communications regarding updates to our Terms of Service or this Privacy Policy or information about billing.</p>
</li>
<li>
<p class="underline">Opt-out of Ad Tracking</p>
<p>You can opt out of the collection and use of your information for ad targeting by going to <a href="http://www.aboutads.info/choices" target="_blank">http://www.aboutads.info/choices</a> or <a href="http://www.youronlinechoices.eu/" target="_blank">http://www.youronlinechoices.eu/</a> to limit collection through the Site or by configuring the settings on your mobile device to limit ad tracking through the App.</p>
</li>
<li>
<p class="underline">Modifying Your Information</p>
<p>You can access and modify the PII associated with your Account by visiting your <a href="/settings/account">Account Settings</a>. If you want us to delete your PII and your Account, please contact us at <a href="mailto:support@proguides.com">support@proguides.com</a> with your request. We’ll take steps to delete your information as soon we can, but some information may remain in archived/backup copies for our records or as otherwise required by law.</p>
</li>
</ul>
</li>
<li>
<h2>Responding to Do Not Track Signals</h2>
<p>Our Site does not have the capability to respond to “Do Not Track” signals received from various web browsers.</p>
</li>
<li>
<h2>The Security of Your Information</h2>
<p>We take reasonable administrative, physical and electronic measures designed to protect the information that we collect from or about you (including your PII) from unauthorized access, use or disclosure. When you enter sensitive information on our forms, we encrypt this data using SSL or other technologies. Please be aware, however, that no method of transmitting information over the Internet or storing information is completely secure. Accordingly, we cannot guarantee the absolute security of any information.</p>
</li>
<li>
<h2>Links to Other Sites </h2>
<p class="uppercase">Our Services may contain links to websites and services that are owned or operated by third parties (each, a “<b>Third-party Service</b>”). Any information that you provide on or to a Third-party Service or that is collected by a Third-party Service is provided directly to the owner or operator of the Third-party Service and is subject to the owner’s or operator’s privacy policy. We’re not responsible for the content, privacy or security practices and policies of any Third-party Service. To protect your information we recommend that you carefully review the privacy policies of all Third-party Services that you access.</p>
</li>
<li>
<h2>International Transfer</h2>
<p>Your PII may be transferred to, and maintained on, computers located outside of your state, province, country or other governmental jurisdiction where the privacy laws may not be as protective as those in your jurisdiction. If you’re located outside the United States and choose to provide your PII to us, we may transfer your PII to the United States and process it there.</p>
</li>
<li>
<h2>Our Policy Toward Children</h2>
<p>We do not direct our Services to children (usually considered to be under the age of 13, depending on the country where you reside). We also do not intentionally collect PII from children through our Services. If you are the parent or guardian of a child and you believe that we have inadvertently received PII about that child, please contact us as described below and we will delete the information from our records.</p>
</li>
<li>
<h2>Your California Privacy Rights</h2>
<p>California residents may request and obtain from us, once a year, free of charge, a list of third parties, if any, to which we disclosed their PII for direct marketing purposes during the preceding calendar year and the categories of PII shared with those third parties. If you are a California resident and wish to obtain that information, please submit your request by sending us an email at <a href="mailto:support@proguides.com">support@proguides.com</a> with “California Privacy Rights” in the subject line or by writing to us at 11862 La Grange Ave., Los Angeles, California 90025.</p>
</li>
<li>
<h2>Questions? </h2>
<p>Please contact us at <a href="mailto:support@proguides.com">support@proguides.com</a> if you have any questions about our Privacy Policy.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<footer>
<div id="signup-bannner" class="signup-banner">
<div class="banner__inner ui container">
<div class="banner__left">
<span class="banner__label">Create a ProGuides account and start ranking up today.</span>
</div>
<div class="banner__right">
<div class="banner__button banner__button--free" id="signup-banner-free"><span>JOIN FOR FREE</span></div>
<div class="banner__button banner__button--pro" id="signup-banner-pro"><span>GO PRO NOW</span></div>
</div>
</div>
</div>
<div class="footer">
<div class="footer__sections">
<div class="footer__logo">
<img src="/public/media/home/ProGuides_Logo.svg">
</div>
<div class="footer__copyright-social">
<div class="socials">
<a href="https://twitter.com/proguidescom" target="_blank" class="footer__social footer__social--twitter"></a>
<a href="https://www.facebook.com/proguidescom" target="_blank" class="footer__social footer__social--facebook"></a>
<a href="https://www.youtube.com/channel/UCq8up0Ew9K0IiRxbz75BZsg" target="_blank" class="footer__social footer__social--youtube"></a>
<a href="https://www.instagram.com/proguidescom" target="_blank" class="footer__social footer__social--instagram"></a>
</div>
<div class="copyright">
<img src="/public/media/home/ProGuides text.png">
<p>| Copyright © 2019 ProGuides. All rights reserved.</p>
</div>
</div>
<div class="footer__section footer__section--company">
<p class="footer__section-header">COMPANY</p>
<span id="footer-contact-us" class="footer__section-link">Customer Support</span>
<a href="https://www.proguides.com/instapro" class="footer__section-link">Become a coach™</a>
<span id="footer-partners-contact" class="footer__section-link">Become a Partner</span>
<a href="https://www.proguides.com/careers" class="footer__section-link">Careers</a>
<a href="https://www.proguides.com/terms_and_conditions" class="footer__section-link">Terms and Conditions</a>
<a href="https://www.proguides.com/privacy_policy" class="footer__section-link">Privacy Policy</a>
</div>
<div class="footer__section footer__section--games">
<p class="footer__section-header">GAMES</p>
<div class="game-link">
<img src="/public/media/games/leagueoflegends/game-icon.png">
<a href="https://www.proguides.com/courses/leagueoflegends" class="footer__section-link">League of Legends</a>
</div>
<div class="game-link">
<img src="/public/media/games/teamfight-tactics/TFTlogo1.png">
<a href="https://www.proguides.com/teamfight-tactics/guides" class="footer__section-link">Teamfight Tactics</a>
</div>
<div class="game-link">
<img src="/public/media/games/fortnite/game-icon.png">
<a href="https://www.proguides.com/courses/fortnite" class="footer__section-link">Fortnite</a>
</div>
<div class="game-link">
<img src="/public/media/games/overwatch/game-icon.png">
<a href="https://www.proguides.com/courses/overwatch" class="footer__section-link">Overwatch</a>
</div>
<div class="game-link">
<img src="/public/media/games/super-smash-bros-ultimate/game-icon.png">
<a href="https://www.proguides.com/courses/super-smash-bros-ultimate" class="footer__section-link">Super Smash Bros. Ultimate</a>
</div>
<div class="game-link">
<img src="/public/media/games/hearthstone/game-icon.png">
<a href="https://www.proguides.com/courses/hearthstone" class="footer__section-link">Hearthstone</a>
</div>
<div class="game-link">
<img src="/public/media/games/csgo/game-icon.png">
<a href="https://www.proguides.com/courses/csgo" class="footer__section-link">Counter Strike: Global Offensive</a>
</div>
<div class="game-link">
<img src="/public/media/games/magic-the-gathering/game-icon.png">
<a href="https://www.proguides.com/courses/magic-the-gathering" class="footer__section-link">Magic: The Gathering Arena</a>
</div>
</div>
</div>


<div class="ui modals">
<div class="ui modal footer-form-modal" id="contact-us-modal">
<i class="close icon"></i>
<form id="contact-us-form" class="ui form">
<div class="header">Customer Support</div>
<p>
Have a question or need help? <br>
Send us a message. We often respond within 2 hours. </p>
<hr>
<div class="field">
<select name="subject" style="font-size: 1.4rem; background-color: #f9f9f9; cursor: pointer; -webkit-appearance: menulist;">
<option value="">Select a Support Category</option>
<option value="Bug">Report Bug</option>
<option value="Membership/Payments">Membership/Payments</option>
<option value="Coaching">Coaching</option>
<option value="Other">Other</option>
</select>
</div>
<div class="field">
<input type="text" name="name" placeholder="Name">
</div>
<div class="field">
<input type="email" name="email" placeholder="Email address">
</div>
<div class="field">
<textarea name="message" rows="4" placeholder="Message"></textarea>
</div>
<div class="ui error message"></div>
<button type="submit" class="ui button fluid blue inverted">Submit</button>
</form>
<div id="contact-us-confirm" class="form-confirmation">
<div class="header">Thanks for contacting us!</div>
<p>We've received your message and a support agent will be contacting you within 24 hours. Thanks for choosing ProGuides!</p>
</div>
</div>
<script>
$(function() {
    $('#contact-us-form').form({
        fields: {
            subject : 'empty',
            name : 'empty',
            email : ['email', 'empty'],
            message: 'empty'
        }
    });

    $('#contact-us-form').on('submit', function(e) {
        e.preventDefault();
        if ($(this).form('is valid')) {
            let $submitButton = $(this).find('button[type="submit"]');
            $submitButton.prop('disabled', true).addClass('loading');

            $.ajax({
                method: 'POST',
                url: '/functions/contact-us.php',
                data: {
                    name: $(this).form('get value', 'name'),
                    email: $(this).form('get value', 'email'),
                    subject: $(this).form('get value', 'subject'),
                    message: $(this).form('get value', 'message')
                },
                dataType: 'json',
                context: this
            }).done(response => {
                if (response.status === 'success') {
                    $('#contact-us-form').hide();
                    $('#contact-us-confirm').show();
                } else {
                    $(this).form('add errors', [response.error]);
                }
            }).always(() => {
                $submitButton.prop('disabled', false).removeClass('loading');
            });
        }
        return false;
    });
});
</script>
<div class="ui modal footer-form-modal" id="partner-modal">
<i class="close icon"></i>
<form id="partner-form" class="ui form">
<div class="header">Partners</div>
<p>
Want to become a ProGuides partner? <br>
Have a substantial audience? Send us a message and we'll respond as soon as possible. </p>
<hr>
<input type="hidden" name="subject" value="ProGuides Partners">
<div class="field">
<input type="text" name="name" placeholder="Name">
</div>
<div class="field">
<input type="email" name="email" placeholder="Email address">
</div>
<div class="field">
<textarea name="message" rows="4" placeholder="Message"></textarea>
</div>
<div class="ui error message"></div>
<button type="submit" class="ui button fluid blue inverted">Submit</button>
</form>
<div id="partner-confirm" class="form-confirmation">
<div class="header">Thanks for contacting us!</div>
<p>We've received your message and a partnership manager will be contacting you shortly. Thanks for your interest in ProGuides!</p>
</div>
</div>
<script>
$(function() {
    $('#partner-form').form({
        fields: {
            subject : 'empty',
            name : 'empty',
            email : ['email', 'empty'],
            message: 'empty'
        }
    });

    $('#partner-form').on('submit', function(e) {
        e.preventDefault();
        if ($(this).form('is valid')) {
            let $submitButton = $(this).find('button[type="submit"]');
            $submitButton.prop('disabled', true).addClass('loading');

            $.ajax({
                method: 'POST',
                url: '/functions/contact-us.php',
                data: {
                    name: $(this).form('get value', 'name'),
                    email: $(this).form('get value', 'email'),
                    subject: $(this).form('get value', 'subject'),
                    message: $(this).form('get value', 'message')
                },
                dataType: 'json',
                context: this
            }).done(response => {
                if (response.status === 'success') {
                    $('#partner-form').hide();
                    $('#partner-confirm').show();
                } else {
                    $(this).form('add errors', [response.error]);
                }
            }).always(() => {
                $submitButton.prop('disabled', false).removeClass('loading');
            });
        }
        return false;
    });
});
</script>
</div>


<div v-show="!hideInstapro" class="vue-app__instacoach-widget vue-app__instacoach-widget--hidden" id="instacoach-widget" ref="instacoachWidget">

<div class="instacoach-widget__open-button" @click="openInstacoachDrawer">
<div class="open-button__avatars" v-if="getOnlineCoaches.length > 0">
<div class="coach-avatar" v-for="coach in getOnlineCoaches.slice(0, 3)">
<img :src="coach.avatar">
</div>
</div>
<div class="open-button__title">Play Now</div>
<div class="open-button__coaches-online">
{{ getNumCoachesOnline }}
</div>
</div>

<div class="instacoach-widget__notification-container">
<div class="notification" v-for="(notification, index) in instaproNotifications" :key="'notification-' + index" @click="openNotification(notification, index)">
<div class="notification__close-button" @click.stop="closeNotification(index)"><img src="/public/media/instacoach/icons/notification-close.png"></div>
<div class="notification__header">InstaPRO</div>
<div class="notification__content">
<div class="notification__avatar-container">
<img class="avatar-image" :src="notification.avatar" alt="">
<div class="avatar-status"></div>
</div>
<div class="notification__text-container">
<div class="text-container__game-row">
<img :src="getGameIcon(notification.game)" alt="">
<span>Following</span>
</div>
<div class="text-container__message"><strong>{{getNotificationSubject(notification)}}</strong>&nbsp;{{getNotificationMessage(notification)}}</div>
</div>
</div>
</div>
</div>

<div class="instacoach-widget__messaging-tab-container" ref="messagingContainer" v-show="isMessagingEnabled">

<div :class="{'messaging-tab-container__message-list': true, 'messaging-tab-container__message-list--open': messagesOpen}">
<div class="message-list__header" @click="openCloseMessages">
<img class="header__avatar" :src="getSelfAvatar">
<div class="header__title">Messaging</div>
<div class="header__unread" v-if="totalUnreadMessages > 0">
<div>{{ totalUnreadMessages }}</div>
</div>
<div class="header__spacer"></div>
<div class="header__minimize-button">
<img src="/public/media/instacoach/icons/minimize.svg">
</div>
</div>
<div class="message-list__body">
<div class="body__search-container">
<div class="body__search">
<div class="search__icon">
<img src="/public/media/instacoach/icons/search.svg">
</div>
<input type="text" placeholder="Search Users" v-model="searchMessagesQueryValue">
</div>
</div>
<div class="body__empty" v-if="getConversations.length === 0">
<div class="empty__message" v-if="failedAuthentication" style="padding-top: 3rem;">
<div class="message__title">Couldn't connect to chat</div>
<div class="message__subtitle">Check to make sure you have internet access</div>
<div class="message__link" @click="restartAuthentication">Reconnect</div>
</div>
<div class="body__loading" v-else-if="!doneFetchingConversations">
<div class="loader"></div>
</div>
<div class="empty__message" v-else="">
<img class="message__icon" src="/public/media/instacoach/icons/conversation-icon.svg">
<div class="message__title">Start messaging pros now</div>
<div class="message__subtitle">Ask a question or message a coach before your next coaching session.</div>
</div>
</div>
<div class="body__empty" v-else-if="getFilteredConversations.length === 0">
<div class="empty__message">
<img class="message__icon" src="/public/media/instacoach/icons/search-icon.svg">
<div class="message__title">No search results.</div>
</div>
</div>
<div class="body__list">
<div class="list__item" @click="openChatTab(conversation)" v-for="conversation in getFilteredConversations" :key="'conversation-' + conversation.id">
<div class="item__avatar">
<img :src="conversation.avatar" class="avatar__image">
<img v-if="conversation.coachId" :src="getOnlineStatus(conversation.coachId)" class="avatar__online-status">
</div>
<div class="item__right">
<div :class="{'item__message': true, 'item__message--unread': conversation.unread > 0}">
<div class="message__username">{{conversation.name}}</div>
<div class="message__preview">
{{ getLastMessage(conversation) }}
</div>
</div>
<div class="item__unread-tag" v-if="conversation.unread">
<span>{{ conversation.unread }}</span>
</div>
</div>
</div>
</div>
</div>
</div>

<div :class="{'messaging-tab-container__message-tab': true, 'messaging-tab-container__message-tab--open': !chat.minimized}" v-for="(chat, chatIndex) in getCurrentChats" :key="'current-chat-' + chat.id" :data-chatid="chatIndex" @click="interactWithChat(chat.id)">

<div :class="{'message-tab__header': true, 'message-tab__header--in-session': (chat.actionState === 'in-session' || chat.actionState === 'confirm-end-session')}" @click="minimizeMessageTab(chat)">
<img v-if="chat.coachId &amp;&amp; !(chat.actionState === 'in-session' || chat.actionState === 'confirm-end-session')" :src="getOnlineStatusNoOutline(chat.coachId)" class="header__online-status">
<div class="header__username">{{chat.name}}</div>
<div class="header__unread" v-if="conversations[chat.id] &amp;&amp; conversations[chat.id].unread">
<div>{{ conversations[chat.id].unread }}</div>
</div>
<div class="header__spacer"></div>

<div class="header__close-button" @click.stop="closeChat(chat.id)">
<img v-if="(chat.actionState === 'in-session' || chat.actionState === 'confirm-end-session')" src="/public/media/instacoach/icons/close-white.svg">
<img v-else="" src="/public/media/instacoach/icons/close.svg">
</div>
</div>
<div class="message-tab__body">
<div class="body__loading-messages-container-one" v-if="!conversationMessages[chat.id] || chat.isFetchingMessages">
<div class="body__loading-messages-container-two">
<div class="body__loading-messages-badge">
<span>Loading more messages...</span>
</div>
</div>
</div>

<div class="body__instapro-actions" v-if="!userInSession || (chat.actionState === 'in-session' || chat.actionState === 'confirm-end-session')">


<div @click="chatTabStartSession(chat)" class="instapro-actions__start-session" v-if="chat.actionState === 'default' &amp;&amp; isCoachOnline(chat.coachId)">
<img src="/public/media/instacoach/icons/play.svg">
<div class="start-session__label">START SESSION</div>
</div>

<div :class="{'instapro-actions__game-select': true, 'instapro-actions__game-select--inactive': !doShowChatBookSessionGameSelect(chat)}" @click.stop="openChatBookSessionGameSelectDropdown(chat)" @blur="closeChatBookSessionGameSelectDropdown(chat)" tabindex="-1" :ref="'chat-book-session-game-select-dropdown-' + chat.id" v-show="chat.actionState === 'select-session-type'">
<img v-if="chat.selectedGame" class="game-select__game-icon" :src="getGameThumbnail(chat.selectedGame)">
<img v-if="doShowChatBookSessionGameSelect(chat)" class="game-select__dropdown-icon" src="/public/media/instacoach/icons/sort-up.png">
<div @click.stop="" v-if="chat.gameSelectDropdownOpen" class="game-select__dropdown">
<div class="dropdown__item" v-for="gameKey in getChatCoachGameOptions(chat)" @click="chatBookSessionSelectGameOption(chat, gameKey)">
<img :src="getGameThumbnail(gameKey)">
<p>{{gameKey}}</p>
</div>
</div>
</div>
<div class="instapro-actions__container" v-show="chat.actionState !== 'default'">
<div class="instapro-actions__select-session-type" v-if="chat.actionState === 'select-session-type'">
<div class="select-session-type__header">
<span class="header__title">SESSION OPTIONS:</span>
<div class="header__close-button" @click.stop="closeChatSelectSessionOptions(chat)">
<img src="/public/media/instacoach/icons/close.svg">
</div>
</div>
<div class="session-types">
<div :class="{'session-types__button': true, 'session-types__button--selected': getChatBookSessionSelectedSessionType(chat) === 'in-game'}" @click="chatBookSessionSelectSessionType(chat, 'in-game')" tabindex="0" v-show="isChatBookSessionMethodAvailable(chat, 'in-game')">
<div class="session-types__radio">
<div class="radio__center"></div>
</div>
<div class="session-types__text-container">
<h1>Play 1 Game with Pro</h1>
<p>You receive feedback while playing together.</p>
</div>

<div class="session-types__point-cost">
<h2>{{getChatBookSessionCoachSessionTypeCost(chat, 'in-game')}}</h2>
<img src="/public/media/instacoach/payment/gem.png">
</div>
</div>
<div :class="{'session-types__button': true, 'session-types__button--selected': getChatBookSessionSelectedSessionType(chat) === 'spectate'}" @click="chatBookSessionSelectSessionType(chat, 'spectate')" tabindex="0" v-show="isChatBookSessionMethodAvailable(chat, 'spectate')">
<div class="session-types__radio">
<div class="radio__center"></div>
</div>
<div class="session-types__text-container">
<h1>Play 1 Spectated Game</h1>
<p>You receive feedback while Pro watches you play.</p>
</div>

<div class="session-types__point-cost">
<h2>{{getChatBookSessionCoachSessionTypeCost(chat, 'spectate')}}</h2>
<img src="/public/media/instacoach/payment/gem.png">
</div>
</div>
<div :class="{'session-types__button': true, 'session-types__button--selected': getChatBookSessionSelectedSessionType(chat) === 'replay'}" @click="chatBookSessionSelectSessionType(chat, 'replay')" tabindex="0" v-show="isChatBookSessionMethodAvailable(chat, 'replay')">
<div class="session-types__radio">
<div class="radio__center"></div>
</div>
<div class="session-types__text-container">
<h1>Replay Analysis</h1>
<p>Coach gives feedback on recorded gameplay.</p>
</div>

<div class="session-types__point-cost">
<h2>{{getChatBookSessionCoachSessionTypeCost(chat, 'replay')}}</h2>
 <img src="/public/media/instacoach/payment/gem.png">
</div>
</div>
</div>
<div class="select-session-type__divider"></div>
<div class="select-session-type__actions">
<div class="actions__button actions__button--refill" v-if="chatBookSessionNotEnoughPoints(chat)" @click="chatBookSessionReloadPoints(chat)">
<div class="button__label">REFILL POINTS</div>
<div class="button__price">
<img src="/public/media/instacoach/payment/gem.png">
<div class="price__amount">{{getChatBookSessionCoachSessionTypeCost(chat, chat.selectedCoachingType)}}</div>
</div>
</div>
<div :class="{'actions__button': true, 'actions__button--submit': true, 'actions__button--disabled': isChatBookSessionPlayNowDisabled(chat)}" v-else="" @click="chatBookSessionSubmit(chat)">
<div class="button__label">PLAY NOW</div>
<div class="button__price" v-if="!isChatBookSessionPlayNowDisabled(chat)">
<img src="/public/media/instacoach/payment/gem.png">
<div class="price__amount">{{getChatBookSessionCoachSessionTypeCost(chat, chat.selectedCoachingType)}}</div>
</div>
</div>
</div>
</div>
<div class="instapro-actions__request-waiting" v-else-if="chat.actionState === 'request-waiting'">
<p>waiting</p>
</div>
<div class="instapro-actions__confirm-end-session" v-else-if="chat.actionState === 'confirm-end-session'">
<div class="confirm-end-session__header">
<div class="header__title">END SESSION</div>
</div>
<div class="confirm-end-session__body">
<div class="body__text">Are you sure you want to end this session?</div>
<div class="body__divider"></div>
<div class="body__actions">
<div class="actions__cancel" @click="chatCancelEndSession(chat)">
<span>CANCEL</span>
</div>
<div class="actions__submit" @click="chatEndSession(chat)">
<span>YES</span>
</div>
</div>
</div>
</div>
<div class="instapro-actions__end-session" v-else-if="chat.actionState === 'in-session'">
<div class="end-session__time-remaining">
<div class="time-remaining__label">TIME ELAPSED:</div>
<div class="time-remaining__time">{{getCurrentSessionTimeElapsed}}</div>
</div>
<div class="end-session__end-button" @click="chatConfirmEndSession(chat)">
<span>END NOW</span>
</div>
</div>
</div>
</div>

<div class="body__message-list" :ref="'message-tab-scrolling-' + chat.id">
<div :class="{'message-list__messages-container': true, 'message-list__messages-container--pad-top': padChatMessageTop(chat)}">
 <div v-for="(message, index) in conversationMessages[chat.id]" :ref="'message-tab-' + chat.id + '__message-' + message.id ? message.id : index" :key="'message-tab-' + chat.id + '__message-' + message.id ? message.id : index">

<div class="message-list__divider" v-if="showMessageDivider(message)">
<div :class="{'divider__line': true, 'divider__line--red': message.newMessagesDivider, 'divider__line--blue': isMessageDividerBlue(message)}" v-if="message.divider || message.newMessagesDivider || isMessageDividerBlue(message)"></div>
<div class="divider__text divider__text--blue" v-if="message.type === 'SESSION_START'">
SESSION START
</div>
<div class="divider__text divider__text--blue" v-else-if="message.type === 'SESSION_END'">
SESSION END
</div>
<div class="divider__text divider__text--red" v-else-if="message.newMessagesDivider">
NEW MESSAGES
</div>
<div class="divider__text" v-else-if="message.divider === 'date'">
{{ message.dividerContent }}
</div>
<div :class="{'divider__line': true, 'divider__line--red': message.newMessagesDivider, 'divider__line--blue': isMessageDividerBlue(message)}" v-if="message.divider || message.newMessagesDivider || isMessageDividerBlue(message)"></div>
</div>

<div class="message-list__text-message" v-if="message.type === 'MESSAGE'">
<div class="text-message__avatar">
<img :src="message.avatar" v-if="message.isNewLine">
</div>
<div class="text-message__column">
<div class="text-message__row text-message__username-container" v-if="message.isNewLine">
<div class="text-message__username">
{{ message.username }}
</div>
<img class="text-message__divider-dot" src="/public/media/instacoach/icons/divider-dot.png" alt="">
<div class="text-message__time">
{{ message.formattedTime }}
</div>
</div>
<div :class="{'text-message__text': true, 'text-message__text--pending': message.messageStatus !== 'received'}">{{ message.text }}</div>
<div class="text-message__not-delivered" v-if="message.messageStatus === 'failed'">
<img src="/public/media/instacoach/icons/not-delivered.svg">
<span>Not Delivered</span>
</div>
</div>
</div>
<div class="message-list__session-start" v-else-if="message.type === 'COACH_CONNECT'">
<div class="session-start__container">
<div class="session-start__title">Please add your coach:</div>
<div class="session-start__in-game-name">
<img class="in-game-name__logo" :src="getGameThumbnail(message.game)">
<div class="in-game-name__name">{{ message.coachInGameUsername }}</div>
</div>
<div class="session-start__communication">
<img class="communication__logo" :src="getCommunicationThumbnail(message.sessionCommunicationMethod)">
<div class="communication__name">{{ message.coachCommunicationUsername }}</div>
</div>
</div>
</div>
<div class="message-list__session-end" v-else-if="message.type === 'SESSION_SUMMARY'">
<div class="session-end__container">
<div class="session-end__title">Session Summary</div>
<div class="session-end__row" v-if="message.text">
<div class="session-end__label">Session:</div>
<div class="session-end__label">{{ mapSessionType(message.text.type) }}</div>
</div>
<div class="session-end__divider"></div>
<div class="session-end__row" v-if="message.text">
<div class="session-end__label">Time Elapsed:</div>
<div class="session-end__label">{{ convertDuration(message.text.duration) }}</div>
</div>
</div>
</div>
</div>
</div>

<div class="message-list__bottom-floating-actions" v-if="showUnreadMessagesButton(chat.id)">
<div class="bottom-floating-actions__recent-messages" @click="scrollToChatBottom(chat.id)">
<div class="recent-messages__left">
<img class="recent-messages__down-arrow" src="/public/media/instacoach/icons/down-arrow.svg">
<span class="recent-messages__label">Jump to most recent messages.</span>
</div>
<div class="recent-messages__unread" v-if="conversations[chat.id] &amp;&amp; conversations[chat.id].unread">
<span>{{conversations[chat.id].unread}}</span>
</div>
</div>
</div>
</div>

<div class="body__input-container">
<textarea class="body__input" rows="1" autocomplete="new-password" :ref="'message-tab-input-' + chat.id" placeholder="Type a message..." @keydown="handleChatInputEvent(chat.id, $event)" @keyup="handleChatInputEvent(chat.id, $event)" v-model="chat.input"></textarea>
<img v-if="!isChatInputDisabled(chat)" class="input__button" src="/public/media/instacoach/icons/send.svg" @click="submitChat(chat.id)">
<div class="input-container__error-message" v-if="chat.errorMessage">
<img class="error-message__icon" src="/public/media/instacoach/icons/not-delivered.svg">
<div class="error-message__text">{{ chat.errorMessage }}</div>
</div>
</div>
</div>
<div :class="{'messaging-tab-container__clearfix': true, 'messaging-tab-container__clearfix--open': !chat.minimized}" :ref="'message-tab-' + chatIndex"></div>
</div>
</div>

<div :class="{
            'instacoach-widget__coach-list-drawer': true,
            'instacoach-widget__coach-list-drawer--disabled': getDrawerDisabled,
            'instacoach-widget__coach-list-drawer--highlighted': drawerHighlighted
        }" v-if="drawerOpen" @click="clickInstacoachDrawer">
<div v-if="getDrawerDisabled" :class="{'coach-list-drawer__coverup': true}">
</div>
<div class="coach-list__in-session-warning" v-if="shouldShowInSessionWarning" @click="closeInSessionWarning">
<div class="in-session-warning__body" @click.stop="">
<div class="in-session-warning__header">
<h1>IN SESSION</h1>
<div class="header__button header__close-button" @click="closeInSessionWarning"><img src="/public/media/instacoach/icons/close.png" alt=""></div>
</div>
<div class="in-session-warning__content">
<h2>You're currently in a session</h2>
<p>If you want to begin a session with another coach, please click on "End Active Session" to continue.</p>
<button class="in-session-warning__submit-button" @click.stop="startConfirmingEndSession">End Active Session</button>
<button class="in-session-warning__link-button" @click.stop="closeInSessionWarning">Nevermind</button>
</div>
</div>
</div>
<div class="coach-list-drawer__menu">
<div class="coach-list-drawer__header" @click="drawerOpen = false">
<div class="header__buttons">
<div class="header__info-button" @click.stop="openGuidelines"><img src="/public/media/instacoach/icons/question.png"></div>
<div class="header__close-button" @click.stop="drawerOpen = false"><img src="/public/media/instacoach/icons/minimize.png"></div>
</div>
<div class="header__game-select" @click.stop="selectGame">
<div v-if="selectedGame === 'leagueoflegends'" class="game-select__selected-game">
<img class="game-select__game-icon" src="/public/media/instacoach/league/game-icon.png">
<span class="game-select__game-name">League of Legends</span>
<span class="game-select__game-online-count">{{ getNumCoachesOnlineForGame('leagueoflegends') }}<span>
</span></span></div>
<div v-else-if="selectedGame === 'fortnite'" class="game-select__selected-game">
<img class="game-select__game-icon" src="/public/media/instacoach/fortnite/game-icon.png">
<span class="game-select__game-name">Fortnite</span>
<span class="game-select__game-online-count">{{ getNumCoachesOnlineForGame('fortnite') }}<span>
</span></span></div>
<div v-else-if="selectedGame === 'super-smash-bros-ultimate'" class="game-select__selected-game">
<img class="game-select__game-icon" src="/public/media/instacoach/super-smash-bros-ultimate/game-icon.png">
<span class="game-select__game-name">Super Smash Bros. Ultimate</span>
<span class="game-select__game-online-count">{{ getNumCoachesOnlineForGame('super-smash-bros-ultimate') }}<span>
</span></span></div>

<img class="game-select__dropdown-icon" src="/public/media/instacoach/icons/caret.svg">
<div @click.stop="" v-if="gameSelectDropdownOpen" class="game-select__dropdown">
<div class="dropdown__item" @click="selectGameOption('leagueoflegends')">
<img src="/public/media/instacoach/league/game-icon.png">
<p>League of Legends</p>
<span class="dropdown__game-online-count">{{ getNumCoachesOnlineForGame('leagueoflegends') }}<span>
</span></span></div>
<div class="dropdown__item" @click="selectGameOption('fortnite')">
<img src="/public/media/instacoach/fortnite/game-icon.png">
<p>Fortnite</p>
<span class="dropdown__game-online-count">{{ getNumCoachesOnlineForGame('fortnite') }}<span>
</span></span></div>
<div class="dropdown__item" @click="selectGameOption('super-smash-bros-ultimate')">
<img src="/public/media/instacoach/super-smash-bros-ultimate/game-icon.png">
<p>Super Smash Bros. Ultimate</p>
<span class="dropdown__game-online-count">{{ getNumCoachesOnlineForGame('super-smash-bros-ultimate') }}<span>
</span></span></div>

</div>
</div>
</div>
<div class="coach-list-drawer__sub-header">
<div class="sub-header__search">
<div class="search__icon">
<img src="/public/media/instacoach/icons/search.svg">
</div>
<input type="text" placeholder="Search" v-model="searchQueryValue">
</div>
<div @click="filtersOpen = !filtersOpen" :class="{'sub-header__filter-button': true, 'sub-header__filter-button--open': filtersOpen || areFiltersSelected}">
<img v-if="filtersOpen || areFiltersSelected" src="/public/media/instacoach/icons/filter-white.svg">
<img v-else="" src="/public/media/instacoach/icons/filter.svg">
<span>Filters</span>
</div>
</div>
<div class="coach-list-drawer__filter-drawer" v-if="filtersOpen">
<div class="row">
<div class="filter-drawer__title">Filters</div>
<div class="filter-drawer__clear-button" @click="resetFilters">Clear All</div>
</div>
<div class="divider"></div>
<div class="row">
<label class="filter-drawer__label">Region</label>
<div class="filter-drawer__dropdown" @blur="filterRegionDropdownOpen = false" @click="filterRegionDropdownOpen = !filterRegionDropdownOpen" tabindex="-1">
<div class="dropdown__selection">
<div class="selection__placeholder" v-if="!areFilterRegionsSelected">Choose Server</div>
<div class="selection__item" v-for="(option, key) in selectedFilterRegions">{{key}}</div>
</div>
<img src="/public/media/instacoach/icons/dropdown-arrow.png">
<div v-if="filterRegionDropdownOpen" class="dropdown__options">
<div @click.stop="selectFilterRegion(option, key)" :class="{'option': true, 'option--selected': isFilterRegionSelected(key)}" v-for="(option, key) in getGameRegionOptions">{{option.name}}</div>
</div>
</div>
</div>

<div class="row">
<label class="filter-drawer__label">Rank</label>
<div class="filter-drawer__dropdown" @blur="filterRankDropdownOpen = false" @click="filterRankDropdownOpen = !filterRankDropdownOpen" tabindex="-1">
<div class="dropdown__selection">
<div class="selection__placeholder" v-if="!areFilterRanksSelected">Choose Rank</div>
<div class="selection__item" v-for="value, key in selectedFilterRanks">{{key}}</div>
</div>
<img src="/public/media/instacoach/icons/dropdown-arrow.png">
<div v-if="filterRankDropdownOpen" class="dropdown__options">
<div @click.stop="selectFilterRank(option)" :class="{'option': true, 'option--selected': isFilterRankSelected(option)}" v-for="option in getGameRankOptions">{{option}}</div>
</div>
</div>
</div>
<label class="filter-drawer__label">Specializations <span>(Roles)</span></label>
<div class="filter-drawer__multi-button-container">
<div @click="selectFilterSpecialty(option)" :class="{'multi-button': true, 'multi-button--specialization': true, 'multi-button--selected': selectedFilterSpecialties[option]}" v-for="(option, index) in getSpecializationOptions">
<img :src="getSpecialtyImage(option)">
<span class="multi-button__label" v-if="getSpecialtyAbbreviation(option)">{{getSpecialtyAbbreviation(option)}}</span>
</div>
</div>
<label class="filter-drawer__label">Price <span>(points)</span></label>
<div class="filter-drawer__multi-button-container">
<div @click="selectFilterPrice(index)" :class="{'multi-button': true, 'multi-button--price': true, 'multi-button--selected': selectedFilterPrices[index]}" v-for="(option, index) in getPriceOptions">
<img v-for="i in option.numPriceIcons" src="/public/media/instacoach/payment/gem.png">
</div>
</div>
</div>
</div>


<div class="coach-list-drawer__coach-list">
<div class="coach-list__header" v-if="shouldShowCurrentSessionTab" @click="activeSessionDropdownOpen = !activeSessionDropdownOpen"><h1>Active Session (1)</h1><img :class="{'header__dropdown-caret': true, 'header__dropdown-caret--open': activeSessionDropdownOpen}" src="/public/media/instacoach/icons/caret.svg"></div>
<div :class="{'coach-list__tile-container': true, 'coach-list__tile-container--closed': !activeSessionDropdownOpen}" v-if="shouldShowCurrentSessionTab">
<div class="coach-tile coach-tile--active-session" @click="openCurrentSessionChat">
<div class="coach-tile__avatar">
<img :src="currentRequest.coach.avatar">
<div class="avatar__badge avatar__badge--online"></div>
</div>
<div class="coach-tile__info">
<div class="info__row">
<div class="row__segment"><span class="info__name info__name--full-width">{{currentRequest.coach.name}}</span></div>
<div class="row__segment"><span class="info__ratings">{{getCurrentSessionTimeElapsed}}</span></div>
</div>
<div class="info__row">
<div class="row__segment"><span class="info__rank">You are currently in session.</span></div>
</div>
</div>
</div>
</div>

<div v-if="userLoggedIn &amp;&amp; getFavoriteCoaches &amp;&amp; getFavoriteCoaches.length > 0" class="coach-list__header" @click="favoriteCoachesDropdownOpen = !favoriteCoachesDropdownOpen"><h1>Your Favorite Pros (<span v-if="getFavoriteCoaches">{{ getFavoriteCoaches.length }}</span>)</h1><img :class="{'header__dropdown-caret': true, 'header__dropdown-caret--open': favoriteCoachesDropdownOpen}" src="/public/media/instacoach/icons/caret.svg"></div>
<div :class="{'coach-list__tile-container': true, 'coach-list__tile-container--closed': !favoriteCoachesDropdownOpen}">
<div class="coach-tile" v-for="(coach, index) in getFavoriteCoaches" @click="selectCoach(coach)">
<div class="coach-tile__avatar">
<img :class="{'avatar--faded': coach.status === 'offline' || coach.status === 'in-session'}" :src="coach.avatar">
<div :class="{'avatar__badge': true, 'avatar__badge--online': coach.status === 'online', 'avatar__badge--busy': (coach.status === 'in-session' || coach.status === 'busy'), 'avatar__badge--offline': coach.status === 'offline'}"></div>
</div>
<div class="coach-tile__info">
<div class="info__row">
<div class="row__segment">
<span :class="{'info__name': true, 'info__name--faded': coach.status === 'offline'}">{{coach.name}}</span>

</div>
<div class="row__segment" v-if="coach.ratings >= 1">
<span class="info__rating"><img src="/public/media/instacoach/ratings/star.svg" alt="" class="rating__star">{{convertRating(coach.rating)}}</span>
<span class="info__ratings">({{coach.ratings}})</span>
</div>
<div class="row__segment" v-else="">
<span class="info__new-coach-badge">NEW!</span>
</div>
</div>
<div class="info__row">
<div class="row__segment" v-if="getCoachBusyStatus(coach)">
<span class="info__rank">{{getCoachBusyStatus(coach)}}</span>
</div>
<div class="row__segment" v-else="">
<img class="info__rank-image" v-if="showRankImage(coach)" :src="getRankImageSrc(coach.games[selectedGame].rank)">
<span class="info__rank" v-if="coach.games[selectedGame].rank">{{coach.games[selectedGame].rank}}</span>
</div>
<div class="row__segment info__region-availabilities">
<span>{{ getRegions(coach).length }}</span>
<img src="/public/media/instacoach/icons/world.svg">
</div>

</div>
</div>
</div>
</div>

<div class="coach-list__header" @click="onlineCoachesDropdownOpen = !onlineCoachesDropdownOpen">
<h1>Pros Online Now (<span v-if="getVisibleOnlineCoaches">{{ getVisibleOnlineCoaches.length }}</span>)</h1>
<img :class="{'header__dropdown-caret': true, 'header__dropdown-caret--open': onlineCoachesDropdownOpen}" src="/public/media/instacoach/icons/caret.svg">
</div>
<div :class="{'coach-list__tile-container': true, 'coach-list__tile-container--closed': !onlineCoachesDropdownOpen}">
<div class="coach-tile" v-for="(coach, index) in getVisibleOnlineCoaches" @click="selectCoach(coach)">
<div class="coach-tile__avatar">
<img :src="coach.avatar">
<div :class="{'avatar__badge': true, 'avatar__badge--online': coach.status === 'online', 'avatar__badge--busy': coach.status === 'busy'}"></div>
</div>
<div class="coach-tile__info">
<div class="info__row">
<div class="row__segment">
<span class="info__name">{{coach.name}}</span>

</div>
<div class="row__segment" v-if="coach.ratings >= 1">
<span class="info__rating"><img src="/public/media/instacoach/ratings/star.svg" alt="" class="rating__star">{{convertRating(coach.rating)}}</span>
<span class="info__ratings">({{coach.ratings}})</span>
</div>
<div class="row__segment" v-else="">
<span class="info__new-coach-badge">NEW!</span>
</div>
</div>
<div class="info__row">
<div class="row__segment">
<img class="info__rank-image" v-if="showRankImage(coach)" :src="getRankImageSrc(coach.games[selectedGame].rank)">
<span class="info__rank" v-if="coach.games[selectedGame].rank">{{coach.games[selectedGame].rank}}</span>
</div>
<div class="row__segment info__region-availabilities">
<span>{{ getRegions(coach).length }}</span>
<img src="/public/media/instacoach/icons/world.svg">
</div>

</div>
</div>
</div>
<div v-if="showShowMore" class="coach-list__show-more-button" @click="showMoreCoaches">
<span>View {{ getShowMoreAmount }} More</span>
</div>
</div>

<div class="coach-list__header" @click="inSessionCoachesDropdownOpen = !inSessionCoachesDropdownOpen" v-if="getInSessionCoaches"><h1>Currently In Session (<span>{{ getInSessionCoaches.length }}</span>)</h1><img :class="{'header__dropdown-caret': true, 'header__dropdown-caret--open': inSessionCoachesDropdownOpen}" src="/public/media/instacoach/icons/caret.svg"></div>
<div :class="{'coach-list__tile-container': true, 'coach-list__tile-container--closed': !inSessionCoachesDropdownOpen}" v-if="getInSessionCoaches">
<div class="coach-tile" v-for="(coach, index) in getInSessionCoaches" @click="selectCoach(coach)">
<div class="coach-tile__avatar">
<img :src="coach.avatar">
<div class="avatar__badge avatar__badge--busy"></div>
</div>
<div class="coach-tile__info">
<div class="info__row">
<div class="row__segment">
<span class="info__name">{{coach.name}}</span>

</div>
<div class="row__segment" v-if="coach.ratings >= 1">
<span class="info__rating"><img src="/public/media/instacoach/ratings/star.svg" alt="" class="rating__star">{{convertRating(coach.rating)}}</span>
<span class="info__ratings">({{coach.ratings}})</span>
</div>
<div class="row__segment" v-else="">
<span class="info__new-coach-badge">NEW!</span>
</div>
</div>
<div class="info__row">
<div class="row__segment">
<span class="info__rank" v-if="coach.games[selectedGame].rank">{{getCoachBusyStatus(coach)}}</span>
</div>
<div class="row__segment info__region-availabilities">
<span>{{ getRegions(coach).length }}</span>
<img src="/public/media/instacoach/icons/world.svg">
</div>

</div>
</div>
</div>
</div>

<div class="coach-list__header" @click="offlineCoachesDropdownOpen = !offlineCoachesDropdownOpen" v-if="getOfflineCoaches"><h1>Offline (<span>{{ getNumOfflineCoaches }}+</span>)</h1><img :class="{'header__dropdown-caret': true, 'header__dropdown-caret--open': offlineCoachesDropdownOpen}" src="/public/media/instacoach/icons/caret.svg"></div>
<div :class="{'coach-list__tile-container': true, 'coach-list__tile-container--closed': !offlineCoachesDropdownOpen}" v-if="getOfflineCoaches">
<div class="coach-tile" v-for="(coach, index) in getOfflineCoaches" @click="selectCoach(coach)">
<div class="coach-tile__avatar">
<img class="avatar--faded" :src="coach.avatar">
<div class="avatar__badge avatar__badge--offline"></div>
</div>
<div class="coach-tile__info">
<div class="info__row">
<div class="row__segment">
<span class="info__name">{{coach.name}}</span>

 </div>
<div class="row__segment" v-if="coach.ratings >= 1">
<span class="info__rating"><img src="/public/media/instacoach/ratings/star.svg" alt="" class="rating__star">{{convertRating(coach.rating)}}</span>
<span class="info__ratings">({{coach.ratings}})</span>
</div>
<div class="row__segment" v-else="">
<span class="info__new-coach-badge">NEW!</span>
</div>
</div>
<div class="info__row">
<div class="row__segment">
<span class="info__rank" v-if="coach.games[selectedGame].rank">{{getCoachBusyStatus(coach)}}</span>
</div>
<div class="row__segment info__region-availabilities">
<span>{{ getRegions(coach).length }}</span>
<img src="/public/media/instacoach/icons/world.svg">
</div>

</div>
</div>
</div>
<div v-if="showShowMoreOffline" class="coach-list__show-more-button" @click="showMoreOfflineCoaches">
<span>View More</span>
</div>
</div>
</div>
</div>

<div :class="{'instacoach-widget__modal': true, 'instacoach-widget__modal--active': modalOpen, 'instacoach-widget__modal--dark': getModalDark, 'instacoach-widget__modal--coach-profile': onCoachProfile}">

<div class="modal__body modal__body--register" @click.stop="" v-if="state === 'register'">
<div class="modal-body__contents require-login-modal">
<div class="login-modal__close-button" @click="closeModal"><img src="/public/media/instacoach/icons/cancel.svg"></div>
<h1>Join <strong>ProGuides</strong></h1>
<p>To perform this action you must be registered<br>and / or logged in.</p>
<a class="login-modal__button login-modal__button--login" :href="getLoginHref">Log In</a>
<a class="login-modal__button login-modal__button--register" :href="getRegisterHref">Create an Account</a>
<button class="login-modal__link" @click="closeModal">Continue without login</button>
</div>
</div>

<div class="modal__body modal__body--onboarding" @click.stop="" v-if="showOnboarding">
<div class="modal-body__header modal-body__header--onboarding">
<div class="header__column">
<div class="header__title">PLAY WITH PROS</div>
<div class="header__subtitle">HOW IT WORKS</div>
</div>
</div>
<div v-if="state === 'onboarding-1'" class="modal-body--onboarding__contents modal-body--onboarding__contents--1">
<div class="h1">Select a Pro</div>
<div class="p">Click on a Pro to see their Coach Profile.</div>
<div class="onboarding__image-container">
<img src="/public/media/instacoach/onboarding/student/new/Onboarding 1.svg">

</div>
<div class="p">Our Pros are verified streamers and pro players who can coach you.</div>
<div class="onboarding__progress">
<div class="progress__circle progress__circle--on"></div>
<div class="progress__circle progress__circle"></div>
<div class="progress__circle progress__circle"></div>
</div>
</div>
<div v-if="state === 'onboarding-2'" class="modal-body--onboarding__contents modal-body--onboarding__contents--1">
<div class="h1">Start a Session</div>
<div class="p">Use <img class="gem" src="/public/media/instacoach/payment/gem.png"> points to start a Coaching Session.</div>
<div class="onboarding__image-container">
<img src="/public/media/instacoach/onboarding/student/new/Onboarding 2.svg">

</div>
<a class="pro-link" href="/checkout">
<div class="pro">PRO Member Perk:</div>
<div class="p">Message any PRO without buying a session.</div>
</a>
<div class="onboarding__progress">
<div class="progress__circle progress__circle"></div>
<div class="progress__circle progress__circle--on"></div>
<div class="progress__circle progress__circle"></div>
</div>
</div>
<div v-if="state === 'onboarding-3'" class="modal-body--onboarding__contents modal-body--onboarding__contents--1">
<div class="h1">Connect and Start Winning</div>
<div class="p">Once in session, the Pro will add you in game.</div>
<div class="onboarding__image-container">
<img src="/public/media/instacoach/onboarding/student/new/Onboarding 3.svg">

</div>
<div class="p">Our Pros will help players like yourself start winning right now.&nbsp;<strong>Guaranteed</strong></div>
<div class="onboarding__progress">
<div class="progress__circle progress__circle"></div>
<div class="progress__circle progress__circle"></div>
<div class="progress__circle progress__circle--on"></div>
</div>
</div>
<div class="modal-body--onboarding__actions">
<p v-if="state === 'onboarding-3'">By clicking "Continue", I agree to the <button class="link-button" @click="openGuidelines">Play With Pro Guidelines</button>.</p>
<button @click="onboardingContinue">Continue</button>
</div>
</div>

<div class="modal__body modal__body--guidelines" v-if="state === 'guidelines'">
<div class="modal-body__header">
<h1>Play With Pro Guidelines</h1>
<div class="header__button header__close-button" @click="closeGuidelines"><img src="/public/media/instacoach/icons/close.png" alt=""></div>
</div>
<div class="guidelines__contents">
<ol>
<li>
<div class="h1">NO RANKED GAMES IN DUO QUEUE.</div>
<div class="p">Playing ranked matches together is prohibited.<br><br>
Ranked games while spectating is allowed.</div>
</li>
<li>
<div class="h1">FOLLOW THE RECOMMENDED TIME.</div>
<div class="p">If a game ends in under {{getGameMinimumTime}} minutes for any reason, you may ask to play another. After two (2) games, you must purchase another session to be eligible for continued coaching.</div>
</li>
<li>
<div class="h1">KEEP IT PROFESSIONAL.</div>
<div class="p">Please keep communication primarily within the session and game. After you complete a session, you MUST remove the coach's credentials from any contact lists. We value respecting each individual's privacy.</div>
</li>
<li>
<div class="h1">STAY ON PLATFORM.</div>
<div class="p">Please do not accept sessions outside of ProGuides. Getting coached through our platform guarantees every student will be provided the best quality coaching experience.<br><br>Please report any coaches who try to contact you for session outside of ProGuides to support@proguides.com.</div>
</li>
</ol>
<div class="contents__divider"></div>
<div style="text-align: center;">
<div class="h1">NEED HELP?</div>
<div class="p">If you have questions or concerns, click the button below to start a live chat with our Support Team.</div>
<button class="cta" @click="startHelpChat">I need help</button>
</div>
<button class="link-button" @click="startOnboarding">How It Works</button>
<a href="/instapro">Apply to Coach</a>
</div>
</div>

<div class="modal__pro-locked" v-if="showProLockedModal">
<div>
<img @click="showProLockedModal = false" class="close-button" src="/public/media/instacoach/icons/close-button.png">
<img class="gem" src="/public/media/instacoach/icons/pro-gem.png">
<div class="h1">You haven't had a session<br>with this Pro yet.</div>
<div class="p">To get unlimited messages with Pros anytime, upgrade to a PRO membership.</div>
<button @click="routeToSales">UPGRADE TO PRO</button>
</div>
</div>

<div :class="{'modal__body': true, 'modal__body--selecting': true, 'main-profile': (state === 'selecting')}" v-if="onCoachProfile &amp;&amp; getSelectedCoach">
<div class="modal-body__header">
<div v-if="!isWaitingForCoach" class="header__button header__back-button only-small-mobile" @click="closeModal"><img src="/public/media/instacoach/icons/back.png" alt=""></div>
<h1>COACH PROFILE</h1>
<div v-if="!isWaitingForCoach" class="header__button header__close-button" @click="closeModal"><img src="/public/media/instacoach/icons/close.png" alt=""></div>
</div>

<div class="selecting__content selecting__content--basic-info">
<div class="content__avatar">
<img :src="getSelectedCoach.avatar">
<div :class="{
                        'avatar__badge': true,
                        'avatar__badge--online': getSelectedCoach.status === 'online',
                        'avatar__badge--busy': ['busy', 'in-session'].includes(getSelectedCoach.status),
                        'avatar__badge--offline': getSelectedCoach.status === 'offline'
                    }"></div>
</div>
<div class="content__info">
<div class="info__row" style="align-items: flex-end">
<h2>{{getSelectedCoach.name}}</h2>
</div>
<div class="info__row" style="margin-top: 0.5em;">
<h2 class="info__region-tag"><span v-for="region in getSelectedCoach.games[selectedGame].regions">{{region}}</span></h2>
</div>
<div class="info__row" style="align-items: center; margin: 0.25em 0;">
<img class="info__rank-image" v-if="showRankImage(getSelectedCoach)" :src="getRankImageSrc(getSelectedCoach.games[selectedGame].rank)">
<div class="info__rank" v-if="getSelectedCoach.games[selectedGame].rank">{{getSelectedCoach.games[selectedGame].rank}}</div>
<div class="info__role-container">
<span class="info__role" v-for="specialty in getSelectedCoach.games[selectedGame].specialties">
<span v-if="selectedGame === 'leagueoflegends' || selectedGame === 'fortnite'">
<img :src="getSpecialtyImage(specialty)">
</span>
<span v-else="">
<span class="info__role">
<div class="role__generic">{{specialty}}</div>
</span>
</span>
</span>
</div>
</div>
<div class="info__row" style="align-items: flex-start;" v-if="getSelectedCoach.ratings >= 1">
<div class="info__column">
<div class="info__rating">
<div class="rating__star" v-for="i in 5">
<img :src="getRatingStarImage(getSelectedCoach.rating, i)">

</div>
<p class="rating__number">{{convertRating(getSelectedCoach.rating)}} (<span class="rating__ammount">{{getSelectedCoach.ratings}}</span>)</p>
</div>
</div>
</div>
<div class="info__row" v-else="">
<span class="info__new-coach-badge">NEW!</span>
</div>
</div>
<div class="content__actions-container">
<button class="favorite-coach" :disabled="favoritingCoach" v-if="!isCoachFavorite(getSelectedCoach)" @click="favoriteCoach"><span>Follow</span></button>
<button class="favorite-coach favorite-coach--selected" :disabled="favoritingCoach" v-else="" @click="unFavoriteCoach"><span>Following</span><img src="/public/media/instacoach/icons/checkmark.png"></button>
</div>
</div>

<div class="selecting__container selecting__container--scrollable" v-if="state === 'selecting'">

<div v-if="getCoachSessionTypeGroups.length > 1" class="selecting__content selecting__content--select-session-type-group">
<div v-for="coachSessionTypeGroup of getCoachSessionTypeGroups" class="session-types-selector-label" :class="{'session-types-selector-label--selected' : coachSelectionSessionTypeGroup === coachSessionTypeGroup.type}" @click="coachSelectionSessionTypeGroup = coachSessionTypeGroup.type">
{{ coachSessionTypeGroup.label }}
<span v-if="coachSessionTypeGroup.isNew">NEW!</span>
</div>
</div>
<div class="selecting__content selecting__content--select-session-type">
<div v-if="coachSelectionSessionTypeGroup === 'session'" class="session-types">
<div @click="coachSelectionSessionType = 3" :class="{'session-types__button': true, 'session-types__button--selected': getSelectedCoachingType === 3}" tabindex="0" v-if="oneVsOneAvailable">
<div class="session-types__radio">
<div class="radio__center"></div>
</div>
<div class="session-types__text-container">
<h1>Play 1v1 with Pro <span v-if="getCoach1v1GameCount > 1">({{ [getCoach1v1GameCount, getCoach1v1GameCount !== 1 ? 'Games' : 'Game'].join(' ') }})</span></h1>
<p>Receive feedback in 1v1s.</p>
</div>
<div class="session-types__time-estimate">{{ getCoach1v1DurationEstimate }}</div>
<div class="session-types__point-cost">
<h2>{{getCoachSessionTypeCost('1v1')}}</h2>
<img src="/public/media/instacoach/payment/gem.png">
</div>
</div>
<div @click="coachSelectionSessionType = 0" :class="{'session-types__button': true, 'session-types__button--selected': getSelectedCoachingType === 0}" tabindex="0" v-if="inGameAvailable">
<div class="session-types__radio">
<div class="radio__center"></div>
</div>
<div class="session-types__text-container">
<h1>Play <span>{{coachSelectionGamesAmount}}</span> {{getSessionUnit}}<span v-if="coachSelectionGamesAmount > 1">s</span> with Pro</h1>
<p>You receive feedback while playing together.</p>
</div>
<div class="session-types__time-estimate no-small-mobile no-desktop">{{getCurrentGameDurationEstimate}}</div>
<div class="session-types__point-cost">
<h2>{{getCoachSessionTypeCost('in-game')}}</h2>
<img src="/public/media/instacoach/payment/gem.png">
</div>
</div>
<div @click="coachSelectionSessionType = 1" :class="{'session-types__button': true, 'session-types__button--selected': getSelectedCoachingType === 1}" tabindex="0" v-if="spectateAvailable">
<div class="session-types__radio">
<div class="radio__center"></div>
</div>
<div class="session-types__text-container">
<h1>Play <span>{{coachSelectionGamesAmount}}</span> Spectated {{getSessionUnit}}<span v-if="coachSelectionGamesAmount > 1">s</span></h1>
<p>You receive feedback while Pro watches you play.</p>
</div>
<div class="session-types__time-estimate no-small-mobile no-desktop">{{getCurrentGameDurationEstimate}}</div>
<div class="session-types__point-cost">
<h2>{{getCoachSessionTypeCost('spectate')}}</h2>
<img src="/public/media/instacoach/payment/gem.png">
</div>
</div>
<div @click="coachSelectionSessionType = 2" :class="{'session-types__button': true, 'session-types__button--selected': getSelectedCoachingType === 2}" tabindex="0" v-if="replayAvailable">
<div class="session-types__radio">
<div class="radio__center"></div>
</div>
<div class="session-types__text-container">
<h1>Replay Analysis</h1>
<p>Coach gives feedback on recorded gameplay.</p>
</div>
<div class="session-types__time-estimate">{{getCoachReplayAnalysisDuration}}</div>
<div class="session-types__point-cost">
<h2>{{getCoachSessionTypeCost('replay')}}</h2>
<img src="/public/media/instacoach/payment/gem.png">
</div>
</div>
</div>
<div v-if="coachSelectionSessionTypeGroup === 'passes'" class="session-types">
<div @click="coachSelectionSessionType = 4" :class="{'session-types__button': true, 'session-types__button--selected': getSelectedCoachingType === 4}" tabindex="0" v-if="allDayPassAvailable">
<div class="session-types__radio">
<div class="radio__center"></div>
</div>
<div class="session-types__text-container">
<h1>All-Day Pass (24 Hours total)</h1>
<p><b>Recommended for dedicated climbers.</b></p>
<p>Coach available for help in an extended session.<br>24 hours can be split up<br></p>
</div>
<div class="session-types__point-cost">
<h2>{{getCoachSessionTypeCost('all-day-pass')}}</h2>
<img src="/public/media/instacoach/payment/gem.png">
</div>
</div>
</div>
</div>

<div class="selecting__content selecting__content--purchase-actions">

<div @click="openCoachMessage(getSelectedCoach)" class="purchase-actions__button purchase-actions__button--chat">
<h1>CHAT WITH COACH</h1>
</div>
<div v-if="notEnoughPoints &amp;&amp; userLoggedIn" @click="reloadPoints" class="purchase-actions__button purchase-actions__button--refill">
<h1>REFILL<span>&nbsp;POINTS</span></h1>
<div class="button__point-cost">
<h2>{{getSelectedSessionTypeCost}}</h2>
<img src="/public/media/instacoach/payment/gem.png">
</div>
</div>
<div v-else="" :class="{'purchase-actions__button': true, 'purchase-actions__button--submit': true, 'purchase-actions__button--disabled': playNowDisabled}" :disabled="playNowDisabled" @click="requestCoach">
<h1>PLAY NOW</h1>
<div class="button__point-cost">
<h2>{{getSelectedSessionTypeCost}}</h2>
<img src="/public/media/instacoach/payment/gem.png">
</div>
</div>
</div>

<div class="selecting__content selecting__content--extra-info">
<div class="extra-info__bio">
<h1>ABOUT THE COACH:</h1>
<div ref="commentOuter" :class="{'info__bio--clamped': coachProfileBioClamped}">
<div ref="commentInner">
<p>{{getSelectedCoach.bio}}</p>
</div>
</div>
<div v-if="!coachProfileBioClamped">

<h1 style="margin-top: 1em;">TYPICAL SESSION:</h1>
<p class="info__bio">{{getSelectedCoach.typicalSession}}</p>
</div>
<button @click="coachProfileBioReadMore" class="bio__read-more-button" v-if="coachProfileShowReadMoreButton">Read More</button>
<button @click="coachProfileBioShowLess" class="bio__read-more-button" v-else-if="!coachProfileShowReadMoreButton">Show Less</button>
</div>
</div>

<div v-if="getSelectedCoachReviews.length > 0" ref="coach-reviews" class="selecting__content selecting__content--reviews">
<h1>REVIEWS:</h1>
<div v-for="review in getSelectedCoachReviews" class="review-list__item">
<div class="item__row">
<div class="review__stars">
<div class="rating__star" v-for="i in 5">
<img v-if="i <= convertRating(review.rate)" src="/public/media/instacoach/ratings/star.svg">
<img v-else="" src="/public/media/instacoach/ratings/empty-star.svg">
</div>
</div>
<div class="review__time">{{getReviewTimestamp(review)}}</div>
</div>
<p>{{review.comment}}</p>
</div>
</div>
</div>

<div class="selecting__waiting" v-else-if="state === 'waiting'">
<div class="waiting__cancelled" v-if="requestCancelled">
<p>Request Cancelled</p>
</div>
<div class="waiting__coach-unavailable" v-else-if="coachRejected">
<p>Sorry the coach declined your request, try another coach.</p>
<p>No points have been deducted from your balance.</p>
<button class="coach-unavailable__close-button" @click="closeModal">Close</button>
</div>
<div class="waiting__coach-unavailable" v-else-if="coachUnavailable">
<p v-if="coachUnavailableMessage">{{coachUnavailableMessage}}</p>
<p v-else="">The Coach is currently unavailable or in another session.</p>
<p>No points have been deducted from your balance.</p>
<button class="coach-unavailable__close-button" @click="closeModal">Close</button>
</div>
<div v-else="">
<div class="request-progress">
<div :class="{'request-progress__bar': true, 'request-progress__bar--moving': coachWaitingProgressStart}"></div>
</div>
<div class="waiting__content">
<h3 style="margin-bottom: 0.5rem;">Request Sent!</h3>
<p style="margin-top: 0; margin-bottom: 4.0rem;">Waiting for Coach to accept.</p>
<p style="margin-bottom: 1.0rem;"><strong>Reminder:</strong> Please have {{getCurrentGameName}} and {{sessionConfirmationCommunicationMethod}} open and ready.</p>


</div>
</div>
</div>
</div>

<div class="modal__body modal__body--confirming" v-if="state === 'confirming'">
<div class="modal-body__header">
<div class="header__button header__back-button" @click="backModal('selecting')"><img src="/public/media/instacoach/icons/back.png" alt=""></div>
<h1>CONFIRM SESSION</h1>
<div class="header__button header__close-button" @click="closeModal"><img src="/public/media/instacoach/icons/close.png" alt=""></div>
</div>
<div class="modal-body__contents confirming__points-section">
<h1>Use {{Number(getSelectedSessionTypeCost).toLocaleString()}} points for a Coach Session?</h1>
<div class="points-section__points-breakdown">
<div class="points-breakdown__item">
<div class="points-breakdown__points">
<h1>{{Number(currentPoints).toLocaleString()}}</h1>
<img src="/public/media/instacoach/payment/gem.png" alt="">
</div>
<h2>Current Balance</h2>
</div>
<img class="arrow" src="/public/media/instacoach/icons/arrow.png" alt="">
<div class="points-breakdown__item">
<div class="points-breakdown__points">
<h1>{{Number(currentPoints - getSelectedSessionTypeCost).toLocaleString()}}</h1>
<img src="/public/media/instacoach/payment/gem.png" alt="">
</div>
<h2>Remaining Balance</h2>
</div>
</div>
<p>Points will be deducted once the coach accepts.</p>
</div>
<div class="confirming__actions">
<button class="confirming__confirm-button" @click="confirmCoachRequest">Confirm</button>
</div>
</div>

<div class="modal__body modal__body--confirming" v-if="state === 'confirming-info'">
<div class="modal-body__header">
<div class="header__button header__back-button" @click="backModal('confirming')"><img src="/public/media/instacoach/icons/back.png" alt=""></div>
<h1>CONTACT INFORMATION</h1>
</div>
<div class="modal-body__contents confirming__information-section">
<h1>Enter your information for {{getSelectedCoach.name}}</h1>
<p :class="{'modal__error': true, 'modal__error--visible': sessionConfirmationError}">{{sessionConfirmationError}}</p>
<div class="information-section__form-fields">
<div class="form-fields__input">
<label for="region">
<img class="small" src="/public/media/instacoach/icons/globe.svg">
<span>REGION</span>
</label>
<div class="input__dropdown" @click="openContactInfoRegionDropdown" @blur="contactInfoRegionDropdownOpen = false" tabindex="-1">
<div class="dropdown__caret">
<img src="/public/media/instacoach/icons/dropdown-arrow.svg">
</div>
<div class="dropdown__selection">{{_.get(getContactInfoRegionOptions, selectedContactInfoRegion + '.name') || 'Choose Server'}}</div>
<div class="dropdown__list" v-if="contactInfoRegionDropdownOpen">
<div class="list__item" @click.stop="selectContactInfoRegion(key)" v-for="(region, key) in getContactInfoRegionOptions">
{{region.name}}
</div>
</div>
</div>
</div>
<div class="form-fields__input" v-if="shouldShowPlatformDropdown">
<label for="region">
<img class="small" src="/public/media/instacoach/icons/pc.svg">
<span>PLATFORM</span>
</label>
<div class="input__dropdown" @click="openContactInfoPlatformDropdown" @blur="contactInfoPlatformDropdownOpen = false" tabindex="-1">
<div class="dropdown__caret">
<img src="/public/media/instacoach/icons/dropdown-arrow.svg">
</div>
<div class="dropdown__selection">{{_.get(getContactInfoPlatformOptions, selectedContactInfoPlatform + '.name') || 'Choose Platform'}}</div>
<div class="dropdown__list" v-if="contactInfoPlatformDropdownOpen">
<div class="list__item" @click.stop="selectContactInfoPlatform(key)" v-for="(platform, key) in getContactInfoPlatformOptions">
{{platform.name}}
</div>
</div>
</div>
</div>
<div class="form-fields__input">
<label for="in-game-username">
<img v-if="selectedGame === 'leagueoflegends'" src="/public/media/instacoach/league/game-icon.png">
<img v-else-if="selectedGame === 'fortnite'" src="/public/media/instacoach/fortnite/game-icon.png">
<img v-else-if="selectedGame === 'super-smash-bros-ultimate'" src="/public/media/instacoach/super-smash-bros-ultimate/game-icon.png">
<span>{{getInGameUsernameLabel}}</span>
</label>
<input id="in-game-username" v-model="sessionConfirmationInGameUsername" :placeholder="'Enter your ' + getInGameUsernameLabel" type="text">
</div>

<div class="form-fields__input discord-skype" v-if="sessionConfirmationCommunicationMethod === 'discord'">
<button class="input__switch-method" @click="selectSessionConfirmationCommunicationMethod('skype')">Use Skype instead</button>
<label for="discord"><img src="/public/media/instacoach/icons/discord-icon.png"><span>DISCORD</span></label>
<input id="discord" type="text" placeholder="Enter your discord username" v-model="sessionConfirmationDiscord">
</div>
<div class="form-fields__input discord-skype" v-if="sessionConfirmationCommunicationMethod === 'skype'">
<button class="input__switch-method" @click="selectSessionConfirmationCommunicationMethod('discord')">Use Discord instead</button>
<label for="skype"><img src="/public/media/instacoach/icons/skype-icon.png"><span>SKYPE</span></label>
<input id="skype" type="text" placeholder="Enter your skype username" v-model="sessionConfirmationSkype">
</div>
<div class="information-section__checkbox">
<label for="save-info-checkbox">
<div class="checkbox__box"><img v-if="confirmSessionSavePersonalInfo" src="/public/media/instacoach/icons/checkbox-check--blue.svg"></div>
Save this information for future sessions
</label>
<input id="save-info-checkbox" type="checkbox" v-model="confirmSessionSavePersonalInfo">
</div>
</div>
</div>
<div class="confirming__actions">
<button :disabled="sessionConfirmationCoachBusy" class="confirming__confirm-button" @click="submitSessionInformation">Confirm</button>
</div>
</div>

<div class="modal__body modal__body--reload" v-if="state === 'reload-points'">
<div class="modal-body__header">
<div class="header__button header__back-button" @click="backModal('selecting')"><img src="/public/media/instacoach/icons/back.png" alt=""></div>
<h1>REFILL YOUR POINTS</h1>
<div class="header__button header__close-button" @click="closeModal"><img src="/public/media/instacoach/icons/close.png" alt=""></div>
</div>
<div class="modal-body__contents">
<p class="modal__subheader" style="margin-bottom: 2.0rem;">Select the amount of points:</p>
<div class="reload__points-buttons">
<div v-for="(option, index) in pointsOptions" :class="{'points-button': true, 'points-button--selected': index === selectedPointsOptionIndex}" @click="selectPointsOption(index)" :key="'points-option-'+ option.points">
<div class="points-button__points">
{{Number(option.basePoints).toLocaleString()}}
<img v-if="index === selectedPointsOptionIndex" src="/public/media/instacoach/payment/gem_shadow.png">
<img v-else="" src="/public/media/instacoach/payment/gem.png">
</div>
<div class="points-button__points-bonus" v-if="option.bonusPoints > 0">
<span>+{{ option.bonusPoints }}</span> Bonus!
</div>
<div class="points-button__price">${{option.price}}</div>
</div>
</div>
<div class="reload__payment-methods">
<p :class="{'modal__subheader': true, 'payment-methods__error': true, 'payment-methods__error--visible': pointsSelectError}">{{pointsSelectError}}</p>
<p class="modal__subheader">Select your payment method:</p>
<div class="payment-methods__button" @click="selectPayPal">
<div class="button__image"><img src="/public/media/instacoach/payment/paypal.png" alt=""></div>
<div class="button__label"><span v-if="paypalLoading">loading...</span><span v-else="">PayPal</span></div>
</div>
<div class="payment-methods__button" @click="selectCreditCard">
<div class="button__image"><img src="/public/media/instacoach/payment/creditcard.png" alt=""></div>
<div class="button__label">Credit Card</div>
</div>
</div>
</div>
</div>

<div class="modal__body modal__body--credit-card" v-if="state === 'purchasing--credit-card-select'">
<div class="modal-body__header">
<div class="header__button header__back-button" @click="backModal('reload-points')"><img src="/public/media/instacoach/icons/back.png" alt=""></div>
<h1>CREDIT CARD</h1>
<div class="header__button header__close-button" @click="closeModal"><img src="/public/media/instacoach/icons/close.png" alt=""></div>
</div>
<div class="modal-body__contents">
<p class="modal__subheader">Select saved payment method:</p>
<div class="saved-cards">
<div class="card-entry saved-card" v-for="savedCard in savedStripeSources" :class="{ 'saved-card--selected': savedCard.id === selectedStripeSource }" @click="selectStripeCard(savedCard)">
<span class="saved-card__brand-image">
<img :src="creditCardAssets[savedCard.brand]" v-if="creditCardAssets[savedCard.brand]">
</span>
<span class="saved-card__brand-name">{{savedCard.brand}}</span>
<span class="saved-card__last4">ending in {{savedCard.last4}}</span>
<span class="saved-card__expiry">Exp {{savedCard.exp_month &lt; 10 ? ('0' + savedCard.exp_month) : savedCard.exp_month}}/{{savedCard.exp_year % 100}}</span>
</div>
<div class="card-entry add-new-card" @click="backModal('purchasing--credit-card')">
<span class="add-new-card__icon">
<img src="/public/media/store/add-icon.svg">
</span>
<span class="add-new-card__text">Add a card</span>
</div>
</div>

<button @click="submitStripeCardForm" :disabled="!stripe || !selectedStripeSource || loadingCreditCard" :class="{ 'loading': loadingCreditCard }" class="credit-card__submit-button ui button">
<span v-if="loadingCreditCard"></span>
<span v-else="">Continue</span>
</button>
</div>
</div>

<div class="modal__body modal__body--credit-card" v-if="state === 'purchasing--credit-card'">
<div class="modal-body__header">
<div class="header__button header__back-button" @click="backModal(savedStripeSources.length ? 'purchasing--credit-card-select' : 'reload-points')"><img src="/public/media/instacoach/icons/back.png" alt=""></div>
<h1>CREDIT CARD</h1>
<div class="header__button header__close-button" @click="closeModal"><img src="/public/media/instacoach/icons/close.png" alt=""></div>
</div>
<div class="modal-body__contents">
<p class="modal__subheader">Fill out the information below:</p>
<div class="shop-creditcard">
<div class="shop-creditcard-segment">
<div class="shop-creditcard-segment__row">
<div class="shop-creditcard-segment__field">
<p class="shop-creditcard-segment__label">Cardholder's Name</p>
<div class="shop-creditcard-segment__input-container">
<input type="text" v-model="stripeCardholderName">
<img class="shop-creditcard-segment__image shop-creditcard-segment__image--error" src="/public/media/store/error.png">
</div>
</div>
</div>
<div class="shop-creditcard-segment__row">
<div class="shop-creditcard-segment__field" id="card-number-field">
<p class="shop-creditcard-segment__label">Card Number</p>
<div class="shop-creditcard-segment__input-container">
<div id="stripe-card-number"></div>
<img class="shop-creditcard-segment__image shop-creditcard-segment__image--cards" src="/public/media/store/cards.png">
<img class="shop-creditcard-segment__image shop-creditcard-segment__image--error" src="/public/media/store/error.png">
</div>
<p class="shop-creditcard-segment__error"></p>
</div>
</div>
<div class="shop-creditcard-segment__row">
<div class="shop-creditcard-segment__field" id="cvv-field">
<p class="shop-creditcard-segment__label">CVV</p>
<div class="shop-creditcard-segment__input-container">
<div id="stripe-card-cvv"></div>
<img class="shop-creditcard-segment__image shop-creditcard-segment__image--faded" src="/public/media/store/cvv.png">
<img class="shop-creditcard-segment__image shop-creditcard-segment__image--error" src="/public/media/store/error.png">
</div>
<p class="shop-creditcard-segment__error"></p>
</div>
<div class="shop-creditcard-segment__field" id="expiry-field">
<p class="shop-creditcard-segment__label">Expiration Date (MM/YY)</p>
<div class="shop-creditcard-segment__input-container">
<div id="stripe-card-expiry"></div>
<img class="shop-creditcard-segment__image shop-creditcard-segment__image--error" src="/public/media/store/error.png">
</div>
<p class="shop-creditcard-segment__error"></p>
</div>
</div>
<div class="shop-creditcard-segment__row">
 <div class="shop-creditcard-segment__field" id="country-field">
<p class="shop-creditcard-segment__label">Country</p>
<div class="shop-creditcard-segment__input-container">
<select v-model="stripeCardCountry">
<option v-for="(countryName, countryCode) in isoCountries" :key="countryCode" :value="countryCode">{{ countryName }}</option>
</select>
</div>
<p class="shop-creditcard-segment__error"></p>
</div>
<div class="shop-creditcard-segment__field" id="postal-code-field">
<p class="shop-creditcard-segment__label">Postal Code</p>
<div class="shop-creditcard-segment__input-container">
<input type="text" v-model="stripeCardPostalCode">
</div>
<p class="shop-creditcard-segment__error"></p>
</div>
</div>
<div id="card-errors" class="shop-creditcard-segment__form-error" v-show="creditCardError !== ''">{{creditCardError}}</div>
</div>
</div>
<div class="credit-card__save-method">
<input type="checkbox" id="save-stripe-payment-method" v-model="stripeSaveSource">
<label for="save-stripe-payment-method">
<span><b>Save payment method</b></span>
</label>
</div>
<button @click="submitStripeCardForm" :disabled="!stripe || loadingCreditCard" :class="{ 'loading': loadingCreditCard }" class="credit-card__submit-button ui button">
<span v-if="loadingCreditCard"></span>
<span v-else="">Continue</span>
</button>
</div>
</div>

<div class="modal__body modal__body--credit-card-success" v-if="state === 'credit-card-success'">
<div class="modal-body__header">
<h1>SUCCESS</h1>
<div class="header__button header__close-button" @click="closeModal"><img src="/public/media/instacoach/icons/close.png" alt=""></div>
</div>
<div class="credit-card-success__content">
<h1>Transaction Successful</h1>
<img src="/public/media/instacoach/icons/accept-circular-button-outline.png">
<div class="credit-card-success__row">
<p>Payment Type</p>
<p>{{paymentType}}</p>
</div>
<div class="credit-card-success__row">
<p>Amount Paid</p>
<p>${{getSelectedPointsOption.price}}</p>
</div>
<p>Thank you for purchasing <strong>{{getSelectedPointsOption.points}}</strong> points.</p>
</div>
<div class="credit-card-success__actions">
<button class="modal-body__link-button" @click="returnToCoach">Return to Coach Profile</button>
</div>
</div>

<div class="modal__body modal__body--cancel-session" v-if="shouldShowCancelSessionModal">
<div class="modal-body__header">
<h1>END SESSION</h1>
<div class="header__button header__close-button" @click="cancelEndSession"><img src="/public/media/instacoach/icons/close.png" alt=""></div>
</div>
<div class="cancel-session__content">
<h1>Are you sure you want to end this session?</h1>
<p>If a game ends in under 5 minutes for any reason, it is okay to play another within the same session.</p>
</div>
<div class="cancel-session__actions">
<button class="modal-body__cancel-button" @click="confirmCancelSession">Yes</button>
</div>
</div>

<div class="modal__body modal__body--rate-session" v-if="state === 'rate-session'">
<div class="modal-body__header">
<h1>INSTACOACH SESSION ENDED</h1>
<div class="header__button header__close-button" @click="closeModal"><img src="/public/media/instacoach/icons/close.png" alt=""></div>
</div>
<div class="rate-session__contents">
<p>How did it go with {{_.get(currentRequest, 'coach.name')}}?</p>
<div class="rate-session__star-rating">
<div class="star-rating__button" v-for="i in 5" :key="'session-rating-'+i" @click="sessionRating = i">
<img v-if="i <= sessionRating" src="/public/media/instacoach/icons/star.svg" alt="">
<img v-else="" src="/public/media/instacoach/icons/star_empty.svg" alt="">
</div>
</div>
<p>What did {{_.get(currentRequest, 'coach.name')}} do well?</p>
<div class="rate-session__button-rating">
<div v-for="(option, index) in ratingOptions" :class="{'rating-button': true, 'rating-button--selected': index === selectedRatingOptionIndex}" @click="selectRatingOption(index)" :key="'rating-option-'+ index">
{{option.name}}
</div>
</div>
<label for="text-rating" class="rate-session__text-rating--label">Leave a comment</label>
<textarea id="text-rating" name="rating" rows="4" class="rate-session__text-rating" v-model="sessionRatingText"></textarea>
<button class="modal-body__link-button" @click="state = 'report-session'">Report an issue.</button>
<button class="rate-session__submit-button" @click="submitSessionRating">Submit</button>
</div>
</div>

<div class="modal__body modal__body--rate-session-success" v-if="state === 'rate-session-success'">
<div class="modal-body__header">
<h1>SUCCESS</h1>
<div class="header__button header__close-button" @click="closeModal"><img src="/public/media/instacoach/icons/close.png" alt=""></div>
</div>
<div class="rate-session-success__content">
<h1>Review Submitted</h1>
<p>Thanks for your feedback!</p>
<img src="/public/media/instacoach/icons/accept-circular-button-outline.png">
</div>
<div class="rate-session-success__actions">
<button class="modal-body__link-button" @click="returnToCoach">Return to Coach Profile</button>
</div>
</div>

<div class="modal__body modal__body--report-session" v-if="state === 'report-session'">
<div class="modal-body__header">
<div class="header__button header__back-button" @click="backModal('rate-session')"><img src="/public/media/instacoach/icons/back.png" alt=""></div>
<h1>REPORT AN ISSUE</h1>
<div class="header__button header__close-button" @click="closeModal"><img src="/public/media/instacoach/icons/close.png" alt=""></div>
</div>
<div class="report-session__contents">

<label for="description" class="report-session__description--label">Describe the issue</label>
<textarea id="description" name="rating" rows="4" class="report-session__description" v-model="sessionRatingText"></textarea>
<p>We will review and resolve each case carefully. If you have specific questions or concerns, please email us at <a href="mailto:support@proguides.com" target="_blank">support@proguides.com</a>.</p>
<button class="report-session__submit-button" @click="submitSessionReport">Submit</button>
<button class="modal-body__link-button" @click="state = 'rate-session'">Cancel and return</button>
</div>
</div>

<div class="modal__body modal__body--report-session-success" v-if="state === 'report-session-success'">
<div class="modal-body__header">
<h1>SUCCESS</h1>
<div class="header__button header__close-button" @click="closeModal"><img src="/public/media/instacoach/icons/close.png" alt=""></div>
</div>
 <div class="report-session-success__content">
<h1>Report submitted</h1>
<p>Thanks for your feedback, we will investigate this issue carefully.</p>
<img src="/public/media/instacoach/icons/accept-circular-button-outline.png">
</div>
<div class="report-session-success__actions">
<button class="modal-body__link-button" @click="returnToSessionRating">Return to Session Rating</button>
</div>
</div>
</div>
</div>


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js">/* Development */</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js"></script>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash-compat/3.10.2/lodash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/node-uuid/1.4.8/uuid.min.js"></script>
<script src="https://js.stripe.com/v3/"></script>

<script src="https://www.proguides.com/public/js/module/instapro/fetch_games.js?v=2.3.1o"></script>
<script>
// Config
const INSTAPRO_API_URL = 'https://instapro.proguides.com/'
const CHAT_WEBSOCKET_URI = 'wss://chat.proguides.com/ws/'
// widget starts hidden to avoid FOUC, display it once its ready to load
let shouldShowInstacoach = true
shouldShowInstacoach *= !window.location.pathname.includes('/store/subscriptions')
shouldShowInstacoach *= !window.location.pathname.includes('/store/points')
shouldShowInstacoach *= !window.location.pathname.includes('/settings/subscriptions')
shouldShowInstacoach *= window.location.pathname !== '/'

// check to see if user is on a course page
let path = window.location.pathname.split('/')
shouldShowInstacoach *= !(path.length >= 5 && path[1] === 'courses')

if (shouldShowInstacoach) {
    $('#instacoach-widget').css('display', 'block')
}

let phpActiveGame = ''
let phpCurrentPoints = Number('0')
let phpIsUserPro = Boolean('')
let phpRequestSoundFile = 'https://www.proguides.com/public/media/sounds/Modified success sound.wav'
let phpMessageSoundFile = 'https://www.proguides.com/public/media/sounds/instapro-message.wav'
let phpUsername = "";
let phpEmail = "";
let phpSelfPgId = "";
let phpSelfAvatar = 'https://www.proguides.com/public/media/apellation-pg-logo.png'

var instaCoachWidget = new Vue({
    el: '#instacoach-widget',
    data: {
        gameOptions: {},
        offlineCoachData: {
            'leagueoflegends': {
                showShowMore: true,
                currentPage: 1
            },
            'fortnite': {
                showShowMore: true,
                currentPage: 1
            },
            'csgo': {
                showShowMore: true,
                currentPage: 1
            },
            'super-smash-bros-ultimate': {
                showShowMore: true,
                currentPage: 1
            },
            'overwatch': {
                showShowMore: true,
                currentPage: 1
            },
            'teamfight-tactics': {
                showShowMore: true,
                currentPage: 1
            },
            'hearthstone': {
                showShowMore: true,
                currentPage: 1
            }
        },
        selfPgId: phpSelfPgId,
        selfAvatar: phpSelfAvatar,
        selfUsername: phpUsername,
        isUserPro: phpIsUserPro,
        startingActiveGame: phpActiveGame,
        currentPoints: phpCurrentPoints,
        showCoachChatButton: !phpIsUserPro,
        requestSoundFile: phpRequestSoundFile,
        messageSoundFile: phpMessageSoundFile,
        InstaproGamesData: InstaproGamesData,
        showProLockedModal: false,
        hideInstapro: !shouldShowInstacoach,
        drawerOpen: false,
        drawerDisabled: false,
        drawerHighlighted: false,
        message: 'Instacoach',
        selectedCoachKey: null,
        state: null,
        onboardingAnimationState: 0,
        onboardingAnimationSpeed: 1200,
        onboardingAnimationTimeoutFunction: null,
        userSeenOnboarding: true,
        gameSelectDropdownOpen: false,
        timer: 0,
        countdownTimeout: null,
        pointsOptions: [
        ],
        selectedPointsOptionIndex: null,
        pointsSelectError: '',
        paymentType: 'Credit Card',
        creditCardAssets: {
            'American Express': '/public/media/store/cards/22.png',
            'Diners Club': '/public/media/store/cards/10.png',
            'Discover': '/public/media/store/cards/14.png',
            'JCB': '/public/media/store/cards/16.png',
            'MasterCard': '/public/media/store/cards/2.png',
            'Visa': '/public/media/store/cards/1.png',
        },
        isoCountries: {
            'AF': 'Afghanistan',
            'AX': 'Aland Islands',
            'AL': 'Albania',
            'DZ': 'Algeria',
            'AS': 'American Samoa',
            'AD': 'Andorra',
            'AO': 'Angola',
            'AI': 'Anguilla',
            'AQ': 'Antarctica',
            'AG': 'Antigua And Barbuda',
            'AR': 'Argentina',
            'AM': 'Armenia',
            'AW': 'Aruba',
            'AU': 'Australia',
            'AT': 'Austria',
            'AZ': 'Azerbaijan',
            'BS': 'Bahamas',
            'BH': 'Bahrain',
            'BD': 'Bangladesh',
            'BB': 'Barbados',
            'BY': 'Belarus',
            'BE': 'Belgium',
            'BZ': 'Belize',
            'BJ': 'Benin',
            'BM': 'Bermuda',
            'BT': 'Bhutan',
            'BO': 'Bolivia',
            'BA': 'Bosnia And Herzegovina',
            'BW': 'Botswana',
            'BV': 'Bouvet Island',
            'BR': 'Brazil',
            'IO': 'British Indian Ocean Territory',
            'BN': 'Brunei Darussalam',
            'BG': 'Bulgaria',
            'BF': 'Burkina Faso',
            'BI': 'Burundi',
            'KH': 'Cambodia',
            'CM': 'Cameroon',
            'CA': 'Canada',
            'CV': 'Cape Verde',
            'KY': 'Cayman Islands',
            'CF': 'Central African Republic',
            'TD': 'Chad',
            'CL': 'Chile',
            'CN': 'China',
            'CX': 'Christmas Island',
            'CC': 'Cocos (Keeling) Islands',
            'CO': 'Colombia',
            'KM': 'Comoros',
            'CG': 'Congo',
            'CD': 'Congo, Democratic Republic',
            'CK': 'Cook Islands',
            'CR': 'Costa Rica',
            'CI': 'Cote D\'Ivoire',
            'HR': 'Croatia',
            'CU': 'Cuba',
            'CY': 'Cyprus',
            'CZ': 'Czech Republic',
            'DK': 'Denmark',
            'DJ': 'Djibouti',
            'DM': 'Dominica',
            'DO': 'Dominican Republic',
            'EC': 'Ecuador',
            'EG': 'Egypt',
            'SV': 'El Salvador',
            'GQ': 'Equatorial Guinea',
            'ER': 'Eritrea',
            'EE': 'Estonia',
            'ET': 'Ethiopia',
            'FK': 'Falkland Islands (Malvinas)',
            'FO': 'Faroe Islands',
            'FJ': 'Fiji',
            'FI': 'Finland',
            'FR': 'France',
            'GF': 'French Guiana',
            'PF': 'French Polynesia',
            'TF': 'French Southern Territories',
            'GA': 'Gabon',
            'GM': 'Gambia',
            'GE': 'Georgia',
            'DE': 'Germany',
            'GH': 'Ghana',
            'GI': 'Gibraltar',
            'GR': 'Greece',
            'GL': 'Greenland',
            'GD': 'Grenada',
            'GP': 'Guadeloupe',
            'GU': 'Guam',
            'GT': 'Guatemala',
            'GG': 'Guernsey',
            'GN': 'Guinea',
            'GW': 'Guinea-Bissau',
            'GY': 'Guyana',
            'HT': 'Haiti',
            'HM': 'Heard Island & Mcdonald Islands',
            'VA': 'Holy See (Vatican City State)',
            'HN': 'Honduras',
            'HK': 'Hong Kong',
            'HU': 'Hungary',
            'IS': 'Iceland',
            'IN': 'India',
            'ID': 'Indonesia',
            'IR': 'Iran, Islamic Republic Of',
            'IQ': 'Iraq',
            'IE': 'Ireland',
            'IM': 'Isle Of Man',
            'IL': 'Israel',
            'IT': 'Italy',
            'JM': 'Jamaica',
            'JP': 'Japan',
            'JE': 'Jersey',
            'JO': 'Jordan',
            'KZ': 'Kazakhstan',
            'KE': 'Kenya',
            'KI': 'Kiribati',
            'KR': 'Korea',
            'KW': 'Kuwait',
            'KG': 'Kyrgyzstan',
            'LA': 'Lao People\'s Democratic Republic',
            'LV': 'Latvia',
            'LB': 'Lebanon',
            'LS': 'Lesotho',
            'LR': 'Liberia',
            'LY': 'Libyan Arab Jamahiriya',
            'LI': 'Liechtenstein',
            'LT': 'Lithuania',
            'LU': 'Luxembourg',
            'MO': 'Macao',
            'MK': 'Macedonia',
            'MG': 'Madagascar',
            'MW': 'Malawi',
            'MY': 'Malaysia',
            'MV': 'Maldives',
            'ML': 'Mali',
            'MT': 'Malta',
            'MH': 'Marshall Islands',
            'MQ': 'Martinique',
            'MR': 'Mauritania',
            'MU': 'Mauritius',
            'YT': 'Mayotte',
            'MX': 'Mexico',
            'FM': 'Micronesia, Federated States Of',
            'MD': 'Moldova',
            'MC': 'Monaco',
            'MN': 'Mongolia',
            'ME': 'Montenegro',
            'MS': 'Montserrat',
            'MA': 'Morocco',
            'MZ': 'Mozambique',
            'MM': 'Myanmar',
            'NA': 'Namibia',
            'NR': 'Nauru',
            'NP': 'Nepal',
            'NL': 'Netherlands',
            'AN': 'Netherlands Antilles',
            'NC': 'New Caledonia',
            'NZ': 'New Zealand',
            'NI': 'Nicaragua',
            'NE': 'Niger',
            'NG': 'Nigeria',
            'NU': 'Niue',
            'NF': 'Norfolk Island',
            'MP': 'Northern Mariana Islands',
            'NO': 'Norway',
            'OM': 'Oman',
            'PK': 'Pakistan',
            'PW': 'Palau',
            'PS': 'Palestinian Territory, Occupied',
            'PA': 'Panama',
            'PG': 'Papua New Guinea',
            'PY': 'Paraguay',
            'PE': 'Peru',
            'PH': 'Philippines',
            'PN': 'Pitcairn',
            'PL': 'Poland',
            'PT': 'Portugal',
            'PR': 'Puerto Rico',
            'QA': 'Qatar',
            'RE': 'Reunion',
            'RO': 'Romania',
            'RU': 'Russian Federation',
            'RW': 'Rwanda',
            'BL': 'Saint Barthelemy',
            'SH': 'Saint Helena',
            'KN': 'Saint Kitts And Nevis',
            'LC': 'Saint Lucia',
            'MF': 'Saint Martin',
            'PM': 'Saint Pierre And Miquelon',
            'VC': 'Saint Vincent And Grenadines',
            'WS': 'Samoa',
            'SM': 'San Marino',
            'ST': 'Sao Tome And Principe',
            'SA': 'Saudi Arabia',
            'SN': 'Senegal',
            'RS': 'Serbia',
            'SC': 'Seychelles',
            'SL': 'Sierra Leone',
            'SG': 'Singapore',
            'SK': 'Slovakia',
            'SI': 'Slovenia',
            'SB': 'Solomon Islands',
            'SO': 'Somalia',
            'ZA': 'South Africa',
            'GS': 'South Georgia And Sandwich Isl.',
            'ES': 'Spain',
            'LK': 'Sri Lanka',
            'SD': 'Sudan',
            'SR': 'Suriname',
            'SJ': 'Svalbard And Jan Mayen',
            'SZ': 'Swaziland',
            'SE': 'Sweden',
            'CH': 'Switzerland',
            'SY': 'Syrian Arab Republic',
            'TW': 'Taiwan',
            'TJ': 'Tajikistan',
            'TZ': 'Tanzania',
            'TH': 'Thailand',
            'TL': 'Timor-Leste',
            'TG': 'Togo',
            'TK': 'Tokelau',
            'TO': 'Tonga',
            'TT': 'Trinidad And Tobago',
            'TN': 'Tunisia',
            'TR': 'Turkey',
            'TM': 'Turkmenistan',
            'TC': 'Turks And Caicos Islands',
            'TV': 'Tuvalu',
            'UG': 'Uganda',
            'UA': 'Ukraine',
            'AE': 'United Arab Emirates',
            'GB': 'United Kingdom',
            'US': 'United States',
            'UM': 'United States Outlying Islands',
            'UY': 'Uruguay',
            'UZ': 'Uzbekistan',
            'VU': 'Vanuatu',
            'VE': 'Venezuela',
            'VN': 'Viet Nam',
            'VG': 'Virgin Islands, British',
            'VI': 'Virgin Islands, U.S.',
            'WF': 'Wallis And Futuna',
            'EH': 'Western Sahara',
            'YE': 'Yemen',
            'ZM': 'Zambia',
            'ZW': 'Zimbabwe'
        },
        stripe: null,
        stripeConfig: {
            elementsStyle: {
                base: {
                    color: "#3B3B3B",
                    fontWeight: 500,
                    fontFamily: "'Muli', 'Open Sans', Helvetica, Arial, sans-serif",
                    fontSize: "16px",
                    fontSmoothing: "antialiased",
                },
                invalid: {
                    color: "#E25950",
                }
            }
        },
        stripeCardholderName: '',
        stripeCardCountry: 'US',
        stripeCardPostalCode: '',
        stripeCreditCardElements: {
            cardNumber: null,
            cvv: null,
            expirationDate: null
        },
        stripeSaveSource: false,
        selectedStripeSource: null,
        savedStripeSources: [],
        creditCardPaymentCardholderName: '',
        creditCardPaymentCardNumber: '',
        creditCardPaymentCVV: '',
        creditCardPaymentExpirationDate: '',
        creditCardError: '',
        loadingCreditCard: false,
        ratingOptions: [
            { name: 'Knowledgable', value: 'knowledgable' },
            { name: 'Patient Teacher', value: 'patient-teacher' },
            { name: 'Positive Attitude', value: 'positive-attitude' },
            { name: 'Easy to Talk to', value: 'easy-to-talk-to' },
        ],
        currentRequest: {
            coach: null,
            games: 1,
            game: null,
            id: null,
            created: null
        },
        selectedRatingOptionIndex: null,
        sessionRatingText: '',
        sessionRating: 0,
        sessionReportEmail: '',
        sessionReportDescription: '',
        requestProgressTimer: 0,
        requestProgressIncrement: 10,
        requestProgressTimeoutFunction: null,
        requestProgressMaxTime: 30,
        requestProgressEnded: false,
        coachUnavailable: false,
        coachRejected: false,
        previousState: null,
        cancellingRequest: false,
        requestCancelled: false,
        sessionConfirmationInGameUsername: '',
        sessionConfirmationDiscord: '',
        sessionConfirmationSkype: '',
        sessionConfirmationCommunicationMethod: 'discord',
        sessionConfirmationError: null,
        sessionConfirmationCoachBusy: false,
        sessionConfirmationSaveContactInfo: true,
        savedContactInfo: {},
        cancellingSession: false,
        inSessionWarning: false,
        currentSessionTabOpen: false,
        currentSessionTimeElapsed: 0,
        currentSessionTimerTimeoutFunction: null,
        confirmSessionSavePersonalInfo: true,
        selectedGame: 'leagueoflegends',
        formattedCoaches: [],
        fetchCoachesTimeoutFunction: null,
        fetchCoachesTimeoutDuration: 15000,
        fetchCoachesTimeoutDurationSlow: 30000,
        fetchRequestStatusTimeoutFunction: null,
        fetchRequestStatusTimeoutDuration: 2500,
        coachWatcherTimeoutFunctions: {},
        coachWatcherTimeoutDuration: 10000,
        pgUserId: null,
        instaProAccessToken: null,
        coachDict: {},
        coachReviews: {},
        onlineCoachLimit: 10,
        inSessionCoachLimit: 10,
        currentTime: moment.utc(),
        watchCurrentSessionTimeoutFunction: null,
        watchCurrentSessionTimeoutDuration: 2500,
        redirectCoachId: null,
        coachUnavailableMessage: '',
        paypalLoading: false,
        requestSound: null,
        userIsCoach: false,
        previousOnboardingState: null,
        coachSelectionGamesAmount: 1,
        coachSelectionSessionType: null,
        coachSelectionSessionTypeGroup: 'session',
        coachProfileBioClamped: true,
        coachProfileShowReadMoreButton: false,
        activeSessionDropdownOpen: true,
        onlineCoachesDropdownOpen: true,
        inSessionCoachesDropdownOpen: true,
        offlineCoachesDropdownOpen: false,
        favoriteCoachesDropdownOpen: true,
        favoritesList: [],
        favoritingCoach: false,
        initialNumOnlineCoachesVisible: 6,
        showCoachesOnlineIncrement: 5,
        // numOnlineCoachesVisible: 6,
        // changed to 1000 to temporarily disable 'show more'
        numOnlineCoachesVisible: 1000,
        coachPollingTimeoutFunction: null,
        filtersOpen: false,
        selectedFilterRegions: {},
        selectedFilterLanguages: {},
        selectedFilterRanks: {},
        filterRegionDropdownOpen: false,
        filterLanguageDropdownOpen: false,
        filterRankDropdownOpen: false,
        selectedFilterSpecialties: {},
        selectedFilterPrices: {},
        instaPROGames: {},
        searchQueryValue: null,
        doneInitialCoachSort: false,
        coachAddedPosition: 0,
        instaproNotifications: [],
        checkNotificationsTimeoutFunction: null,
        favoriteCoachPollingTimeoutFunction: null,
        userInSession: false,
        messagesOpen: false,
        conversations: {
        },
        conversationMessages: {
        },
        currentChats: {
        },
        chatUsers: {
        },
        searchMessagesQueryValue: '',
        chatInputMaxHeight: 115,
        currentUser: '10',
        wsUri: CHAT_WEBSOCKET_URI,
        websocket: null,
        testUserId: 513241,
        doneFetchingConversations: false,
        isFocusingModal: false,
        chatSocketPingTimeout: 20000,
        chatMessageResendLimit: 5,
        chatMessageResendTimeout: 4000,
        testAccessToken: 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczpcL1wvd3d3LnByb2d1aWRlcy5jb21cLyIsImF1ZCI6Imh0dHBzOlwvXC93d3cucHJvZ3VpZGVzLmNvbVwvIiwiaWF0IjoxNTY4MjI3NzcwLCJuYmYiOjE1NjgyMjc3NzAsImV4cCI6MTU2ODIzODU3MCwidWlkIjo1MTU5NzR9.E3bBLBMptQRYgN0RF9eoxTgjYlrVdjxYTI3WsNCN4og',
        testRefreshToken: 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczpcL1wvd3d3LnByb2d1aWRlcy5jb21cLyIsImF1ZCI6Imh0dHBzOlwvXC93d3cucHJvZ3VpZGVzLmNvbVwvIiwiaWF0IjoxNTY3MjA1NjYxLCJuYmYiOjE1NjcyMDU2NjEsImV4cCI6MTU3MTA5MzY2MSwiZGV2aWNlX2lkIjoiNWU4ZDQ0OWE0YWFjMTg3MzdlNjIzY2Y4ZGU5YWU0YmI2MmRhOGUwNGM2ZmQ5ZDVmMTRlN2JkZjRhODc3NDUzYmUxNTU4MTc3NDYzMzljM2U2ZGY1ODNhNTE2ZDkyYzZmYWM0NWU0ZmNmNzE2ZDE5OTJkYjRkMjM5YTk1ODhkYjVhNTM5OWM4ZmNmM2VmMTBjYTViOGI5MjAzZWU2MDFjNjU5NzQ2NGFhMmI3NWQwMDEzZWRkMTgyYjk1NmMzMDk4Yjg2NjYyZjVhN2Y3ZjE0ZmIzN2JlNjVhY2QxZDg0MTU0MjJjNjYyNTM3NTJlZmIxNzkzNDU2YzUzZjc4NmJlNWJkZmNiZWNhMjY5N2FkM2M3ODRhZmVkNGYyZDM0Mjg0ZGI3NTZkNTc1ZGQ3OWI4ZDJiYjUxYjk3OGQyNDllOTIifQ.4_somC08BKfIeuKQPgB8awMqjoa4_FPdtlEYcoyu8lU',
        authenticationAttemptLimit: 5,
        authenticateChatSocketTimeout: 4000,
        defaultInstaproPhoto: 'https://d17galhwha3ary.cloudfront.net/assets/instapro/instapro-default-avatar.png',
        coachWaitingProgressStart: false,
        failedAuthentication: false,
        totalUnreadMessages: 0,
        dontMinimizeSessionTab: false,
        pgAccessToken: null,
        contactInfoRegionDropdownOpen: false,
        contactInfoPlatformDropdownOpen: false,
        selectedContactInfoRegion: null,
        selectedContactInfoPlatform: null,
    },
    mounted () {
        if (!this.hideInstapro) {
            this.initializeZopim()
            this.initJSEventBus()
            this.checkPaypalRedirect()
            this.initializeAudio()
            this.setActiveGame()
            this.init().then(() => {
                this.getCurrentTime()
            }).catch((error) => {
                console.log('Unable to load InstaPRO: ', error)
            })
            this.autoOpenDrawer()
            this.registerModalListener()
        }
    },
    watch: {
        getNumCoachesOnline: function (numCoaches) {
            let onlineCoachCountEvent = new CustomEvent('onlineCoachCountEvent', { detail: { onlineCoachCount: numCoaches } })
            document.dispatchEvent(onlineCoachCountEvent)
        },
        coachSelectionSessionTypeGroup: function (sessionTypeGroup) {
            // TODO: Keep track of list of session types to be able to select first and get rid of the type by arbitrary number value
            switch (sessionTypeGroup) {
                case 'session':
                    if (this.oneVsOneAvailable) {
                        this.coachSelectionSessionType = 3
                    } else if (this.inGameAvailable) {
                        this.coachSelectionSessionType = 0
                    } else if (this.spectateAvailable) {
                        this.coachSelectionSessionType = 1
                    } else if (this.replayAvailable) {
                        this.coachSelectionSessionType = 2
                    }
                    break;
                case 'passes':
                    if (this.allDayPassAvailable) {
                        this.coachSelectionSessionType = 4
                    }
                    break;
            }
        },
        totalUnreadMessages: function (newVal, oldVal) {
            this.updateSidenavUnread(newVal)
        },
        userInSession: function (newVal, oldVal) {
            if (newVal === true) {
                this.watchCurrentSession()
            }
            let minimized = this.checkForMobile()
            if (this.dontMinimizeSessionTab) {
                minimized = false
            }
            this.updateChatTabSessionState(minimized)
        },
        currentChats: function (newVal, oldVal) {
            this.$nextTick(() => {
                this.checkChatTabScreenPosition()
            })
        },
        coachUnavailable: function (newVal, oldVal) {
            if (newVal === true) {
                clearTimeout(this.requestProgressTimeoutFunction)
                this.requestProgressEnded = true
            } else {
                this.requestProgressEnded = false
            }
        },
        state: function (newVal, oldVal) {
            this.previousState = oldVal
            if (newVal === 'selecting') {
                this.$nextTick(() => {
                    this.checkCoachBioLength()
                })
            }
            if (newVal === 'waiting') {
                // this.requestProgressTimer = 0
                // this.requestProgressEnded = false
                // this.countdownRequestProgressTimer()
                this.$nextTick(() => {
                    this.coachWaitingProgressStart = true
                })
            } else {
                this.coachWaitingProgressStart = false
            }
            if (newVal === 'in-session') {
                this.currentSessionTabOpen = true
                this.getCurrentTime()
                this.watchCurrentSession()
            }
            if (newVal === null) {
                this.resetState()
            }
            if (newVal === 'onboarding-1') {
                this.startOnboardingAnimation()
            }
            // SET UP STRIPE STUFF HERE
            if (newVal === 'purchasing--credit-card-select') {
                this.setupStripe()
            }
            if (newVal === 'purchasing--credit-card') {
                this.$nextTick(() => {
                    this.setupStripe()

                    // Mount Stripe Elements here because of re-rendering
                    this.stripeCreditCardElements.cardNumber.mount('#stripe-card-number')
                    this.stripeCreditCardElements.cvv.mount('#stripe-card-cvv')
                    this.stripeCreditCardElements.expirationDate.mount('#stripe-card-expiry')
                })
            }
            if (newVal !== null) {
                this.$nextTick(() => {
                    this.isFocusingModal = true
                    this.toggleModalFocus(true)
                })
            }
        },
        drawerOpen: function (newVal, oldVal) {
            $('body').toggleClass('instapro__modal-open', newVal)
            this.gameSelectDropdownOpen = false
        },
        messagesOpen: function (newVal, oldVal) {
            $('body').toggleClass('instapro__modal-open', newVal)
        }
    },
    methods: {
        selectContactInfoRegion (region) {
            this.selectedContactInfoRegion = region
            this.contactInfoRegionDropdownOpen = false
        },
        selectContactInfoPlatform (platform) {
            this.selectedContactInfoPlatform = platform
            this.contactInfoPlatformDropdownOpen = false
        },
        openContactInfoRegionDropdown () {
            this.contactInfoRegionDropdownOpen = !this.contactInfoRegionDropdownOpen
        },
        openContactInfoPlatformDropdown () {
            this.contactInfoPlatformDropdownOpen = !this.contactInfoPlatformDropdownOpen
        },
        fetchGameOptions () {
            return Promise.all([
                this.fetchAllPages(INSTAPRO_API_URL + 'api/v1/games', {'status': 'online'}, [], this.instaProAccessToken)
            ]).then((responses) => {
                let gamesList = []
                responses.forEach((response) => {
                    gamesList.push(...response)
                })
                this.gameOptions = gamesList.reduce((result, obj) => {
                    result[obj.name] = obj
                    return result
                }, {})
            })
        },
        closeAllOpenMessages () {
            let didCloseMessages = false
            this.getCurrentChats.forEach((obj) => {
                if (this.currentChats[obj.id]) {
                    Vue.set(this.currentChats[obj.id], 'visible', false)
                    Vue.set(this.currentChats[obj.id], 'minimized', true)
                    didCloseMessages = true
                }
            })
            return didCloseMessages
        },
        checkForMobile () {
            return window.innerWidth <= 768
        },
        chatBookSessionReloadPoints (chat) {
            this.selectedCoachKey = _.get(chat, 'coachId', null)
            this.state = 'reload-points'
        },
        chatBookSessionNotEnoughPoints (chat) {
            let cost = this.getChatBookSessionCoachSessionTypeCost(chat, chat.selectedCoachingType)
            return cost > this.currentPoints
        },
        updateSidenavUnread (unread) {
            $('#instapro-unread-messages-container').toggleClass('messages__unread-count--hidden', unread <= 0)
            document.getElementById('instapro-unread-messages').innerHTML = String(unread)
        },
        checkTotalUnread () {
            let message = {
                command: 'get_unread_count'
            }
            this.doChatSocketSend(message)
        },
        padChatMessageTop (chat) {
            return _.get(chat, 'actionState') !== 'default'
        },
        restartAuthentication () {
            this.failedAuthentication = false
            this.doneFetchingConversations = false
            this.initChat()
        },
        convertDuration (seconds) {
            let padNum = (num) => {
                return ('0' + num).slice(-2)
            }
            var minutes = Math.floor(seconds / 60)
            seconds = seconds % 60
            var hours = Math.floor(minutes / 60)
            minutes = minutes % 60
            return padNum(hours) + ':' + padNum(minutes) + ':' + padNum(seconds)
        },
        mapSessionType (type) {
            let typeMap = {
                'in-game': 'Play with Pro',
                'spectate': 'Spectated Game',
                'replay': 'Replay Analysis'
            }

            return typeMap[type]
        },
        registerChatTabScrollListener (conversationId) {
            let scrollElement = _.first(this.$refs['message-tab-scrolling-' + conversationId])
            Vue.set(this.currentChats[conversationId], 'lastScrollPosition', _.get(scrollElement, 'scrollTop'))
            scrollElement.addEventListener('scroll', (event) => {
                if (this.currentChats[conversationId]) {
                    let scrollPos = _.get(event, 'target.scrollTop')
                    if (scrollPos) {
                        let lastScrollPos = _.get(this.currentChats, conversationId + '.lastScrollPosition')
                        // if scrolling up
                        if (lastScrollPos && lastScrollPos > scrollPos) {
                            let nearTop = this.isChatNearTop(conversationId)
                            if (nearTop) {
                                this.getOlderMessages(conversationId)
                            }
                        }
                        Vue.set(this.currentChats[conversationId], 'lastScrollPosition', scrollPos)
                    }
                }
            })
        },
        isChatNearTop (chatId) {
            let scrollingSection = _.first(this.$refs['message-tab-scrolling-' + chatId])
            let scrollTop = _.get(scrollingSection, 'scrollTop')
            if (scrollTop < 150) {
                return true
            }
        },
        isChatNearBottom (chatId) {
            let scrollingSection = _.first(this.$refs['message-tab-scrolling-' + chatId])
            let scrollTop = _.get(scrollingSection, 'scrollTop')
            let clientHeight = _.get(scrollingSection, 'clientHeight')
            let scrollHeight = _.get(scrollingSection, 'scrollHeight')

            let scrollPos = scrollTop + clientHeight
            let scrollDifference = scrollHeight - scrollPos
            if (scrollDifference < 70) {
                return true
            }
        },
        handleFetchMessageScrollPosition (conversationId) {
            let scrollingSection = _.first(this.$refs['message-tab-scrolling-' + conversationId])
            let scrollTop = _.get(scrollingSection, 'scrollTop')
            // only need to fix scroll pos if its at very top
            if (scrollTop === 0) {
                let correctPosition = _.get(this.currentChats, conversationId + '.oldestMessageEl.offsetTop')
                scrollingSection.scrollTo({
                    top: correctPosition,
                    left: 0
                })
            }
        },
        getOlderMessages (conversationId) {
            if (!_.get(this.currentChats, conversationId + '.isFetchingMessages', false) && !_.get(this.currentChats, conversationId + '.fetchedAllMessages', false)) {
                let oldestMessage = _.first(this.conversationMessages[conversationId])
                let oldestMessageTime = _.get(oldestMessage, 'time', moment()).format()
                let oldestMessageId = _.get(oldestMessage,'id')
                let oldestMessageEl = _.first(this.$refs['message-tab-' + conversationId + '__message-' + oldestMessageId])
                Vue.set(this.currentChats[conversationId], 'oldestMessageEl', oldestMessageEl)

                let message = {
                    command: 'get_messages',
                    request_id: conversationId,
                    payload: {
                        conversation_id: conversationId,
                        before: oldestMessageTime || ''
                    }
                }
                this.doChatSocketSend(message)
                Vue.set(this.currentChats[conversationId], 'isFetchingMessages', true)
            }
        },
        showUnreadMessagesButton (chatId) {
            return !this.isChatNearBottom(chatId) && _.get(this.conversations, chatId + '.unread')
        },
        interactWithChat (chatId) {
            let lastReadMessage = _.last(_.get(this.conversationMessages, chatId))

            // if last message was receieved after conversation was last read
            if (_.get(lastReadMessage, 'time') > _.get(this.conversations, chatId + '.readAt')) {
                let lastReadMessageId = _.get(lastReadMessage, 'id')
                this.updateLastReadMessage(chatId, lastReadMessageId)
            }
        },
        getCommunicationThumbnail (communicationMethod) {
            let thumbnailMap = {
                'discord': '/public/media/instacoach/icons/discord-icon.png',
                'skype': '/public/media/instacoach/icons/skype-icon.png'
            }
            return thumbnailMap[communicationMethod]
        },
        isMessageDividerBlue (message) {
            return message.type === 'SESSION_START' || message.type === 'SESSION_END'
        },
        showMessageDivider (message) {
            return message.isNewLine || message.divider || message.newMessagesDivider || message.type === 'SESSION_START' || message.type === 'SESSION_END'
        },
        chatEndSession (chat) {
            this.confirmCancelSession()
        },
        openCurrentSessionChat () {
            this.updateChatTabSessionState()
        },
        addSessionStartMessage (conversation) {
            let requestGame = _.get(this.currentRequest, 'game')
            let coachInGameUsername = _.get(this.currentRequest, 'coach.games.' + requestGame + '.username')
            let coach = _.get(this.currentRequest, 'coach.games.' + requestGame + '.username')
            let sessionCommunicationMethod = _.get(this.currentRequest, 'communicationMethod')
            let coachCommunicationUsername = _.get(this.currentRequest, 'coach.' + sessionCommunicationMethod)
            let startSessionMessage = {
                game: requestGame,
                coachInGameUsername: coachInGameUsername,
                sessionCommunicationMethod: sessionCommunicationMethod,
                coachCommunicationUsername: coachCommunicationUsername,
                time: moment().add(2, 'second'),
                conversationId: _.get(conversation, 'id'),
                type: 'COACH_CONNECT'
            }

            this.addMessages(_.get(conversation, 'id'), [startSessionMessage])
        },
        updateChatTabSessionState (minimized) {
            if (this.currentRequest) {
                if (this.userInSession) {
                    let coachPgId = _.get(this.currentRequest, 'coach.pgId')
                    let coachConversation = Object.values(this.conversations).find((obj) => {
                        return obj.pgId == coachPgId
                    })
                    if (coachConversation) {
                        this.openChatTab(coachConversation, minimized)
                        Vue.set(this.currentChats[coachConversation.id], 'actionState', 'in-session')
                        this.addSessionStartMessage(coachConversation)
                    } else {
                        this.startOrFetchConversation(coachPgId).then((response) => {
                            let conversation = _.get(response, 'data')
                            if (conversation) {
                                this.addConversations([conversation])
                                let mappedConversation = _.get(this.conversations, conversation.id)
                                this.openChatTab(mappedConversation, minimized)
                                Vue.set(this.currentChats[mappedConversation.id], 'actionState', 'in-session')
                                this.addSessionStartMessage(mappedConversation)
                            }
                        }).catch((error) => {
                            console.log('Error fetching current session coach conversation', error)
                        })
                    }
                } else {
                    let coachPgId = _.get(this.currentRequest, 'coach.pgId')
                    let coachConversation = Object.values(this.conversations).find((obj) => {
                        return obj.pgId == coachPgId
                    })
                    if (coachConversation) {
                        this.openChatTab(coachConversation, minimized)
                        Vue.set(this.currentChats[coachConversation.id], 'actionState', 'default')
                    }
                }
            }
        },
        chatCancelEndSession (chat) {
            Vue.set(this.currentChats[chat.id], 'actionState', 'in-session')
        },
        chatConfirmEndSession (chat) {
            Vue.set(this.currentChats[chat.id], 'actionState', 'confirm-end-session')
        },
        isChatInSession (chat) {
            if (this.userInSession) {
                if (_.get(this.currentRequest, 'coach.pgId') === chat.pgId) {
                    return true
                }
            }
        },
        getNumCoachesOnlineForGame (game) {
            return this.getAllOnlineCoaches.filter(obj => {
                if (obj.games) {
                    return Object.keys(obj.games).includes(game)
                }
                return obj.game === game
            }).length
        },
        isCoachOnline (coachId) {
            return _.get(this.coachDict, coachId + '.status') === 'online'
        },
        mapSelectedCoachingType (type) {
            let typeMap = {
                'in-game': 0,
                'spectate': 1,
                'replay': 2,
                '1v1': 3,
                'all-day-pass': 4
            }
            return typeMap[type]
        },
        chatBookSessionSubmit (chat) {
            let selectedGame = _.get(chat, 'selectedGame', null)
            if (selectedGame) {
                this.selectedGame = selectedGame
            }
            this.coachSelectionSessionType = this.mapSelectedCoachingType(_.get(chat, 'selectedCoachingType', null))
            this.selectedCoachKey = _.get(chat, 'coachId', null)
            Vue.set(this.currentChats[chat.id], 'actionState', 'default')
            this.requestCoach()
        },
        closeChatSelectSessionOptions (chat) {
            Vue.set(this.currentChats[chat.id], 'actionState', 'default')
        },
        getConversationUnreadMessages (conversationId) {
            let convo = _.get(this.conversations, conversationId)
            let messages = _.get(this.conversationMessages, conversationId)
            if (convo && messages) {
                let numUnread = 0
                // loop through messages starting from most recent
                // if conversation.readAt < message.time : increment numUnread
                return 2
            }
        },
        handleNewMessageRendering (message) {
            let id = _.get(message, 'conversationId')
            // only handle rendering if chat is open
            if (_.get(this.currentChats, id + '.visible')) {
                let isNearBottom = this.isChatNearBottom(id)
                if (isNearBottom) {
                    this.$nextTick(() => {
                        this.scrollToChatBottom(id)
                    })
                }
            }
        },
        updateUnreadMessages (chatId) {
            if (this.conversations[chatId]) {
                let unread = _.get(this.conversations, chatId + '.unread')
                Vue.set(this.conversations[chatId], 'unread', unread + 1)
                this.totalUnreadMessages += 1
            }
        },
        isChatFocused (chatId) {
            return _.first(this.$refs['message-tab-input-' + chatId]) === document.activeElement
        },
        scrollToChatBottom (chatId) {
            let scrollingSection = _.first(this.$refs['message-tab-scrolling-' + chatId])
            if (_.get(scrollingSection, 'scrollHeight')) {
                scrollingSection.scrollTop = scrollingSection.scrollHeight
            }
        },
        isChatInputDisabled (chat) {
            return !(_.get(chat, 'valid', false))
        },
        getMessageStatus (message) {
            return _.get(message, 'messageStatus')
        },
        refreshChatSocket () {
            setTimeout(() => {
                let message = {
                    command: 'ping'
                }
                this.doChatSocketSend(message)
                // if Websocket is closed, re-open it, otherwise refresh it
                if (this.websocket.readyState === WebSocket.CLOSED) {
                    this.initChat()
                } else {
                    this.refreshChatSocket()
                }
            }, this.chatSocketPingTimeout)
        },
        isChatMessageValid (chatId, message) {
            let messageLength = _.get(message, 'length', -1)
            if (message === '' || message === null || message === undefined || messageLength <= 0) {
                return false
            }
            if (messageLength > 1000) {
                return false
            }

            return true
        },
        sendChatMessage (chatId, body) {
            let messageToken = uuid()
            let message = {
                command: 'send_message',
                payload: {
                    conversation_id: chatId,
                    body: body,
                    token: messageToken
                }
            }
            this.doChatSocketSend(message)

            let messageList = _.get(this.conversationMessages, chatId, [])
            let previousMessageTime = _.get(_.last(messageList), 'time')
            let previousMessageUser = _.get(_.last(messageList), 'user')

            let divider = this.getMessageDivider(moment(), previousMessageTime)
            let dividerContent = this.getMessageDateDividerContent(moment(), previousMessageTime)
            let isNewLine = this.isMessageNewLine(moment(), previousMessageTime, this.getSelfPgId, previousMessageUser)
            let user = this.getChatUsers[this.getSelfPgId]
            let username = _.get(user, 'name')
            let avatar = _.get(user, 'avatar')
            let time = moment()
            let formattedTime = time.format('h:mm A')

            let localMessage = {
                id: null,
                messageToken: messageToken,
                conversationId: chatId,
                text: body,
                time: time,
                type: 'MESSAGE',
                user: this.getSelfPgId,
                messageStatus: 'pending',
                divider: divider,
                dividerContent: dividerContent,
                isNewLine: isNewLine,
                username: username,
                avatar: avatar,
                formattedTime: formattedTime
            }
            let tempMessages = _.get(this.conversationMessages, chatId, [])
            tempMessages.push(localMessage)
            Vue.set(this.conversationMessages, chatId, tempMessages)

            // update last read of conversation (locally)
            Vue.set(this.conversations[chatId], 'readAt', moment())
            Vue.set(this.conversations[chatId], 'lastReceivedAt', moment())

            this.$nextTick(() => {
                this.scrollToChatBottom(chatId)
            })

            setTimeout(() => {
                this.tryResendChatMessage(message, 1)
            }, this.chatMessageResendTimeout)

            if (typeof amplitude !== "undefined") {
                amplitude.getInstance().logEvent("Sends Message")
            } else {
                console.log('no amplitude')
            }
        },
        tryResendChatMessage (message, iteration) {
            let messageList = _.get(this.conversationMessages, _.get(message, 'payload.conversation_id'), [])
            let localMessageIndex = messageList.indexOf(messageList.find((obj) => {
                return obj.messageToken === _.get(message, 'payload.token')
            }))
            let status = _.get(messageList, '[' + localMessageIndex + '].messageStatus')
            if (iteration <= this.chatMessageResendLimit) {
                if (status === 'pending') {
                    this.doChatSocketSend(message)
                    setTimeout(() => {
                        this.tryResendChatMessage(message, iteration + 1)
                    }, this.chatMessageResendTimeout)
                }
            } else {
                if (localMessageIndex >= 0) {
                    messageList[localMessageIndex].messageStatus = 'failed'
                }
            }
        },
        toggleModalFocus (doFocus) {
            $('.instacoach-widget__modal').toggleClass('focused', doFocus)
        },
        startOrFetchConversation (coachPgId) {
            let body = new FormData()
            body.append('type', 'direct')
            body.append('reference', coachPgId)
            return axios({
                method: 'post',
                url: '/api/v2/messages/find-conversation',
                headers: {
                    'Authorization': 'Bearer ' + this.getUserToken
                },
                data: body
            }).then((response) => {
                return response
            }).catch((error) => {
                return Promise.reject(error)
            })
        },
        openCoachMessage (coach) {
            let coachConversation = Object.values(this.conversations).find((obj) => {
                return obj.pgId === coach.pgId
            })
            if (!coachConversation) {
                if (typeof amplitude !== "undefined") {
                    amplitude.getInstance().logEvent("Initiate Message", {
                        game: this.selectedGame
                    })
                } else {
                    console.log('no amplitude')
                }
                this.startOrFetchConversation(coach.pgId).then((response) => {
                    let conversation = _.get(response, 'data')
                    if (conversation) {
                        this.addConversations([conversation])
                        let mappedConversation = _.get(this.conversations, conversation.id)
                        this.openChatTab(mappedConversation)
                        if (this.checkForMobile()) {
                            this.state = null
                        }
                    }
                }).then((response) => {
                }).catch((error) => {
                    if (_.get(error, 'response.status') === 403 || _.get(error, 'response.status') === 401) {
                        this.openProLockedModal()
                    }
                })
            } else {
                this.openChatTab(coachConversation)
            }
        },
        registerModalListener () {
            $('#instacoach-widget').on('click', (e) => {
                if (!this.isFocusingModal) {
                    let doFocus = $(e.target).parents('.modal__body').length > 0 || $(e.target).parents('.modal__pro-locked').length > 0
                    this.toggleModalFocus(doFocus)
                } else {
                    this.isFocusingModal = false
                }
            })
        },
        isChatBookSessionPlayNowDisabled (chat) {
            let stateDisabled = ['confirming', 'confirming-info', 'waiting'].includes(this.state)
            return !(this.getChatBookSessionSelectedSessionType(chat) || false)
        },
        getChatBookSessionCurrentGame (chat) {
            if (chat.selectedGame) {
                return chat.selectedGame
            } else {
                let coachGames = _.get(this.coachDict, chat.coachId + '.games', {})
                // if coach only has one game, return that
                let gameKeys = Object.keys(coachGames)
                if (gameKeys.length === 1) {
                    return _.first(gameKeys)
                } else {
                    let game = this.selectedGame
                    if (gameKeys.includes(game)) {
                        return game
                    } else {
                        return _.first(gameKeys)
                    }
                }
            }
        },
        isChatBookSessionMethodAvailable (chat, type) {
            let coach = _.get(this.coachDict, chat.coachId)
            let currentGame = this.getChatBookSessionCurrentGame(chat)
            let prices = _.get(coach, 'games.' + currentGame + '.price', {})
            if (prices[type]) {
                return true
            }
        },
        getChatBookSessionCoachSessionTypeCost (chat, type) {
            let coachObj = _.get(this.coachDict, _.get(chat, 'coachId'))
            if (coachObj) {
                let gameKey = _.get(chat, 'selectedGame', this.selectedGame)
                let game = _.get(coachObj, 'games.' + gameKey + '.price')
                let cost = _.get(game, type, null)
                return cost
            }
        },
        getChatBookSessionSelectedSessionType (chat) {
            let selectedType = _.get(chat, 'selectedCoachingType', null)
            if (this.isChatBookSessionMethodAvailable(chat, selectedType)) {
                return selectedType
            } else {
                return null
            }
        },
        chatBookSessionSelectSessionType (chat, type) {
            Vue.set(this.currentChats[chat.id], 'selectedCoachingType', type)
        },
        async initChat () {
            this.websocket = new WebSocket(this.wsUri)
            this.websocket.onopen = (evt) => { this.onChatSocketOpen(evt) }
            this.websocket.onclose = (evt) => { this.onChatSocketClose(evt) }
            this.websocket.onmessage = (evt) => { this.onChatSocketMessage(evt) }
            this.websocket.onerror = (evt) => { this.onChatSocketError(evt) }

            this.addSelfToChatUsers()
        },
        addSelfToChatUsers () {
            let self = {
                name: this.getSelfUsername,
                avatar: this.getSelfAvatar,
                pgId: this.getSelfPgId,
                id: null
            }
            Vue.set(this.chatUsers, this.getSelfPgId, self)
        },
        fetchChatConversations () {
            this.doneFetchingConversations = false

            // set a timeout to show that fetching conversations is done,
            // in case there is no response from the websocket
            setTimeout(() => {
                this.doneFetchingConversations = true
            }, 3500)
            let message = {
                command: "get_conversations",
                request_id: 'init_conv',
                payload: {
                }
            }
            this.doChatSocketSend(message)
        },
        authenticateChatSocket (attempt) {
            let message = {
                command: 'authenticate',
                payload: this.getUserToken,
                request_id: attempt || 0
            }
            this.doChatSocketSend(message)
        },
        retryAuthenticateChatSocket (attempt) {
            setTimeout(() => {
                if (attempt < this.authenticationAttemptLimit) {
                    if (attempt > (this.authenticationAttemptLimit / 2)) {
                        this.refreshUserToken().then((response) => {
                            let newPgToken = _.get(response, 'data.access_token')
                            let newRefreshToken = _.get(response, 'data.refresh_token')
                            if (newPgToken) {
                                this.pgAccessToken = newPgToken
                                window.localStorage.setItem('client_credentials', newPgToken)
                            }
                            if (newRefreshToken) {
                                window.localStorage.setItem('refresh_token', newRefreshToken)
                            }
                            this.authenticateChatSocket(attempt + 1)
                        }).catch((error) => {
                            console.log(error)
                            this.authenticateChatSocket(attempt + 1)
                        })
                    } else {
                        this.authenticateChatSocket(attempt + 1)
                    }
                } else {
                    this.failedAuthentication = true
                }
            }, this.authenticateChatSocketTimeout)
        },
        onChatSocketOpen (evt) {
            this.authenticateChatSocket(0)
        },
        onChatSocketClose (evt) {
            this.restartAuthentication()
        },
        refreshUserToken () {
            let refreshToken = window.localStorage.getItem('refresh_token')

            let url = '/api/v2/tokens/'

            let body = new FormData()
            body.append('grant_type', 'refresh_token')
            body.append('refresh_token', refreshToken)

            return axios({
                method: 'post',
                url: url,
                data: body
            }).then((response) => {
                // set local storage with user tokens
                if (response.data) {
                    if (response.data.access_token) {
                        window.localStorage.setItem('client_credentials', response.data.access_token)
                    }
                    if (response.data.refresh_token) {
                        window.localStorage.setItem('refresh_token', response.data.refresh_token)
                    }
                }
                return response
            }).catch((error) => {
                return Promise.reject(error)
            })
        },
        fetchConversationById (conversationId) {
            let message = {
                command: 'get_conversation',
                payload: {
                    conversation_id: conversationId
                }
            }
            this.doChatSocketSend(message)
        },
        onChatSocketMessage (evt) {
            let response = JSON.parse(evt.data)
            let command = _.get(response, 'command', null)
            let success = _.get(response, 'success')
            switch (command) {
                case 'authenticate':
                    // fetch conversations
                    if (success) {
                        this.refreshChatSocket()
                        this.fetchChatConversations()
                        this.checkTotalUnread()
                    } else {
                        let currentAuthAttempt = parseInt(_.get(response, 'request_id'))
                        this.retryAuthenticateChatSocket(currentAuthAttempt)
                    }
                    break;
                case 'get_conversation':
                    if (success) {
                        this.addConversations([_.get(response, 'payload')])
                        this.doneFetchingConversations = true
                    }
                    break;
                case 'get_conversations':
                    this.addConversations(_.get(response, 'payload.data'))
                    this.doneFetchingConversations = true
                    break;
                case 'get_messages':
                    let messageList = _.get(response, 'payload', [])
                    let conversationId = _.get(_.first(messageList), 'conversation_id')
                    let fetchedAllMessages = messageList.length === 0
                    // if no messages in the list to get conversationId from, get it from request_id sent with request
                    if (messageList.length === 0) {
                        conversationId = _.get(response, 'request_id')
                    }
                    let mappedMessages = this.mapMessages(conversationId, _.get(response, 'payload', []))
                    this.addMessages(conversationId, mappedMessages)
                    this.handleUnreadMessagesDivider(conversationId)

                    // Set that no messages are being fetched currently for this conversation
                    // And set the scroll position of the chat to the position of the oldest message they viewed before fetching
                    this.$nextTick(() => {
                        if (this.currentChats[conversationId]) {
                            if (_.get(this.currentChats, conversationId + '.isFetchingMessages')) {
                                this.handleFetchMessageScrollPosition(conversationId)
                            }
                            Vue.set(this.currentChats[conversationId], 'isFetchingMessages', false)
                            // record the new "last scroll position" for next time the user scrolls, so it can accurately
                            // determine if the user has srolled up or down
                            let scrollElement = _.first(this.$refs['message-tab-scrolling-' + conversationId])
                            Vue.set(this.currentChats[conversationId], 'lastScrollPosition', _.get(scrollElement, 'scrollTop'))

                            // If there are no more messages left, set that accordingly on the chat
                            if (fetchedAllMessages) {
                                Vue.set(this.currentChats[conversationId], 'fetchedAllMessages', true)
                            }
                        }
                    })

                    // if chat window is already open, update last read on that window
                    let conversationMessages = _.get(this.conversationMessages, conversationId)
                    let chatOpen = _.get(this.currentChats, conversationId + '.visible')
                    if (conversationMessages && chatOpen) {
                        let lastReadMessageId = _.get(_.last(conversationMessages), 'id')
                        this.updateLastReadMessage(conversationId, lastReadMessageId)
                    }
                    break;
                case 'send_message':
                    if (success) {
                        this.updateLocalMessageId(_.get(response, 'payload'))
                    }
                    break;
                case 'new_message':
                    this.addOrUpdateMessage(_.get(response, 'payload'))
                    break;
                case 'get_unread_count':
                    if (success) {
                        let unread = _.get(response, 'payload', 0)
                        this.totalUnreadMessages = unread
                    }
                    break;
                case 'ping':
                    break;
                default:
            }
        },
        updateLocalMessageId (payload) {
            let conversationId = _.get(payload, 'conversation_id')
            let messageList = _.get(this.conversationMessages, conversationId, [])
            let localMessageIndex = messageList.indexOf(messageList.find((obj) => {
                return obj.messageToken === _.get(payload, 'token')
            }))
            if (localMessageIndex !== -1) {
                messageList[localMessageIndex].id = _.get(payload, 'message_id')
                messageList[localMessageIndex].messageStatus = 'received'
                Vue.set(this.conversationMessages, conversationId, messageList)
            }
        },
        addOrUpdateMessage (message) {
            let conversationId = _.get(message, 'conversation_id')
            let messageList = _.get(this.conversationMessages, conversationId, null)

            // if messageList doesn't exist, we don't need to add this new message to local data yet.
            // we will be getting this new message later (if needed) when fetching all messages
            if (messageList) {
                let localMessageIndex = messageList.indexOf(messageList.find((obj) => {
                    return (obj.id === _.get(message, 'id') || obj.messageToken === _.get(message, 'token'))
                }))
                if (localMessageIndex !== -1) {
                    messageList[localMessageIndex].id = _.get(message, 'id')
                    messageList[localMessageIndex].messageStatus = 'received'
                    Vue.set(this.conversationMessages, conversationId, messageList)
                } else {
                    let lastMessage = _.last(messageList)
                    let previousMessageTime = _.get(lastMessage, 'time')
                    let previousMessageUser = _.get(lastMessage, 'user')
                    let mappedMessage = this.mapSingleMessage(message, previousMessageTime, previousMessageUser, conversationId)
                    this.addMessages(conversationId, [mappedMessage])
                    if (!this.isChatFocused(conversationId)) {
                        this.handleUnreadMessagesDivider(conversationId)
                    }
                    // Check is window is focused, to see if message should be marked as read
                    if (this.isChatFocused(conversationId) && _.get(message, 'id')) {
                        this.updateLastReadMessage(conversationId, _.get(message, 'id'), moment.utc(_.get(message, 'created_at')))
                    } else {
                        this.messageSound.play()
                        this.updateUnreadMessages(conversationId)
                    }
                }

                // Update lastMessage of conversation (only if its a text message)
                if (_.get(message, 'type') === 'MESSAGE' && _.get(this.conversations, conversationId)) {
                    Vue.set(this.conversations[conversationId], 'lastMessage', message)
                }
            } else {
                let mappedMessage = this.mapSingleMessage(message, null, null, conversationId)
                Vue.set(this.conversationMessages, conversationId, [mappedMessage])
                this.fetchConversationById(conversationId)
            }

            if (_.get(this.conversations, conversationId)) {
                let receivedAt = _.get(message, 'created_at')
                if (receivedAt) {
                    Vue.set(this.conversations[conversationId], 'lastReceivedAt', moment.utc(receivedAt))
                }
            }
        },
        addMessages (conversationId, mappedMessageList) {
            if (conversationId) {
                if (_.get(this.conversationMessages, conversationId, []).length > 0) {
                    let newMessages = this.conversationMessages[conversationId]
                    newMessages.push(...mappedMessageList)
                    newMessages = this.sortAndFilterUniqueMessages(newMessages)
                    Vue.set(this.conversationMessages, conversationId, newMessages)
                    let newestMessage = _.last(newMessages)
                    this.handleNewMessageRendering(newestMessage)
                } else {
                    let sortedMessages = this.sortAndFilterUniqueMessages(mappedMessageList)
                    Vue.set(this.conversationMessages, conversationId, sortedMessages)
                    this.$nextTick(() => {
                        this.scrollToChatBottom(conversationId)
                    })
                }
            }
        },
        mapMessages (conversationId, messageList) {
            let mappedMessageList = []
            for (let i = 0; i < messageList.length; i++) {
                let message = messageList[i]

                let previousMessageTime
                let previousMessageUser
                if (i > 0) {
                    previousMessageTime = moment(_.get(messageList[i - 1], 'created_at'))
                    previousMessageUser = _.get(messageList[i - 1], 'user_id')
                }
                let mappedMessage = this.mapSingleMessage(message, previousMessageTime, previousMessageUser, conversationId)
                mappedMessageList.push(mappedMessage)
            }
            return mappedMessageList
        },
        mapSingleMessage (message, previousMessageTime, previousMessageUser, conversationId) {
            let time = moment(message.created_at)
            let divider = this.getMessageDivider(time, previousMessageTime)
            let dividerContent = this.getMessageDateDividerContent(time, previousMessageTime)

            let currentUserId = _.get(message, 'user_id')
            let isNewLine = this.isMessageNewLine(time, previousMessageTime, currentUserId, previousMessageUser)
            let user = this.getChatUsers[_.get(message, 'user_id')]
            let username = _.get(user, 'name')
            let avatar = _.get(user, 'avatar')
            let formattedTime = time.format('h:mm A')

            let text = message.body
            if (message.type === 'SESSION_SUMMARY') {
                try {
                    text = JSON.parse(message.body)
                } catch (e) {
                }
            }

            let mappedMessage = {
                user: message.user_id,
                time: time,
                text: text,
                type: message.type,
                id: message.id,
                conversationId, conversationId,
                messageStatus: 'received',
                divider: divider,
                dividerContent: dividerContent,
                newMessagesDivider: false,
                isNewLine: isNewLine,
                username: username,
                avatar: avatar,
                formattedTime: formattedTime
            }
            return mappedMessage
        },
        handleUnreadMessagesDivider (conversationId) {
            let conversationMessages = _.get(this.conversationMessages, conversationId, [])
            let conversation = _.get(this.conversations, conversationId)
            if (conversationMessages.length === 0 || !conversation) {
                return
            }
            let lastReadTimestamp = conversation.readAt.unix()
            let addedNewMessageDivider = false
            for (let i = (conversationMessages.length - 1); i >= 0; i--) {
                let currentMessage = conversationMessages[i]
                // only add new message divider if its an actual text message

                if (lastReadTimestamp >= currentMessage.time.unix() && !addedNewMessageDivider) {
                    // if not on the first element, add in new messages divider to next message
                    if (i < (conversationMessages.length - 1)) {
                        // only add divider if its a text message
                        let nextMessage = _.get(this.conversationMessages, conversationId + '[' + (i + 1) + ']')
                        if (_.get(nextMessage, 'type') === 'MESSAGE') {
                            Vue.set(this.conversationMessages[conversationId][i + 1], 'newMessagesDivider', true)
                        }
                        addedNewMessageDivider = true
                    } else {
                        // first message is the last read message, so remove all new message dividers
                        addedNewMessageDivider = true
                    }
                } else if (i < (conversationMessages.length - 1)) {
                    // Take off new messages divider from all other messages
                    Vue.set(this.conversationMessages[conversationId][i + 1], 'newMessagesDivider', false)
                }
            }
        },
        fetchConversationCoach (coachPgId) {
            return axios({
                method: 'get',
                url: INSTAPRO_API_URL + 'api/v1/coach/by-pg-id/' + coachPgId,
                headers: {
                    'Authorization': 'Bearer ' + this.instaProAccessToken
                }
            }).then((response) => {
                return response
            }).catch((error) => {
                return Promise.reject(error)
            })
        },
        addConversations (conversations) {
            conversations.forEach((conversation) => {
                // socket message ; This will be added into the conversation object once the response is recieved
                this.getConversationMessages(conversation, null)

                let users = _.get(conversation, 'users', [])
                let coachObj = users.find((obj) => {
                    return obj.index != this.getSelfPgId
                })
                let userObj = users.find((obj) => {
                    return obj.index == this.getSelfPgId
                })
                let userMap = {}
                if (userObj) {
                    userMap[userObj.index] = userObj
                }
                if (coachObj) {
                    userMap[coachObj.index] = coachObj
                }
                let coachPgId = _.get(coachObj, 'index')
                let coach = this.coaches.find((obj) => {
                    return obj.pgId == coachPgId
                })


                if (!coach) {
                    coach = {
                        id: null,
                        pgId: coachPgId,
                        name: _.get(coachObj, 'display.name'),
                        avatar: _.get(coachObj, 'display.thumbnail')
                    }

                    // Fetch coach from InstaPro and update local data acordingly
                    this.fetchConversationCoach(coachPgId).then((response) => {
                        let coach = _.get(response, 'data.result')
                        // update chat data
                        if (this.conversations[conversation.id]) {
                            Vue.set(this.conversations[conversation.id], 'coachId', _.get(coach, 'id'))
                            Vue.set(this.conversations[conversation.id], 'name', _.get(coach, 'nickname'))
                            Vue.set(this.conversations[conversation.id], 'avatar', _.get(coach, 'additional.photo', this.defaultInstaproPhoto))
                        }
                        if (this.currentChats[conversation.id]) {
                            Vue.set(this.currentChats[conversation.id], 'coachId', _.get(coach, 'id'))
                            Vue.set(this.currentChats[conversation.id], 'name', _.get(coach, 'nickname'))
                            Vue.set(this.currentChats[conversation.id], 'avatar', _.get(coach, 'additional.photo', this.defaultInstaproPhoto))
                        }

                        // update coach in instapro data
                        this.updateCoaches([coach])
                    }).catch((error) => {
                        console.log('error fetching coach for conversation', error)
                    })
                }
                let mappedConversation = this.mapConversation(conversation, coach)
                Vue.set(this.conversations, mappedConversation.id, mappedConversation)

                // Update this user in chatUsers
                Vue.set(this.chatUsers, _.get(coach, 'pgId'), coach)

                // check if any messages exist already and set their username/avatar
                let conversationId = _.get(conversation, 'id')
                let currentMessages = _.get(this.conversationMessages, conversationId, [])

                for (let i = 0; i < currentMessages.length; i++) {
                    let message = _.get(this.conversationMessages, conversationId + '[' + i + ']')
                    if (message) {
                        // SET USERNAME AND AVATAR OF CORRECT USER NOT OF JUST COACH
                        let userId = _.get(message, 'user')
                        let messageUser = _.get(userMap, userId)
                        if (message.type === 'MESSAGE') {
                            let username = _.get(messageUser, 'display.name')
                            if (username) {
                                Vue.set(this.conversationMessages[conversationId][i], 'username', username)
                            }
                            let avatar = _.get(messageUser, 'display.thumbnail')
                            if (avatar) {
                                Vue.set(this.conversationMessages[conversationId][i], 'avatar', avatar)
                            }
                        }
                    }
                }
            })
        },
        mapConversation (conversation, coach) {
            let lastMessageReceivedAt = _.get(conversation, 'last_message.created_at')
            if (lastMessageReceivedAt) {
                lastMessageReceivedAt = moment.utc(lastMessageReceivedAt)
            }
            return {
                id: conversation.id,
                lastMessage: _.get(conversation, 'last_message'),
                readAt: moment.utc(conversation.last_read_at),
                unread: _.get(conversation, 'unread_count'),
                lastUnreadId: _.get(conversation, 'last_message_id'),
                lastReceivedAt: lastMessageReceivedAt,
                coachId: _.get(coach, 'id'),
                pgId: _.get(coach, 'pgId'),
                name: _.get(coach, 'name'),
                avatar: _.get(coach, 'avatar')
            }
        },
        getConversationMessages (conversation, before) {
            let message = {
                command: 'get_messages',
                request_id: _.get(conversation, 'id'),
                payload: {
                    conversation_id: _.get(conversation, 'id'),
                    before: before || ''
                }
            }
            this.doChatSocketSend(message)
        },
        onChatSocketError (evt) {
        },
        doChatSocketSend (messageObject) {
            this.websocket.send(JSON.stringify(messageObject));
        },
        chatTabStartSession (chat) {
            this.currentChats[chat.id].actionState = 'select-session-type'
        },
        getComputedChatState (chat) {
            if (chat.coachId === null) {
                return 'not-coach'
            } else if (chat.actionState === null) {
                return 'default'
            } else if (chat.actionState === 'select-session-type') {
                return 'select-session-type'
            }
        },
        getMessageDivider (messageTime, previousMessageTime) {
            if (this.getMessageDateDividerContent(messageTime, previousMessageTime)) {
                return 'date'
            }
        },
        shouldShowChatCloseButton (chat) {
            return true
        },
        isMessageNewLine (messageTime, previousMessageTime, user, previousUser) {
            if (!previousMessageTime || user != previousUser) {
                return true
            }

            let oneMinute = 60 * 1 * 1000

            if (messageTime && previousMessageTime && messageTime - previousMessageTime < oneMinute) {
                return false
            } else {
                return true
            }
        },
        getMessageDateDividerContent (messageTime, previousMessageTime) {
            let isNewDay = false
            if (!previousMessageTime) {
                isNewDay = true
            } else {
                if (messageTime.date() !== previousMessageTime.date()) {
                    isNewDay = true
                }
            }

            // It is a new day and should be shown
            if (isNewDay) {
                // Message was from a different year
                if (messageTime.year() !== moment().year()) {
                    return messageTime.format('M/D/YY')
                }
                // Message was from more than 7 days ago
                else if (moment().dayOfYear() - messageTime.dayOfYear() >= 7) {
                    return messageTime.format('MMM D')
                }
                // Message was from more than 2 days ago
                else if (moment().dayOfYear() - messageTime.dayOfYear() >= 2) {
                    return messageTime.format('dddd')
                }
                // Message was from yesterday
                else if (moment().dayOfYear() - messageTime.dayOfYear() === 1) {
                    return 'Yesterday'
                }
                // Message was from yesterday
                else if (moment().dayOfYear() === messageTime.dayOfYear()) {
                    return 'Today'
                }
            }

            return false
        },
        getMessageUser (message) {
            return this.getChatUsers[message.user]
        },
        getMessageAvatar (message) {
            return _.get(this.getMessageUser(message), 'avatar', 'https://d17galhwha3ary.cloudfront.net/assets/instapro/instapro-default-avatar.png')
        },
        getMessageUsername (message) {
            return _.get(this.getMessageUser(message), 'name', 'unknown')
        },
        getMessageTime (message) {
            let time = _.get(message, 'time', null)
            return time ? time.format('h:mm A') : ''
        },
        closeChat (chatId) {
            // if (_.get(this.currentChats, chatId + '.actionState') === 'in-session') {
            //     // minimize, dont close
            // } else {
            // }
            Vue.set(this.currentChats[chatId], 'minimized', true)
            Vue.set(this.currentChats[chatId], 'visible', false)
        },
        getLastMessage (conversation) {
            let conversationId = _.get(conversation, 'id')
            let lastMessage = _.get(conversation, 'lastMessage.body')
            let username
            if (_.get(conversation, 'lastMessage.user_id') == this.getSelfPgId) {
                username = 'You'
            } else {
                username = _.get(this.coachDict, _.get(conversation, 'coachId') + '.name', null)
            }
            if (lastMessage) {
                return username ? username + ': ' + lastMessage : lastMessage
            } else {
                return ' '
            }
        },
        sortAndFilterUniqueMessages (messages) {
            let seen = new Set()
            return messages.filter((message) => {
                let duplicate = seen.has(message.id)
                seen.add(message.id)
                return !duplicate
            }).sort((a, b) => {
                if (a.time > b.time) {
                    return 1
                } else if (a.time < b.time) {
                    return -1
                } else {
                    return 0
                }
            })
        },
        submitChat (chatId) {
            let inputRefKey = 'message-tab-input-' + chatId
            let textArea = _.first(this.$refs[inputRefKey])
            if (textArea) {
                // Send Message
                if (!this.isChatMessageValid(chatId, textArea.value)) {
                    return
                }
                this.sendChatMessage(chatId, textArea.value)
                textArea.value = ''
                Vue.set(this.currentChats[chatId], 'input', '')
                Vue.set(this.currentChats[chatId], 'valid', false)
                Vue.set(this.currentChats[chatId], 'errorMessage', '')
                let computedStyle = window.getComputedStyle(textArea)
                if (computedStyle) {
                    let paddingTop = computedStyle.getPropertyValue('padding-top')
                    paddingTop = parseInt(paddingTop.substring(0, paddingTop.length - 2))
                    let paddingBottom = computedStyle.getPropertyValue('padding-bottom')
                    paddingBottom = parseInt(paddingBottom.substring(0, paddingBottom.length - 2))
                    let lineHeight = computedStyle.getPropertyValue('line-height')
                    lineHeight = parseInt(lineHeight.substring(0, lineHeight.length - 2))
                    let minHeight = (paddingTop + paddingBottom + lineHeight * 2) + 'px'
                    textArea.style.transition = 'all 0.25s'
                    textArea.style.height = minHeight
                }
            }
        },
        handleChatInputEvent (chatId, event) {
            if (event.keyCode && event.keyCode === 13 && !event.shiftKey && !this.checkForMobile()) {
                event.preventDefault()
                this.submitChat(chatId)
                return
            }
            let textValue = _.get(this.currentChats, chatId + '.input')
            this.textAreaResize(chatId)
            this.validateChatInput(chatId)
        },
        validateChatInput (chatId) {
            let textValue = _.get(_.first(this.$refs['message-tab-input-' + chatId]), 'value', '')
            if (textValue === '') {
                Vue.set(this.currentChats[chatId], 'valid', false)
                Vue.set(this.currentChats[chatId], 'errorMessage', '')
            } else if (textValue.length >= 1000) {
                Vue.set(this.currentChats[chatId], 'valid', false)
                Vue.set(this.currentChats[chatId], 'errorMessage', 'Your message must be less than 1000 characters.')
            } else {
                Vue.set(this.currentChats[chatId], 'valid', true)
                Vue.set(this.currentChats[chatId], 'errorMessage', '')
            }
        },
        textAreaResize (chatId) {
            let textArea = _.first(this.$refs['message-tab-input-' + chatId])
            if (textArea) {
                let scrollHeight = textArea.scrollHeight
                if (textArea.clientHeight < scrollHeight) {
                    if (scrollHeight < this.chatInputMaxHeight) {
                        textArea.style.transition = 'none'
                        textArea.style.height = (scrollHeight + 1) + 'px'
                    }
                }
            }
        },
        getOnlineStatus (coachId) {
            let coach = _.get(this.coachDict, coachId)
            let statusMap = {
                'online': '/public/media/instacoach/icons/online-border.svg',
                'offline': '/public/media/instacoach/icons/offline-border.svg',
                'busy': '/public/media/instacoach/icons/busy-border.svg',
                'in-session': '/public/media/instacoach/icons/busy-border.svg',
            }
            return statusMap[_.get(coach, 'status')]
        },
        getOnlineStatusNoOutline (coachId) {
            let coach = _.get(this.coachDict, coachId)
            let statusMap = {
                'online': '/public/media/instacoach/icons/online.svg',
                'offline': '/public/media/instacoach/icons/offline.svg',
                'busy': '/public/media/instacoach/icons/busy.svg',
                'in-session': '/public/media/instacoach/icons/busy.svg',
            }
            return statusMap[_.get(coach, 'status')]
        },
        minimizeMessageTab (chat) {
            if (this.currentChats[chat.id].minimized) {
                this.openMessageTab(chat.id)
            } else {
                Vue.set(this.currentChats[chat.id], 'minimized', true)
            }
        },
        openMessageTab (id) {
            // check if open chat would go off screen
            this.$nextTick(() => {
                Vue.set(this.currentChats[id], 'minimized', false)
                let input = _.first(this.$refs['message-tab-input-' + id])
                if (input && !this.checkForMobile()) {
                    input.focus()
                }
                this.scrollToChatBottom(id)
                this.$nextTick(() => {
                    this.checkChatTabScreenPosition()
                })
            })
        },
        openMessages () {
            this.messagesOpen = true
        },
        openCloseMessages () {
            this.messagesOpen = !this.messagesOpen
        },
        openChatTab (conversation, minimized) {
            let id = _.get(conversation, 'id')
            // if its not already open, open it
            if (!this.currentChats[id]) {
                // check if user is coach in local data
                // modify chat data accordingly based on coach
                let tempChat = {
                    ...conversation,
                    valid: false,
                    minimized: true,
                    visible: true,
                    input: '',
                    selectedGame: this.getChatDefaultSelectedGame(conversation),
                    selectedCoachingType: null,
                    gameSelectDropdownOpen: false,
                    added: moment(),
                    actionState: 'default'
                }
                Vue.set(this.currentChats, id, tempChat)

                if (typeof amplitude !== "undefined") {
                    amplitude.getInstance().logEvent("Enter Chat")
                } else {
                    console.log('no amplitude')
                }
            } else if (_.get(this.currentChats[id], 'visible') === false) {
                Vue.set(this.currentChats[id], 'added', moment())
                Vue.set(this.currentChats[id], 'visible', true)
            }
            let conversationMessages = _.get(this.conversationMessages, id)
            if (conversationMessages) {
                // Check where "new_messages" divider should go
                this.handleUnreadMessagesDivider(id)
                // Mark messages as read
                let lastReadMessageId = _.get(_.last(conversationMessages), 'id')
                this.updateLastReadMessage(id, lastReadMessageId)
            }
            this.$nextTick(() => {
                this.isFocusingModal = true
                this.toggleModalFocus(false)
                if (!minimized) {
                    this.openMessageTab(id)
                }
                this.registerChatTabScrollListener(id)
            })
        },
        updateLastReadMessage (conversationId, messageId, readAt) {
            let message = {
                command: "update_last_read_message",
                payload: {
                    conversation_id: conversationId,
                    message_id: messageId
                }
            }
            if (![undefined, null].includes(messageId)) {
                this.doChatSocketSend(message)
            }

            if (this.conversations[conversationId]) {
                let currentUnread = _.get(this.conversations, conversationId + '.unread', 0)
                this.totalUnreadMessages -= currentUnread
                Vue.set(this.conversations[conversationId], 'unread', 0)
                Vue.set(this.conversations[conversationId], 'lastUnreadId', null)
                Vue.set(this.conversations[conversationId], 'readAt', readAt || moment())
            }
        },
        getChatDefaultSelectedGame (conversation) {
            let coachObj = _.get(this.coachDict, _.get(conversation, 'coachId'))
            if (coachObj) {
                let coachGames = Object.keys(_.get(coachObj, 'games'))
                if (coachGames.includes(this.selectedGame)) {
                    return this.selectedGame
                } else {
                    return _.first(coachGames)
                }
            }
        },
        chatBookSessionSelectGameOption (chat, gameKey) {
            let currentGame = _.get(this.currentChats, _.get(chat, 'id') + '.selectedGame', -1)
            if (currentGame !== -1) {
                Vue.set(this.currentChats[_.get(chat, 'id')], 'selectedGame', gameKey)
            }
            this.closeChatBookSessionGameSelectDropdown(chat)
        },
        openChatBookSessionGameSelectDropdown (chat) {
            if (!this.doShowChatBookSessionGameSelect(chat)) {
                return
            }
            let dropdownOpen = _.get(this.currentChats[_.get(chat, 'id')], 'gameSelectDropdownOpen', null)
            if (dropdownOpen !== null) {
                Vue.set(this.currentChats[_.get(chat, 'id')], 'gameSelectDropdownOpen', !dropdownOpen)
                this.$nextTick(() => {
                    if (dropdownOpen === false) {
                        let dropdown = _.first(this.$refs['chat-book-session-game-select-dropdown-' + chat.id])
                        if (dropdown) {
                            dropdown.focus()
                        }
                    }
                })
            }
        },
        closeChatBookSessionGameSelectDropdown (chat) {
            let dropdownOpen = _.get(this.currentChats[_.get(chat, 'id')], 'gameSelectDropdownOpen', null)
            if (dropdownOpen !== null) {
                Vue.set(this.currentChats[_.get(chat, 'id')], 'gameSelectDropdownOpen', false)
            }
        },
        getChatCoachGameOptions (chat) {
            let coachObj = _.get(this.coachDict, _.get(chat, 'coachId'), {})
            return Object.keys(_.get(coachObj, 'games', {}))
        },
        getGameThumbnail (gameKey) {
            let srcMap = {
                'leagueoflegends': '/public/media/instacoach/league/game-icon.png',
                'fortnite': '/public/media/instacoach/fortnite/game-icon.png',
                'super-smash-bros-ultimate': '/public/media/instacoach/super-smash-bros-ultimate/game-icon.png',
                'csgo': '/public/media/instacoach/csgo/csgo.png'
            }
            return srcMap[gameKey]
        },
        doShowChatBookSessionGameSelect (chat) {
            let coachObj = _.get(this.coachDict, _.get(chat, 'coachId'), {})
            return Object.keys(_.get(coachObj, 'games', {})).length > 1
        },
        checkChatTabScreenPosition () {

            // Check left most tab to see if its off screen. If it is: remove it and repeat process.
            let instaProX = this.$refs.instacoachWidget.getBoundingClientRect().x
            let leftMessageTabKey = 'message-tab-' + (this.getCurrentChats.length - 1)
            let leftMessageTab = _.first(this.$refs[leftMessageTabKey])

            if (leftMessageTab && leftMessageTab.getBoundingClientRect().x < instaProX) {
                let lastKey = _.get(_.first(this.getCurrentChats), 'id')
                // only close chat tab if it isn't the last remaining one.
                if (this.getCurrentChats.length > 1) {
                    this.closeChat(lastKey)
                    this.$nextTick(() => {
                        this.checkChatTabScreenPosition()
                    })
                }
            }
        },
        initJSEventBus () {
            document.addEventListener('instaproEvent', (e) => {
                let eventType = _.get(e, 'detail.eventType')
                if (eventType === 'openInstaproMessages') {
                    let didCloseMessages = this.closeAllOpenMessages()
                    if (didCloseMessages) {
                        this.openMessages()
                    } else {
                        this.openCloseMessages()
                    }
                }
            })
        },
        checkPaypalRedirect () {
            // Check query string to see if user is coming back from a successful paypal purchase
            let search = window.location.search.substring(1);
            if (search) {
                let query = JSON.parse('{"' + decodeURI(search).replace(/"/g, '\\"').replace(/&/g, '","').replace(/=/g,'":"') + '"}')
                this.redirectCoachId = query.coach
            }
        },
        initializeAudio () {
            this.requestSound = new Audio()
            this.requestSound.src = this.requestSoundFile
            this.requestSound.volume = 0.5

            this.messageSound = new Audio()
            this.messageSound.src = this.messageSoundFile
            this.messageSound.volume = 0.5
        },
        setActiveGame () {
            if (this.startingActiveGame === 'fortnite') {
                this.selectedGame = 'fortnite'
            } else if (this.startingActiveGame === 'leagueoflegends') {
                this.selectedGame = 'leagueoflegends'
            } else if (this.startingActiveGame === 'super-smash-bros-ultimate') {
                this.selectedGame = 'super-smash-bros-ultimate'
            }
            // else if (this.startingActiveGame === 'csgo') {
            //     this.selectedGame = 'csgo'
            // } else if (this.startingActiveGame === 'teamfight-tactics') {
            //     this.selectedGame = 'teamfight-tactics'
            // } else if (this.startingActiveGame === 'overwatch') {
            //     this.selectedGame = 'overwatch'
            // } else if (this.startingActiveGame === 'hearthstone') {
            //     this.selectedGame = 'hearthstone'
            // }
        },
        autoOpenDrawer () {
            let isMobile = window.innerWidth < 500
            if (!isMobile) {
                this.drawerOpen = true
                if (typeof amplitude !== 'undefined') {
                    amplitude.getInstance().logEvent('Auto Open Instapro', {
                        game: this.selectedGame
                    })
                } else {
                    console.log('no amplitude')
                }
            }
        },
        initializeZopim () {
            window.$zopim || (function(d,s){var z=$zopim=function(c){z._.push(c)},$=z.s=
            d.createElement(s),e=d.getElementsByTagName(s)[0];z.set=function(o){z.set.
            _.push(o)};z._=[];z.set._=[];$.async=!0;$.setAttribute("charset","utf-8");
            $.src="//v2.zopim.com/?34QcOsn4KZzGOslEdtXJxKzXn4N3X9c4";z.t=+new Date;$.
            type="text/javascript";e.parentNode.insertBefore($,e)})(document,"script");
            if (window.$zopim) {
                window.$zopim(() => {
                    $zopim.livechat.setName("");
                    $zopim.livechat.setEmail("");
                    $zopim.livechat.hideAll()
                    $zopim.livechat.setStatus('online')
                    $zopim.livechat.addTags('browsing_instapro_' + this.selectedGame)
                    $zopim.livechat.setOnChatStart(() => {
                        $zopim.livechat.window.show()
                    })
                })
            }
        },
        closeNotification (index) {
            this.instaproNotifications.splice(index, 1)
        },
        openNotification (notification, index) {
            // data collection
            if (window.$zopim.livechat) {
                $zopim.livechat.addTags('browsing_instapro_' + this.selectedGame)
            }
            if (typeof amplitude !== "undefined") {
                amplitude.getInstance().logEvent("Open Instapro", {
                    game: this.selectedGame
                })
            } else {
                console.log('no amplitude')
            }
            if (typeof amplitude !== "undefined") {
                amplitude.getInstance().logEvent('Click InstaPRO Push Notification')
            } else {
                console.log('no amplitude')
            }

            if (this.userInSession) {
                this.startInSessionWarning()
            } else {
                if (notification.game !== this.selectedGame) {
                    this.selectGameOption(notification.game)
                }
                this.selectedCoachKey = notification.id
                this.state = 'selecting'
                amplitude.getInstance().logEvent("View Coach Profile", {
                    'game_type': this.selectedGame
                })
                this.loadCoachReviews()
            }
            this.drawerOpen = true
            this.closeNotification(index)
        },
        getNotificationSubject (notification) {
            if (notification.numCoaches === 1) {
                return notification.name
            } else {
                return notification.name + ' and ' + (notification.numCoaches - 1) + ' coaches'
            }
        },
        getNotificationMessage (notification) {
            if (notification.numCoaches === 1) {
                return 'is online!'
            } else {
                return 'are online!'
            }
        },
        getGameIcon (gameName) {
            let map = {
                'leagueoflegends': '/public/media/instacoach/league/game-icon.png',
                'fortnite': '/public/media/instacoach/fortnite/game-icon.png'
            }
            return map[gameName]
        },
        isCoachFavorite (coach) {
            return this.favoritesList.includes(coach.id)
        },
        resetFilters () {
            this.selectedFilterRegions = {}
            this.selectedFilterLanguages = {}
            this.selectedFilterRanks = {}
            this.filterRegionDropdownOpen = false
            this.filterLanguageDropdownOpen = false
            this.filterRankDropdownOpen = false
            this.selectedFilterSpecialties = {}
            this.selectedFilterPrices = {}
        },
        isFilterRegionSelected (key) {
            return this.selectedFilterRegions[key]
        },
        isFilterLanguageSelected (key) {
            return this.selectedFilterLanguages[key]
        },
        isFilterRankSelected (key) {
            return this.selectedFilterRanks[key]
        },
        getRankImageSrc (rank) {
            if (this.selectedGame === 'leagueoflegends' && rank) {
                let league = rank.split(' ')[0].toLowerCase()
                return '/public/media/onboarding/leagueoflegends/' + league + '.png'
            }
        },
        isSpecialtySelected (specialty) {
            return this.selectedFilterSpecialties[specialty]
        },
        selectFilterSpecialty (specialty) {
            if (specialty in this.selectedFilterSpecialties) {
                Vue.delete(this.selectedFilterSpecialties, specialty)
            } else {
                Vue.set(this.selectedFilterSpecialties, specialty, true)
            }
        },
        selectFilterPrice (priceIndex) {
            if (priceIndex in this.selectedFilterPrices) {
                Vue.delete(this.selectedFilterPrices, priceIndex)
            } else {
                Vue.set(this.selectedFilterPrices, priceIndex, true)
            }
        },
        getSpecialtyAbbreviation (specialty) {
            let specialtyMap = {
                'top': 'TOP',
                'ad': 'ADC',
                'support': 'SUP',
                'mid': 'MID',
                'jungle': 'JUN'
            }
            return specialtyMap[specialty]
        },
        getSpecialtyImage (specialty) {
            let map = {
                'top': '/public/media/instacoach/league/roles/top.png',
                'jungle': '/public/media/instacoach/league/roles/jungle.png',
                'mid': '/public/media/instacoach/league/roles/mid.png',
                'support': '/public/media/instacoach/league/roles/support.png',
                'ad': '/public/media/instacoach/league/roles/ad.png',
                'building': '/public/media/instacoach/fortnite/specializations/building.svg',
                'aiming': '/public/media/instacoach/fortnite/specializations/aim.svg',
                'decision': '/public/media/instacoach/fortnite/specializations/decision.svg'
            }
            return map[specialty]
        },
        selectFilterRegion (region, key) {
            if (key in this.selectedFilterRegions) {
                Vue.delete(this.selectedFilterRegions, key)
            } else {
                Vue.set(this.selectedFilterRegions, key, region)
            }
        },
        selectFilterLanguage (language, key) {
            if (key in this.selectedFilterLanguages) {
                Vue.delete(this.selectedFilterLanguages, key)
            } else {
                Vue.set(this.selectedFilterLanguages, key, language)
            }
        },
        selectFilterRank (rank) {
            if (rank in this.selectedFilterRanks) {
                Vue.delete(this.selectedFilterRanks, rank)
            } else {
                Vue.set(this.selectedFilterRanks, rank, true)
            }
        },
        showMoreCoaches () {
            let increment = (this.numOnlineCoachesVisible + this.showCoachesOnlineIncrement) > this.getAvailableCoaches.length ? (this.getAvailableCoaches.length - this.numOnlineCoachesVisible) : this.showCoachesOnlineIncrement
            this.numOnlineCoachesVisible += increment
        },
        showMoreOfflineCoaches () {
            this.fetchOfflineCoaches()
        },
        getRatingStarImage (rating, index) {
            rating = this.convertRating(rating)
            if (index <= rating) {
                return '/public/media/instacoach/ratings/star.svg'
            } else if (index - 0.5 <= rating) {
                return '/public/media/instacoach/ratings/half-star.svg'
            } else {
                return '/public/media/instacoach/ratings/empty-star.svg'
            }
        },
        async init () {
            // Load User
            try {
                await this.loadUserData()
            } catch (e) {
                // User not logged in
            }

            if (this.pgUserId) {
                // Check if User should view onboarding
                axios({
                    method: 'get',
                    url: '/functions/notifications/instapro/check-notification-status.php'
                }).then((response) => {
                    if (_.get(response, 'data.should_display')) {
                        this.userSeenOnboarding = false
                    }
                })
            }


            // Fetch all game options
            await this.fetchGameOptions()

            // Fetch list of coaches and begin polling
            this.startFetchCoaches()


            // Fetch list of favorite coaches and fetch their coach object
            if (this.userLoggedIn) {
                this.fetchFavoriteCoaches()
            }

            // Start polling coaches that are visible to the user
            this.pollVisibleCoaches()
            // Start polling favorite coaches who are online
            this.pollFavoriteOnlineCoaches()

            // Initialize and authenticate chat web socket
            if (this.userLoggedIn) {
                this.initChat()
            }

            // Load Points Store
            this.loadPointsStore()

            // Restore the User's session if they've previously left the page
            if (this.userLoggedIn) {
                this.restoreSessionState()
            }

            // Fetch instapro game types
            this.fetchInstaproGameTypes()
        },
        fetchInstaproGameTypes () {
            this.InstaproGamesData.fetchInstaPROGames().then((response) => {
                response.forEach(game => {
                    Vue.set(this.instaPROGames, game.name, game)
                })
            }).catch((error) => {
                console.log(error)
            })
        },
        fetchFavoriteCoaches () {
            return axios({
                method: 'get',
                url: INSTAPRO_API_URL + 'api/v1/student/favorite',
                headers: {
                    'Authorization': 'Bearer ' + this.instaProAccessToken
                }
            }).then((response) => {
                let list = _.get(response, 'data.result.data')
                this.favoritesList = list.map((obj) => {
                    return obj.coach_id
                })
                for (let i = 0; i < list.length; i++) {
                    this.fetchCoachById(this.favoritesList[i])
                }
                return list
            }).catch((error) => {
                console.log(error)
            })
        },
        fetchCoachById (id) {
            return axios({
                method: 'get',
                url: INSTAPRO_API_URL + 'api/v1/coach/' + id,
                headers: {
                    'Authorization': 'Bearer ' + this.instaProAccessToken
                }
            }).then((response) => {
                let coach = _.get(response, 'data.result')
                this.updateCoaches([coach])
                return response
            }).catch((error) => {
                console.log(error)
            })
        },
        syncUserAccessToken () {
            return new Promise((resolve, reject) => {
                axios({
                    method: 'get',
                    url: '/functions/user/check-login-state',
                }).then((response) => {
                    if (response.status === 200) {
                        let accessToken = _.get(response, 'data.access_token')
                        let refreshToken = _.get(response, 'data.refresh_token')
                        if (accessToken) {
                            window.localStorage.setItem('client_credentials', accessToken)
                        }
                        if (refreshToken) {
                            window.localStorage.setItem('refresh_token', refreshToken)
                        }
                        resolve(accessToken)
                    } else {
                        reject()
                    }
                })
            })
        },
        loadProGuidesUser () {
            return axios({
                method: 'get',
                url: '/api/v2/user/account',
                headers: {
                    'Authorization': 'Bearer ' + window.localStorage.getItem('client_credentials')
                }
            }).then((response) => {
                let userId = _.get(response, 'data.id')
                this.pgUserId = userId
            })
        },
        loadUserStripeCards () {
            // Fetch User's saved Stripe cards
            return axios({
                method: 'get',
                url: '/api/v2/user/account/payment-methods/stripe/sources/cards',
                headers: {
                    'Authorization': 'Bearer ' + window.localStorage.getItem('client_credentials')
                }
            }).then((response) => {
                this.selectedStripeSource = _.get(response, 'data.default_card')
                this.savedStripeSources = _.get(response, 'data.saved_cards') || []
            })
        },
        loadInstaProUser () {
            return axios({
                method: 'get',
                url: '/api/v2/instapro/user/access-token',
                headers: {
                    'Authorization': 'Bearer ' + window.localStorage.getItem('client_credentials')
                }
            }).then((response) => {
                this.instaProAccessToken = _.get(response, 'data.access_token')

                // Check if User is an InstaPRO Coach
                return axios({
                    method: 'get',
                    url: INSTAPRO_API_URL + 'api/v1/user',
                    headers: {
                        'Authorization': 'Bearer ' + this.instaProAccessToken
                    }
                })
            }).then((response) => {
                let isCoach = _.get(response, 'data.result.is_coach')
                if (isCoach) {
                    this.userIsCoach = true
                    $('.coach-only').toggleClass('coach-only', false)
                }
            })
        },
        async loadUserData () {
            await this.syncUserAccessToken()

            return Promise.all([
                this.loadProGuidesUser(),
                this.loadUserStripeCards(),
                this.loadInstaProUser()
            ])
        },
        async restoreSessionState () {
            // Get students requests to see if they have an active session
            let studentRequests = await this.fetchAllPages(INSTAPRO_API_URL + 'api/v1/student/requests', '', [], this.instaProAccessToken)
            let openRequests = studentRequests.reduce((result, obj) => {
                if (['accepted', 'open'].includes(obj.status)) {
                    result.push(obj)
                }
                return result
            }, [])
            if (openRequests === null || openRequests.length <= 0) {
                // console.log('no active requests, moving on..')
                this.checkRedirectCoach()
            } else {
                // SET STATE AS IF STUDENT IS IN SESSION, AND SET THE ACTIVE REQUEST AND ACTIVE COACH ACCORDINGLY
                // There should only be one request
                // console.log('student has an active or pending request', openRequests)
                this.initializeZopim()
                // this.drawerOpen = true

                openRequests.forEach((obj) => {
                    this.mapRequestCoachData(obj).then((response) => {
                        if (obj.status === 'accepted') {
                            this.selectedCoachKey = obj.id
                            this.state = null
                            this.currentRequest.id = obj.id
                            this.currentRequest.coach = response
                            this.currentRequest.type = obj.type
                            this.currentRequest.games = parseInt(obj.value)
                            this.currentRequest.game = _.get(obj, 'game.name')
                            this.currentRequest.communicationMethod = _.first(Object.keys(_.get(obj, 'communication', {})))
                            this.currentRequest.created = moment.utc(obj.updated_at)
                            this.userInSession = true
                        } else if (obj.status === 'open') {
                            this.selectedCoachKey = obj.id
                            this.state = 'waiting'
                            this.startFetchRequestStatus()
                            this.drawerOpen = true
                            this.currentRequest.id = obj.id
                            this.currentRequest.coach = response
                            this.currentRequest.type = obj.type
                            this.currentRequest.games = parseInt(obj.value)
                            this.currentRequest.game = _.get(obj, 'game.name')
                            this.currentRequest.communicationMethod = _.first(Object.keys(_.get(obj, 'communication', {})))
                            this.currentRequest.created = moment.utc(obj.updated_at)
                        }
                    }).catch((error) => {
                        console.log(error)
                    })
                })
            }
        },
        loadPointsStore () {
            // Fetch Point Products
            return axios({
                method: 'get',
                url: '/api/v2/store/products/points'
            }).then((response) => {
                let points = _.get(response, 'data.items')
                let tempPoints = []
                points.forEach((product) => {
                    let tempProduct = {
                        basePoints: product.amount,
                        bonusPoints: product.bonus,
                        bonusPercentage: Math.floor(product.bonus / product.amount * 100),
                        points: product.amount + product.bonus,
                        price: product.price,
                        id: product.id
                    }
                    tempPoints.push(tempProduct)
                })
                this.pointsOptions = tempPoints
            })
        },
        favoriteCoach () {
            if (typeof amplitude !== "undefined") {
                amplitude.getInstance().logEvent('Follows Coach', {
                    frequency: (this.favoritesList || []).length
                })
            } else {
                console.log('no amplitude')
            }
            // Follow coach first, then favorite
            this.favoritingCoach = true
            axios({
                method: 'post',
                url: INSTAPRO_API_URL + 'api/v1/student/follow/',
                headers: {
                    'Authorization': 'Bearer ' + this.instaProAccessToken
                },
                data: {
                    id: this.getSelectedCoach.id
                }
            }).then((response) => {
                // Favorite coach after following them
                return axios({
                    method: 'post',
                    url: INSTAPRO_API_URL + 'api/v1/student/favorite/',
                    headers: {
                        'Authorization': 'Bearer ' + this.instaProAccessToken
                    },
                    data: {
                        id: this.getSelectedCoach.id
                    }
                })
            }).then((response) => {
                this.favoritingCoach = false
                this.favoritesList.push(this.getSelectedCoach.id)
            }).catch((error) => {
                console.log(error)
            })
        },
        unFavoriteCoach () {
            // Follow coach first, then favorite
            this.favoritingCoach = true
            axios({
                method: 'post',
                url: INSTAPRO_API_URL + 'api/v1/student/favorite/',
                headers: {
                    'Authorization': 'Bearer ' + this.instaProAccessToken
                },
                data: {
                    id: this.getSelectedCoach.id
                }
            }).then((response) => {
                // Favorite coach after following them
                return axios({
                    method: 'post',
                    url: INSTAPRO_API_URL + 'api/v1/student/follow/',
                    headers: {
                        'Authorization': 'Bearer ' + this.instaProAccessToken
                    },
                    data: {
                        id: this.getSelectedCoach.id
                    }
                })
            }).then((response) => {
                this.favoritingCoach = false
                let coachIndex = this.favoritesList.indexOf(this.getSelectedCoach.id)
                this.favoritesList.splice(coachIndex, 1)
            }).catch((error) => {
                console.log(error)
            })
        },
        routeToSales () {
            if (typeof amplitude !== "undefined") {
                amplitude.getInstance().logEvent('Clicked Coach Chat Go Pro', {
                    game: this.selectedGame
                })
            } else {
                console.log('no amplitude')
            }
            window.location = '/store/subscriptions'
        },
        openProLockedModal () {
            this.showProLockedModal = true
        },
        startOnboarding () {
            this.state = 'onboarding-1'
            if (typeof amplitude !== "undefined") {
                amplitude.getInstance().logEvent("Reread Onboard")
            } else {
                console.log('no amplitude')
            }
        },
        startHelpChat () {
            if (typeof amplitude !== "undefined") {
                amplitude.getInstance().logEvent("Need Help")
            } else {
                console.log('no amplitude')
            }
            if (window.$zopim.livechat) {
                $zopim.livechat.addTags('clicked_need_help')
                window.$zopim(() => {
                    $zopim.livechat.window.show()
                    // $zopim.livechat.window.onHide(() => {
                    //     $zopim.livechat.hideAll()
                    // })
                })
            }
        },
        convertGameName (key) {
            let map = {
                'leagueoflegends': 'League of Legends',
                'fortnite': 'Fortnite',
                'csgo': 'Counter-Strike: Global Offensive',
                'super-smash-bros-ultimate': 'Super Smash Bros. Ultimate',
                'teamfight-tactics': 'Teamfight Tactics',
                'hearthstone': 'Hearthstone',
                'overwatch': 'Overwatch',
            }
            return map[key] || ''
        },
        coachHasNA (coach) {
            return this.getRegions(coach).includes('NA')
        },
        getRegions (coach) {
            return _.get(coach, 'games.' + this.selectedGame + '.regions', [])
        },
        convertRating (rating) {
            let formattedRating = parseFloat((parseInt(rating) / 20).toFixed(1))
            return formattedRating
        },
        getReviewTimestamp (review) {
            return moment.utc(review.created_at).fromNow()
        },
        coachProfileBioShowLess () {
            this.coachProfileBioClamped = true
            this.coachProfileShowReadMoreButton = true
        },
        coachProfileBioReadMore () {
            this.coachProfileBioClamped = false
            this.coachProfileShowReadMoreButton = false
        },
        reduceGameQuantity () {
            let amt = this.coachSelectionGamesAmount
            this.coachSelectionGamesAmount = amt > 1 ? amt - 1 : amt
        },
        increaseGameQuantity () {
            let amt = this.coachSelectionGamesAmount
            this.coachSelectionGamesAmount = amt < 9 ? amt + 1 : amt
        },
        getCoachSessionTypeHeader (type) {

        },
        getCoachSessionTypeCost (type) {
            // return _.get(this.getSelectedCoach, 'games.' + this.selectedGame + '.achievement_rates.' + type)
            if (type === 'in-game') {
                return ((_.get(this.getCurrentCoachPrices, 'in-game') || 0)  * this.coachSelectionGamesAmount) || 'N/A'
            } else if (type === 'spectate') {
                return ((_.get(this.getCurrentCoachPrices, 'spectate') || 0)  * this.coachSelectionGamesAmount) || 'N/A'
            } else if (type === 'replay') {
                return ((_.get(this.getCurrentCoachPrices, 'replay') || 0)  * this.coachSelectionGamesAmount) || 'N/A'
            } else if (type === '1v1') {
                return ((_.get(this.getCurrentCoachPrices, '1v1') || 0)  * this.coachSelectionGamesAmount) || 'N/A'
            } else if (type === 'all-day-pass') {
                return ((_.get(this.getCurrentCoachPrices, 'all-day-pass') || 0)  * this.coachSelectionGamesAmount) || 'N/A'
            } else {
                return 'N/A'
            }
        },
        watchCurrentSession () {
            clearTimeout(this.watchCurrentSessionTimeoutFunction)
            if (this.userInSession) {
                this.watchCurrentSessionTimeoutFunction = setTimeout(() => {
                    axios({
                        method: 'get',
                        url: INSTAPRO_API_URL + 'api/v1/student/requests/' + this.currentRequest.id,
                        headers: {
                            'Authorization': 'Bearer ' + this.instaProAccessToken
                        }
                    }).then((response) => {
                        // console.log('got request ', response)
                        let requestStatus = _.get(response, 'data.result.status')
                        if (requestStatus === 'finished' && this.userInSession) {
                            this.userInSession = false
                            this.state = 'rate-session'
                            if (window.$zopim.livechat) {
                                $zopim.livechat.addTags('ended_session')
                            }
                        } else {
                            this.watchCurrentSession()
                        }
                    }).catch((error) => {
                        console.log(error)
                        this.watchCurrentSession()
                    })
                }, this.watchCurrentSessionTimeoutDuration)
            }
        },
        getCurrentTime () {
            setTimeout(() => {
                this.currentTime = moment.utc()
                this.getCurrentTime()
            }, 1000)
        },
        urlencodeFormData (fd) {
            var s = ''
            function encode(s) { return encodeURIComponent(s).replace(/%20/g,'+') }
            for(var pair of fd.entries()){
                if(typeof pair[1]=='string'){
                    s += (s?'&':'') + encode(pair[0])+'='+encode(pair[1])
                }
            }
            return s
        },
        mapStatus (status, statusState) {
            let newStatus
            if (status === 'offline') {
                newStatus = 'offline'
            } else {
                if (statusState === 'idle') {
                    newStatus = 'online'
                } else if (statusState === 'busy') {
                    newStatus = 'busy'
                } else if (statusState === 'in-session') {
                    newStatus = 'in-session'
                } else {
                    newStatus = 'offline'
                }
            }
            return newStatus
        },
        checkRedirectCoach () {
            if (this.redirectCoachId) {
                axios({
                    method: 'get',
                    url: INSTAPRO_API_URL + 'api/v1/coach/' + this.redirectCoachId,
                    headers: {
                        'Authorization': 'Bearer ' + this.instaProAccessToken
                    }
                }).then((response) => {
                    // UPDATE COACH LIST HERE WITH RESPONSE OF THIS COACH
                    let coach = _.get(response, 'data.result')
                    this.updateCoaches([coach])
                    this.selectedCoachKey = this.redirectCoachId
                    this.state = 'selecting'
                    this.drawerOpen = true
                    this.redirectCoachId = null
                    this.loadCoachReviews()
                }).catch((error) => {
                    console.log(error)
                })
            }
        },
        fetchAllCoaches () {
            return Promise.all([
                this.fetchAllPages(INSTAPRO_API_URL + 'api/v1/coach', {'status': 'online'}, [], this.instaProAccessToken)
            ]).then((responses) => {
                let coachList = []
                responses.forEach((response) => {
                    coachList.push(...response)
                })

                // Check if there are any coaches in-session that aren't in this list.
                // If there are, it means they are now offline
                this.removeOfflineCoaches(coachList)

                // Do our initial sort of the coaches before the user views the list
                if (!this.doneInitialCoachSort) {
                    coachList = this.sortRawCoaches(coachList)
                    this.doneInitialCoachSort = true
                }
                this.updateCoaches(coachList)
            })
        },
        fetchOfflineCoaches () {
            let currentPage = _.get(this.offlineCoachData, this.selectedGame + '.currentPage', 1)
            let currentGame = _.get(this.gameOptions, this.selectedGame + '.id')
            return axios({
                method: 'get',
                url: INSTAPRO_API_URL + 'api/v1/coach?page=' + currentPage + '&status=offline&games[]=' + currentGame,
                headers: {
                    'Authorization': 'Bearer ' + this.instaProAccessToken
                }
            }).then((response) => {
                Vue.set(this.offlineCoachData[this.selectedGame], 'currentPage', currentPage + 1)
                this.updateCoaches(_.get(response, 'data.result.data', []))
            })
        },
        removeOfflineCoaches (coaches) {
            let newCoachDict = coaches.reduce((result, coach) => {
                result[coach.id] = coach
                return result
            }, {})
            for (let i = 0; i < this.coaches.length; i++) {
                let id = _.get(this.coaches[i], 'id')
                if (!newCoachDict[id]) {
                    Vue.set(this.coachDict[id], 'status', 'offline')
                }
            }
        },
        fetchAllPages (url, queryOptions, currentArray, accessToken) {
            let formattedUrl = new URL(url)
            if (formattedUrl.search) {
                Object.keys(queryOptions).forEach((key) => {
                    formattedUrl += '&' + key + '=' + queryOptions[key]
                })
            } else {
                formattedUrl += '?'
                Object.keys(queryOptions).forEach((key) => {
                    formattedUrl += key + '=' + queryOptions[key] + '&'
                })
                formattedUrl = formattedUrl.substring(0, formattedUrl.length - 1)
            }
            return axios({
                method: 'get',
                url: formattedUrl,
                headers: {
                    'Authorization': 'Bearer ' + accessToken
                }
            }).then((response) => {
                currentArray.push(..._.get(response, 'data.result.data'))
                let nextPage = _.get(response, 'data.result.next_page_url')

                if (nextPage) {
                    // Automatically convert protocol to https
                    nextPage = new URL(nextPage)
                    nextPage.protocol = 'https:'
                    nextPage = nextPage.href
                    return this.fetchAllPages(nextPage, queryOptions, currentArray, accessToken)
                } else {
                    return currentArray
                }
            }).then((response) => {
                if (response) {
                    return response
                }
            })
        },
        // call this every time new coaches are fetched
        // modify coachDict here only
        // send raw unmapped coach data here
        updateCoaches (coachList) {
            coachList.forEach((coachObj) => {
                let coach = this.mapCoachData(coachObj)
                let timeAdded = this.coachAddedPosition
                this.coachAddedPosition += 1
                if (this.coachDict[coach.id]) {
                    // coach's status updated
                    if (this.coachDict[coach.id].status !== coach.status) {
                        let updateOrdering = ['online', 'busy'].includes(this.coachDict[coach.id].status) && !['online', 'busy'].includes(coach.status)
                        updateOrdering = updateOrdering || !['online', 'busy'].includes(this.coachDict[coach.id].status) && ['online', 'busy'].includes(coach.status)

                        // if coach is favorite - check notification cooldown, show accordingly, and update cooldown if necessary
                        if (this.isCoachFavorite(coach) && coach.status === 'online') {
                            this.addFavoriteCoachNotification(coach)
                        }

                        // Fetch PG Price for each new coach
                        axios({
                            method: 'get',
                            url: '/api/v2/instapro/coach/' + coach.id + '/session-pricing'
                        }).then((response) => {
                            let prices = response.data
                            let priceKeys = Object.keys(prices)
                            let coachGameKeys = Object.keys(coach.games)
                            coachGameKeys.forEach((key) => {
                                if (priceKeys.includes(String(coach.games[key].id))) {
                                    coach.games[key].price = prices[coach.games[key].id]
                                    coach.games[key].defaultGameType = this.getDefaultCoachingType(coach.games[key].price)
                                }
                            })
                            let tempCoach = {
                                ...coach
                            }

                            if (updateOrdering) {
                                tempCoach['added'] = timeAdded
                            }
                            Vue.set(this.coachDict, coach.id, tempCoach)
                        }).catch((error) => {
                            console.log(error)
                        })
                    }
                } else { // new coach added to list
                    if (['online', 'busy'].includes(coach.status)) {
                        // if coach is favorite - check notification cooldown, show accordingly, and update cooldown if necessary
                        if (this.isCoachFavorite(coach) && coach.status === 'online') {
                            this.addFavoriteCoachNotification(coach)
                        }
                        // Fetch PG Price for each new coach
                        axios({
                            method: 'get',
                            url: '/api/v2/instapro/coach/' + coach.id + '/session-pricing'
                        }).then((response) => {
                            let prices = response.data
                            let priceKeys = Object.keys(prices)
                            let coachGameKeys = Object.keys(coach.games)
                            coachGameKeys.forEach((key) => {
                                if (priceKeys.includes(String(coach.games[key].id))) {
                                    coach.games[key].price = prices[coach.games[key].id]
                                    coach.games[key].defaultGameType = this.getDefaultCoachingType(coach.games[key].price)
                                }
                            })
                            let tempCoach = {
                                ...coach,
                                added: timeAdded
                            }
                            Vue.set(this.coachDict, coach.id, tempCoach)
                        }).catch((error) => {
                            console.log(error)
                        })
                    } else {
                        // Fetch PG Price for each new coach
                        axios({
                            method: 'get',
                            url: '/api/v2/instapro/coach/' + coach.id + '/session-pricing'
                        }).then((response) => {
                            let prices = response.data
                            let priceKeys = Object.keys(prices)
                            let coachGameKeys = Object.keys(coach.games)
                            coachGameKeys.forEach((key) => {
                                if (priceKeys.includes(String(coach.games[key].id))) {
                                    coach.games[key].price = prices[coach.games[key].id]
                                    coach.games[key].defaultGameType = this.getDefaultCoachingType(coach.games[key].price)
                                }
                            })
                            let tempCoach = {
                                ...coach,
                                added: timeAdded
                            }
                            Vue.set(this.coachDict, coach.id, tempCoach)
                        }).catch((error) => {
                            console.log(error)
                        })
                    }
                }
            })
        },
        addFavoriteCoachNotification (coach) {
            try {
                let instaproNotificationStatus = JSON.parse(window.localStorage.getItem('instaproNotifications'))
                if (!instaproNotificationStatus) {
                    window.localStorage.setItem('instaproNotifications', JSON.stringify({
                        'favoriteCoaches': {}
                    }))
                    instaproNotificationStatus = JSON.parse(window.localStorage.getItem('instaproNotifications'))
                }

                let favoriteCoachNotifications = _.get(instaproNotificationStatus, 'favoriteCoaches')
                if (!favoriteCoachNotifications) {
                    window.localStorage.setItem('instaproNotifications', JSON.stringify({
                        'favoriteCoaches': {}
                    }))
                    instaproNotificationStatus = JSON.parse(window.localStorage.getItem('instaproNotifications'))
                    favoriteCoachNotifications = _.get(instaproNotificationStatus, 'favoriteCoaches')
                }

                let cooldown = _.get(favoriteCoachNotifications, coach.id + '.cooldown')
                if (cooldown && cooldown > moment().unix()) {
                    // dont show notification
                } else {
                    // show notification
                    this.pushInstaproNotification(coach, 50000)
                    if (_.get(instaproNotificationStatus, 'favoriteCoaches.' + coach.id)) {
                        instaproNotificationStatus.favoriteCoaches[coach.id].cooldown = moment().unix() + this.getNotificationCooldownAmount
                    } else {
                        instaproNotificationStatus.favoriteCoaches[coach.id] = {
                            cooldown: moment().unix() + this.getNotificationCooldownAmount
                        }
                    }
                }
                window.localStorage.setItem('instaproNotifications', JSON.stringify(instaproNotificationStatus))
            } catch {
                window.localStorage.setItem('instaproNotifications', JSON.stringify({
                    'favoriteCoaches': {}
                }))
            }
        },
        pushInstaproNotification (coach, duration) {
            let firstGame
            try {
                firstGame = Object.keys(coach.games)[0]
            } catch {
                firstGame = ''
            }
            if (this.instaproNotifications.length === 0) {
                let notification = {
                    name: _.get(coach, 'name'),
                    avatar: _.get(coach, 'avatar'),
                    id: _.get(coach, 'id'),
                    game: firstGame,
                    numCoaches: 1,
                    expires: moment().utc() + duration
                }
                this.instaproNotifications.push(notification)
            } else {
                let notificationPushed = false
                for (let i = 0; i < this.instaproNotifications.length; i++) {
                    // another notification for a game that already has an active notification
                    if (this.instaproNotifications[i].game === firstGame) {
                        let tempNotification = this.instaproNotifications[i]
                        tempNotification.numCoaches += 1
                        Vue.set(this.instaproNotifications, i, tempNotification)
                        notificationPushed = true
                    }
                }
                if (!notificationPushed) {
                    let notification = {
                        name: _.get(coach, 'name'),
                        avatar: _.get(coach, 'avatar'),
                        id: _.get(coach, 'id'),
                        game: firstGame,
                        numCoaches: 1,
                        expires: moment().utc() + duration
                    }
                    this.instaproNotifications.push(notification)
                }
            }
            // start checking notifications for expiration
            this.checkNotifications()
        },
        checkNotifications () {
            this.checkNotificationsTimeoutFunction = setTimeout(() => {
                let now = moment()
                for (let i = this.instaproNotifications.length - 1; i >= 0; i--) {
                    if (this.instaproNotifications[i].expires < now) {
                        this.instaproNotifications.splice(i, 1)
                    }
                }
                this.checkNotifications()
            }, 500)
        },
        clearCurrentRequest () {
            Object.keys(this.currentRequest).forEach((key) => {
                this.currentRequest[key] = null
            })
        },
        pollVisibleCoaches () {
            clearTimeout(this.coachPollingTimeoutFunction)
            this.coachPollingTimeoutFunction = setTimeout(() => {
                if (this.state !== 'in-session' && this.drawerOpen) {
                    for (let i = 0; i < this.getVisibleOnlineCoaches.length; i++) {
                        let id = _.get(this.getVisibleOnlineCoaches[i], 'id')
                        this.fetchCoachById(id)
                    }
                }
                this.pollVisibleCoaches()
            }, this.coachWatcherTimeoutDuration)
        },
        pollFavoriteOnlineCoaches () {
            clearTimeout(this.favoriteCoachPollingTimeoutFunction)
            this.favoriteCoachPollingTimeoutFunction = setTimeout(() => {
                if (this.state !== 'in-session' && this.drawerOpen) {
                    for (let i = 0; i < this.getFavoriteCoachesOnline.length; i++) {
                        let id = _.get(this.getFavoriteCoachesOnline[i], 'id')
                        this.fetchCoachById(id)
                    }
                }
                this.pollFavoriteOnlineCoaches()
            }, this.coachWatcherTimeoutDuration)
        },
        async startFetchCoaches () {
            await this.fetchAllCoaches()
            await this.fetchOfflineCoaches()
            this.fetchCoaches()
        },
        fetchCoaches () {
            clearTimeout(this.fetchCoachesTimeoutFunction)
            this.fetchCoachesTimeoutFunction = setTimeout(() => {
                this.fetchAllCoaches()
                this.fetchCoaches()
            }, this.getFetchCoachesTimeoutDuration)
        },
        async mapRequestCoachData (request) {
            // return coach data with same formatting as mapCoachData
            let status = this.mapStatus(_.get(request, 'coach.status'), _.get(request, 'coach.status_state'))
            let coachId = _.get(request, 'coach_id')
            let coach
            await this.fetchCoachById(coachId).then((response) => {
                coach = _.get(response, 'data.result.coach')
            })
            let gamesObj = {}
            let games = _.get(coach, 'games', [])
            for (let i = 0; i < games.length; i++) {
                let game = games[i]
                let gameKey = game.game ? game.game.name : null
                if (gameKey !== null) {
                    let gameName = this.convertGameName(gameKey)
                    gamesObj[gameKey] = {
                        id: game.game_id,
                        coachGameId: game.id,
                        name: gameName,
                        platforms: game.platforms,
                        regions: game.regions,
                        specialties: game.specializations,
                        username: game.username,
                        rank: game.achievement
                    }
                }
            }
            return axios({
                method: 'get',
                url: '/api/v2/instapro/coach/' + coachId + '/session-pricing'
            }).then((response) => {
                let prices = response.data
                let priceKeys = Object.keys(prices)
                let coachGameKeys = Object.keys(gamesObj)
                coachGameKeys.forEach((key) => {
                    if (priceKeys.includes(String(gamesObj[key].id))) {
                        gamesObj[key].price = prices[gamesObj[key].id]
                    }
                })
                let newCoach = {
                    name: _.get(request, 'coach.user.nickname'),
                    pgId: _.get(request, 'coach.user.pg_id'),
                    id: _.get(request, 'coach_id'),
                    games: gamesObj,
                    status: status,
                    avatar: _.get(request, 'coach.additional.photo') || '/public/media/instacoach/765-default-avatar-530x500.png',
                    rating: _.get(request, 'coach.simple_data.requests.avg') || -1,
                    ratings: _.get(request, 'coach.simple_data.requests.total'),
                    typicalSession: _.get(request, 'coach.coaching_session'),
                    bio: _.get(request, 'coach.introduction'),
                    discord: _.get(request, 'coach.additional.social_media.discord'),
                    skype: _.get(request, 'coach.additional.social_media.skype'),
                    added: moment()
                }
                return newCoach
            }).catch((error) => {
                console.log(error)
            })
        },
        mapCoachData (user) {
            if (user.coach) {
                // create games object for coach
                // key will be game name
                let gamesObj = {}
                for (let i = 0; i < user.coach.games.length; i++) {
                    let game = user.coach.games[i]
                    let gameKey = game.game ? game.game.name : null
                    if (gameKey !== null) {
                        let gameName = this.convertGameName(gameKey)
                        gamesObj[gameKey] = {
                            id: game.game_id,
                            coachGameId: game.id,
                            name: gameName,
                            platforms: game.platforms,
                            regions: game.regions,
                            specialties: game.specializations,
                            username: game.username,
                            rank: game.achievement
                        }
                    }
                }
                let status = this.mapStatus(user.coach.status, user.coach.status_state)
                let reviews = _.get(user, 'coach.simple_data.requests.all')
                reviews = Array.isArray(reviews) ? reviews.reverse() : []
                let newCoach = {
                    name: user.nickname,
                    id: user.id,
                    pgId: user.pg_id,
                    games: gamesObj,
                    status: status,
                    avatar: _.get(user, 'coach.additional.photo') || 'https://d17galhwha3ary.cloudfront.net/assets/instapro/instapro-default-avatar.png',
                    rating: _.get(user, 'coach.simple_data.requests.avg') || -1,
                    ratings: _.get(user, 'coach.simple_data.requests.total'),
                    reviews: reviews,
                    typicalSession: user.coach.coaching_session,
                    bio: user.coach.introduction,
                    discord: _.get(user, 'coach.additional.social_media.discord'),
                    skype: _.get(user, 'coach.additional.social_media.skype')
                }
                return newCoach
            }
            return null
        },
        postRequest () {
            // CHECK WHICH PATH USER IS TAKING HERE
            // if they have a conversation with this coach, open waiting in the chat window instead of modal
            // otherwise, open modal with this.state = 'waiting'
            // let coachPgId = _.get(this.getSelectedCoach, 'pgId')
            // let conversation = Object.values(this.conversations).find((obj) => {
            //     return obj.pgId == coachPgId
            // })
            // let conversationId = _.get(conversation, 'id')
            // console.log('posting request', coachPgId, conversationId, this.conversations[conversationId])
            // if (this.conversations[conversationId]) {
            //     console.log('conversation exists, start waiting in chat window')
            //     this.openChatTab(this.conversations[conversationId])
            //     this.currentChats[conversationId].actionState = 'request-waiting'
            //     this.state = null
            // } else {
            this.state = 'waiting'
            // }

            if (window.$zopim.livechat) {
                $zopim.livechat.addTags('requested_session')
            }
            if (typeof amplitude !== "undefined") {
                amplitude.getInstance().logEvent("Begin Request")
            } else {
                console.log('no amplitude')
            }
            Vue.set(this.getSelectedCoach, 'status', 'busy')
            this.coachUnavailableMessage = ''
            this.coachUnavailable = false
            this.currentRequest.coach = this.getSelectedCoach
            this.currentRequest.game = this.selectedGame
            this.currentRequest.created = moment.utc()
            this.currentRequest.type = this.getSelectedSessionType
            Vue.set(this.currentRequest, 'communicationMethod', this.sessionConfirmationCommunicationMethod)
            let body = new FormData()
            body.append('coach_id', this.getSelectedCoach.id)
            body.append('game_id', this.getSelectedCoach.games[this.selectedGame].id)
            body.append('type', this.getSelectedSessionType)
            let platform
            if (this.shouldShowPlatformDropdown) {
                platform = this.selectedContactInfoPlatform
            } else if (this.selectedGame === 'super-smash-bros-ultimate') {
                platform = 'console'
            } else {
                platform = 'pc'
            }
            let region = this.selectedContactInfoRegion || _.get(this.getSelectedCoach, 'games.' + this.selectedGame + '.regions[0]')
            body.append('platform', platform)
            body.append('message', 'fake message')
            body.append('region', region)
            body.append('total', '1')
            body.append('in_game_username', this.sessionConfirmationInGameUsername)
            let communicationUsername
            if (this.sessionConfirmationCommunicationMethod === 'discord') {
                communicationUsername = this.sessionConfirmationDiscord
            } else if (this.sessionConfirmationCommunicationMethod === 'skype') {
                communicationUsername = this.sessionConfirmationSkype
            }
            body.append('communication_type', this.sessionConfirmationCommunicationMethod)
            body.append('communication_name', communicationUsername)

            axios({
                method: 'post',
                url: '/api/v2/instapro/session-request',
                data: this.urlencodeFormData(body),
                headers: {
                    'Authorization': 'Bearer ' + window.localStorage.getItem('client_credentials'),
                    'X-INSTA-TOKEN': this.instaProAccessToken,
                    'Content-Type': 'application/x-www-form-urlencoded'
                }
            }).then((response) => {
                this.currentRequest.id = _.get(response, 'data.request_id')
                this.startFetchRequestStatus()
                if (typeof amplitude !== "undefined") {
                    amplitude.getInstance().logEvent("Sends Request")
                } else {
                    console.log('no amplitude')
                }
            }).catch((error) => {
                if (_.get(error, 'response.status') === 403) {
                    // insufficient funds
                    this.coachUnavailableMessage = 'Insufficient funds'
                    this.coachUnavailable = true
                } else {
                    this.coachUnavailable = true
                }
            })
        },
        startFetchRequestStatus () {
            this.fetchRequestStatus(0)
        },
        fetchRequestStatus (iterations) {
            clearTimeout(this.fetchRequestStatusTimeoutFunction)
            this.fetchRequestStatusTimeoutFunction = setTimeout(() => {
                axios({
                    method: 'get',
                    url: INSTAPRO_API_URL + 'api/v1/student/requests/' + this.currentRequest.id,
                    headers: {
                        'Authorization': 'Bearer ' + this.instaProAccessToken
                    }
                }).then((response) => {
                    let requestStatus = _.get(response, 'data.result.status')
                    this.fetchRequestStatus(iterations + 1)
                    if (requestStatus === 'accepted') {
                        if (window.$zopim.livechat) {
                            $zopim.livechat.addTags('started_session')
                        }
                        if (typeof amplitude !== "undefined") {
                            amplitude.getInstance().logEvent("Enter Session")
                        } else {
                            console.log('no amplitude')
                        }
                        this.state = null
                        this.dontMinimizeSessionTab = true
                        this.userInSession = true
                        this.requestSound.play()
                        // check new points balance
                        axios({
                            method: 'get',
                            url: '/api/v2/user/resources/pg-points',
                            headers: {
                                'Authorization': 'Bearer ' + window.localStorage.getItem('client_credentials')
                            }
                        }).then((response) => {
                            this.currentPoints = _.get(response, 'data.amount')
                            $('.current-resource').text(this.currentPoints)
                        }).catch((error) => {
                            console.log(error)
                        })
                        clearTimeout(this.fetchRequestStatusTimeoutFunction)
                    } else if (requestStatus === 'rejected') {
                        if (window.$zopim.livechat) {
                            $zopim.livechat.addTags('coach_rejected_request')
                        }
                        this.coachRejected = true
                        this.coachUnavailable = true
                        let rejectionReason = _.get(response, 'data.result.close_reason')
                        clearTimeout(this.fetchRequestStatusTimeoutFunction)
                    } else if (requestStatus === 'closed') {
                        if (window.$zopim.livechat) {
                            $zopim.livechat.addTags('request_timed_out')
                        }
                        this.coachUnavailable = true
                        clearTimeout(this.fetchRequestStatusTimeoutFunction)
                    }
                }).catch((error) => {
                    console.log(error)
                    if (iterations < 30) {
                        this.fetchRequestStatus(iterations + 1)
                    }
                })
            }, this.fetchRequestStatusTimeoutDuration)
        },
        submitSessionInformation () {
            this.validateSessionConfirmationRequest()
            if (!this.sessionConfirmationError) {
                if (this.sessionConfirmationSaveContactInfo) {
                    let leagueoflegendsUsername = this.selectedGame === 'leagueoflegends' ? this.sessionConfirmationInGameUsername : null
                    if (leagueoflegendsUsername) {
                        window.localStorage.setItem('instaProLeagueoflegendsUsername', leagueoflegendsUsername)
                    }

                    let fortniteUsername = this.selectedGame === 'fortnite' ? this.sessionConfirmationInGameUsername : null
                    if (fortniteUsername) {
                        window.localStorage.setItem('instaProFortniteUsername', fortniteUsername)
                    }

                    let csgoUsername = this.selectedGame === 'csgo' ? this.sessionConfirmationInGameUsername : null
                    if (csgoUsername) {
                        window.localStorage.setItem('instaProCSGOUsername', csgoUsername)
                    }

                    let smashUltimateUsername = this.selectedGame === 'super-smash-bros-ultimate' ? this.sessionConfirmationInGameUsername : null
                    if (smashUltimateUsername) {
                        window.localStorage.setItem('instaProSmashUltimateUsername', smashUltimateUsername)
                    }

                    let teamfightTacticsUsername = this.selectedGame === 'teamfight-tactics' ? this.sessionConfirmationInGameUsername : null
                    if (teamfightTacticsUsername) {
                        window.localStorage.setItem('instaProTeamfightTacticsUsername', teamfightTacticsUsername)
                    }

                    let hearthstoneUsername = this.selectedGame === 'hearthstone' ? this.sessionConfirmationInGameUsername : null
                    if (hearthstoneUsername) {
                        window.localStorage.setItem('instaProHearthstoneUsername', hearthstoneUsername)
                    }

                    let overwatchUsername = this.selectedGame === 'overwatch' ? this.sessionConfirmationInGameUsername : null
                    if (overwatchUsername) {
                        window.localStorage.setItem('instaProOverwatchUsername', overwatchUsername)
                    }

                    let discord = this.sessionConfirmationCommunicationMethod === 'discord' ? this.sessionConfirmationDiscord : null
                    let skype = this.sessionConfirmationCommunicationMethod === 'skype' ? this.sessionConfirmationSkype : null
                    if (discord) {
                        window.localStorage.setItem('instaProDiscord', discord)
                    }
                    if (skype) {
                        window.localStorage.setItem('instaProSkype', skype)
                    }

                    if (this.selectedContactInfoRegion) {
                        let localStorageKey = this.selectedGame + '-region'
                        window.localStorage.setItem(localStorageKey, this.selectedContactInfoRegion)
                    }
                    if (this.selectedContactInfoPlatform && this.shouldShowPlatformDropdown) {
                        let localStorageKey = this.selectedGame + '-platform'
                        window.localStorage.setItem(localStorageKey, this.selectedContactInfoPlatform)
                    }
                }
                this.postRequest()
            }
        },
        selectGameOption (game) {
            if (this.state === 'selecting') {
                this.state = null
                this.selectedCoachKey = null
            }
            this.resetFilters()
            this.selectedGame = game
            this.gameSelectDropdownOpen = false
            if (_.get(this.offlineCoachData, this.selectedGame + '.currentPage') === 1) {
                this.fetchOfflineCoaches()
            }
            if (window.$zopim.livechat) {
                $zopim.livechat.addTags('browsing_instapro_' + this.selectedGame)
            }
        },
        clickInstacoachDrawer () {
            this.gameSelectDropdownOpen = false
        },
        selectGame () {
            if (this.userInSession) {
                this.startInSessionWarning()
            } else {
                this.gameSelectDropdownOpen = !this.gameSelectDropdownOpen
            }
        },
        openGuidelines () {
            this.previousOnboardingState = this.state
            this.state = 'guidelines'
        },
        closeGuidelines() {
            this.state = this.previousOnboardingState
        },
        openInstacoachDrawer () {
            this.initializeZopim()
            if (typeof amplitude !== "undefined") {
                amplitude.getInstance().logEvent("Open Instapro", {
                    game: this.selectedGame
                })
            } else {
                console.log('no amplitude')
            }
            this.drawerOpen = true
            if (!this.userSeenOnboarding) {
                // this.state = 'onboarding-1'
                // this.userSeenOnboarding = true
                axios({
                    method: 'get',
                    url: '/functions/notifications/instapro/mark-notification-seen.php'
                }).then((response) => {
                })
            }
        },
        highlightInstacoachDrawer (highlighted) {
            this.drawerHighlighted = highlighted
        },
        onboardingToGuidelines () {
            this.state = 'guidelines'
        },
        startOnboardingAnimation () {
            clearTimeout(this.onboardingAnimationTimeoutFunction)
            this.continueOnboardingAnimation()
        },
        continueOnboardingAnimation () {
            this.onboardingAnimationTimeoutFunction = setTimeout(() => {
                this.onboardingAnimationState = (this.onboardingAnimationState + 1) % 2
                this.continueOnboardingAnimation()
            }, this.onboardingAnimationSpeed)
        },
        onboardingContinue () {
            if (this.state === 'onboarding-1') {
                this.state = 'onboarding-2'
                this.startOnboardingAnimation()
            } else if (this.state === 'onboarding-2') {
                this.state = 'onboarding-3'
                this.startOnboardingAnimation()
            } else {
                this.state = null
                clearTimeout(this.onboardingAnimationTimeoutFunction)
            }
        },
        openCloseCurrentSessionTab () {
            this.currentSessionTabOpen = !this.currentSessionTabOpen
        },
        cancelEndSession () {
            this.closeInSessionWarning()
            this.cancellingSession = false
        },
        startConfirmingEndSession () {
            this.cancellingSession = true
        },
        closeInSessionWarning () {
            this.inSessionWarning = false
        },
        startInSessionWarning () {
            this.inSessionWarning = true
        },
        closeCoachList () {
            if (!this.getDrawerDisabled) {
                if (this.state !== 'in-session') {
                    this.state = null
                }
                this.drawerOpen = false
            }
        },
        submitSessionReport () {
            this.state = 'report-session-success'
        },
        submitSessionRating () {
            let percentageRating = ((100.00 / 5) * this.sessionRating).toFixed(2)
            if (percentageRating <= 0) {
            } else {
                let body = new FormData()
                body.append('rate', percentageRating)
                body.append('comment', this.sessionRatingText)
                axios({
                    method: 'put',
                    url: INSTAPRO_API_URL + 'api/v1/student/requests/' + this.currentRequest.id + '/rate',
                    headers: {
                        'Authorization': 'Bearer ' + this.instaProAccessToken
                    },
                    data: this.urlencodeFormData(body)
                }).then((response) => {
                    // console.log('submitted student rating', response)
                    if (typeof amplitude !== "undefined") {
                        amplitude.getInstance().logEvent("Rate Coach")
                    } else {
                        console.log('no amplitude')
                    }
                }).catch((error) => {
                    console.log(error)
                })
            }
            this.state = 'rate-session-success'
        },
        returnToSessionRating () {
            this.state = 'rate-session'
        },
        checkCoachBioLength () {
            let innerHeight = _.get(this.$refs.commentInner, 'scrollHeight')
            let outerHeight = _.get(this.$refs.commentOuter, 'offsetHeight')
            if (innerHeight > outerHeight) {
                this.coachProfileBioClamped = true
                this.coachProfileShowReadMoreButton = true
            } else {
                this.coachProfileBioClamped = false
                this.coachProfileShowReadMoreButton = false
            }
        },
        loadCoachReviews () {
            let selectedCoach = this.getSelectedCoach
            if (selectedCoach) {
                // Check if reviews have already been loaded or if any changes to the review count were made
                let coachReviews = this.getSelectedCoachReviews
                if (!coachReviews || (coachReviews.length !== selectedCoach.ratings)) {
                    // Fetch reviews for coach
                    axios({
                        method: 'GET',
                        url: INSTAPRO_API_URL + 'api/v1/coach/' + selectedCoach.id + '/ratings',
                        headers: {
                            'Authorization': 'Bearer ' + this.instaProAccessToken
                        }
                    }).then((response) => {
                        let reviews = _.get(response, 'data.result', [])
                        Vue.set(this.coachReviews, selectedCoach.id, reviews.reverse())
                    }).catch((error) => {
                        console.log(error)
                    })
                }
            }
        },
        resetState () {
            // this.clearCurrentRequest()
            this.coachSelectionGamesAmount = 1
            this.coachSelectionSessionTypeGroup = 'session'
            this.coachSelectionSessionType = null
            this.coachProfileBioClamped = true
            this.coachProfileShowReadMoreButton = false
            this.coachUnavailableMessage = ''
            this.sessionRatingText = ''
            this.sessionRating = 0
            this.sessionConfirmationError = ''
            this.inSessionWarning = false
            this.previousState = null
            this.cancellingRequest = false
            this.requestCancelled = false
            this.requestProgressEnded = false
            this.coachUnavailable = false
            this.coachRejected = false
            this.requestProgressTimer = 0
            this.cancellingSession = false
            this.currentSessionTimeElapsed = 0
            clearTimeout(this.requestProgressTimeoutFunction)
            clearTimeout(this.currentSessionTimerTimeoutFunction)
        },
        validateSessionConfirmationRequest () {
            let skypeError = (this.sessionConfirmationCommunicationMethod === 'skype') && (this.sessionConfirmationSkype === '')
            let discordError = false
            let regionError = false
            let platformError = false
            let tempError = ''
            if (this.sessionConfirmationCommunicationMethod === 'discord') {
                let discord = this.sessionConfirmationDiscord
                discordError = (discord === '')
                tempError = discordError ? 'You must enter your discord' : ''
                if (!discordError) {
                    let splits = discord.split('#')
                    if (splits.length !== 2) {
                        discordError = true
                    } else if (splits[0] === '') {
                        discordError = true
                    } else if (splits[1].length !== 4) {
                        discordError = true
                    } else if (!/^[0-9]{4}$/.test(splits[1])) {
                        discordError = true
                    }
                    tempError = discordError ? 'Your discord must be properly formatted like: name#1234' : ''
                }
            }
            if (!this.selectedContactInfoRegion) {
                regionError = true
            }
            if (this.shouldShowPlatformDropdown && !this.selectedContactInfoPlatform) {
                platformError = true
            }
            if (discordError) {
                this.sessionConfirmationError = tempError
            }
            else if (!this.sessionConfirmationInGameUsername || skypeError || regionError || platformError) {
                this.sessionConfirmationError = 'You must fill out all fields'
            } else {
                if (this.getSelectedCoach.status === 'busy') {
                    this.sessionConfirmationCoachBusy = true
                    this.sessionConfirmationError = 'Sorry, this coach is currently responding to another user\'s request.'
                } else if (this.getSelectedCoach.status === 'in-session') {
                    this.sessionConfirmationCoachBusy = true
                    this.sessionConfirmationError = 'Sorry, this coach is currently in another session. Try again later'
                } else {
                    this.sessionConfirmationCoachBusy = false
                    this.sessionConfirmationError = ''
                    this.sessionConfirmationCoachBusy = false
                    this.sessionConfirmationError = ''
                }
            }


        },
        selectSessionConfirmationCommunicationMethod (type) {
            // console.log('select', type)
            this.sessionConfirmationCommunicationMethod = type
        },
        returnToCoach () {
            // console.log('return to coach profile')
            this.selectedCoachKey = this.getSelectedCoach.id
            this.resetState()
            this.state = 'selecting'
            this.loadCoachReviews()
            // console.log(this.getSelectedCoach)
        },
        cancelCoachRequest () {
            // console.log('cancel coach request')
            this.cancellingRequest = true
        },
        confirmCancelCoachRequest () {
            // console.log('confirm cancel coach request')
            this.cancellingRequest = false
            this.requestCancelled = true
        },
        backModal (newState) {
            this.state = newState
        },
        closeModalWeak () {
            console.log('close modal weak')
            if (['selecting'].includes(this.state)) {
                this.state = null
            }
            if (this.state === 'guidelines') {
                this.closeGuidelines()
            }
        },
        closeModal () {
            console.log('closing modal')
            if (this.state !== 'in-session') {
                this.state = null
            } else {
                this.cancellingRequest = false
            }
        },
        getDefaultCoachingType (prices) {
            // Set starting selectedGame index
            if (prices['in-game']) {
                return 0
            } else if (prices['spectate']) {
                return 1
            } else if (prices['replay']) {
                return 2
            }
        },
        selectCoach (coach) {
            // if (this.userInSession) {
            //     this.startInSessionWarning()
            // } else {
            //     this.selectedCoachKey = coach.id
            //     this.state = 'selecting'
            //     amplitude.getInstance().logEvent("View Coach Profile", {
            //         'game_type': this.selectedGame
            //     })
            //     this.loadCoachReviews()
            // }
            this.selectedCoachKey = coach.id
            if (this.coachSelectionSessionTypeGroup === 'passes' && !this.allDayPassAvailable) {
                this.coachSelectionSessionTypeGroup = 'session'
            } else if (this.coachSelectionSessionTypeGroup === 'session' && !this.sessionCoachingAvailable) {
                this.coachSelectionSessionTypeGroup = 'passes'
            }
            this.state = 'selecting'
            amplitude.getInstance().logEvent("View Coach Profile", {
                'game_type': this.selectedGame
            })
            this.loadCoachReviews()
        },
        showRegisterModal () {
            this.state = 'register'
        },
        requestCoach () {
            if (!this.userLoggedIn) {
                this.showRegisterModal()
            } else if (this.userInSession) {
                this.startInSessionWarning()
            } else {
                this.state = 'confirming'
            }
        },
        confirmCoachRequest () {
            this.state = 'confirming-info'
            if (this.selectedGame === 'fortnite') {
                this.sessionConfirmationInGameUsername = window.localStorage.getItem('instaProFortniteUsername')
            } else if (this.selectedGame === 'leagueoflegends') {
                this.sessionConfirmationInGameUsername = window.localStorage.getItem('instaProLeagueoflegendsUsername')
            } else if (this.selectedGame === 'csgo') {
                this.sessionConfirmationInGameUsername = window.localStorage.getItem('instaProCSGOUsername')
            } else if (this.selectedGame === 'super-smash-bros-ultimate') {
                this.sessionConfirmationInGameUsername = window.localStorage.getItem('instaProSmashUltimateUsername')
            } else if (this.selectedGame === 'teamfight-tactics') {
                this.sessionConfirmationInGameUsername = window.localStorage.getItem('instaProTeamfightTacticsUsername')
            } else if (this.selectedGame === 'hearthstone') {
                this.sessionConfirmationInGameUsername = window.localStorage.getItem('instaProHearthstoneUsername')
            } else if (this.selectedGame === 'overwatch') {
                this.sessionConfirmationInGameUsername = window.localStorage.getItem('instaProOverwatchUsername')
            }
            this.sessionConfirmationDiscord = window.localStorage.getItem('instaProDiscord')
            this.sessionConfirmationSkype = window.localStorage.getItem('instaProSkype')

            let savedRegion = window.localStorage.getItem(this.selectedGame + '-region')
            if (this.getContactInfoRegionOptions[savedRegion]) {
                this.selectedContactInfoRegion = savedRegion
            } else {
                this.selectedContactInfoRegion = null
            }

            let savedPlatform = window.localStorage.getItem(this.selectedGame + '-platform')
            if (this.getContactInfoPlatformOptions[savedPlatform]) {
                this.selectedContactInfoPlatform = savedPlatform
            } else {
                this.selectedContactInfoPlatform = null
            }
        },
        reloadPoints () {
            this.state = 'reload-points'
        },
        // confirmCoach () {
        //     this.state = 'waiting'
        //     // axios.post('/student/request')
        //     this.startTimer(30)
        // },
        countdownRequestProgressTimer () {
            // dummy function to start session
            if (this.requestProgressTimer < this.requestProgressMaxTime) {
                this.requestProgressTimeoutFunction = setTimeout(() => {
                    this.requestProgressTimer += (this.requestProgressIncrement / 1000)
                    this.countdownRequestProgressTimer()
                }, this.requestProgressIncrement)
            } else {
                clearTimeout(this.requestProgressTimeoutFunction)
                this.requestProgressEnded = true
                this.coachUnavailable = true
            }
        },
        selectPointsOption (index) {
            this.selectedPointsOptionIndex = index
            this.pointsSelectError = this.selectedPointsOptionIndex === null ? 'You must select a points option' : ''
        },
        selectRatingOption (index) {
            this.selectedRatingOptionIndex = index
        },
        selectPayPal () {
            this.pointsSelectError = this.selectedPointsOptionIndex === null ? 'You must select a points option' : ''
            if (this.pointsSelectError) {
                return
            }
            this.paypalLoading = true
            axios({
                method: 'get',
                url: '/payment/nonrecurring/get-paypal-auth-url?product_ids=' + this.getSelectedPointsOption.id + '&query_string=coach=' + this.getSelectedCoach.id
            }).then((response) => {
                // console.log('paypal response', response)
                if (response.data.status === 'failure') {
                    // console.log('paypal callback failure', response)
                    this.pointsSelectError = 'Sorry, something went wrong.'
                    this.paypalLoading = false
                } else {
                    // console.log('paypal callback success', response)
                    if (typeof amplitude !== "undefined") {
                        amplitude.getInstance().logEvent("Refil Points", {
                            'points_package': this.getSelectedPointsOption.points,
                            'payment_type': 'paypal'
                        })
                    } else {
                        console.log('no amplitude')
                    }
                    window.location = response.data.auth_url
                    // this.paymentType = 'PayPal'
                    // this.state = 'credit-card-success'
                }
            })
        },
        selectCreditCard () {
            this.pointsSelectError = this.selectedPointsOptionIndex === null ? 'You must select a points option' : ''
            if (this.pointsSelectError) {
                return
            }
            this.paymentType = 'Credit Card'

            // If user has any saved cards, route to that screen
            this.state = this.savedStripeSources.length ? 'purchasing--credit-card-select' : 'purchasing--credit-card'
        },
        setupStripe () {
            if (!this.stripe) {
                let stripe = Stripe('pk_live_ihrc2K7oHW0IpL4kOijnDKD1')
                this.stripe = stripe

                // Create an instance of Elements.
                let elements = stripe.elements()

                let applyElementsFieldError = (fieldElement, error) => {
                    fieldElement.toggleClass('shop-creditcard-segment__field--error', !!error)

                    this.creditCardError = error ? error.message : ''
                };

                // Init Stripe Elements.
                let cardNumberElement = elements.create('cardNumber', { style: this.stripeConfig.elementsStyle })
                cardNumberElement.on('change', (event) => applyElementsFieldError($('#card-number-field'), event.error))
                this.stripeCreditCardElements.cardNumber = cardNumberElement

                let cardCvcElement = elements.create('cardCvc', { style: this.stripeConfig.elementsStyle })
                cardCvcElement.on('change', (event) => applyElementsFieldError($('#cvv-field'), event.error))
                this.stripeCreditCardElements.cvv = cardCvcElement

                let cardExpiryElement = elements.create('cardExpiry', { style: this.stripeConfig.elementsStyle })
                cardExpiryElement.on('change', (event) => applyElementsFieldError($('#expiry-field'), event.error))
                this.stripeCreditCardElements.expirationDate = cardExpiryElement
            }
        },
        selectStripeCard (card) {
            this.selectedStripeSource = card.id
        },
        async submitStripeCardForm () {
            if (this.stripe) {
                this.loadingCreditCard = true
                try {
                    // Check if User is using an existing Source of or User is adding a new one
                    if (this.state === 'purchasing--credit-card-select') {
                        // Charge existing source
                        await this.chargeStripeSource(this.selectedStripeSource, 'source')
                    } else if (this.state === 'purchasing--credit-card') {

                        // Other Stripe elements' data should be retrievable from one element so long as they originate from the same elements object
                        let cardElement = this.stripeCreditCardElements.cardNumber

                        // Include additional user data
                        let tokenData = {
                            name: this.stripeCardholderName,
                            address_zip: this.stripeCardPostalCode,
                            address_country: this.stripeCardCountry
                        }

                        let tokenResponse = await this.stripe.createToken(cardElement, tokenData)
                        if (tokenResponse.error) {
                            // Inform the user if there was an error
                            this.creditCardError = tokenResponse.error.message
                        } else {
                            // Send the token to your server
                            await this.chargeStripeSource(tokenResponse.token.id, 'token')
                        }
                    }
                } catch (e) {
                    this.creditCardError = _.get(e, 'message', 'Sorry, something went wrong.')
                } finally {
                    this.loadingCreditCard = false
                }
            }
        },
        chargeStripeSource (sourceId, sourceType) {
            let body = new FormData()
            body.append('product_ids[]', this.getSelectedPointsOption.id)
            body.append('description', this.getSelectedPointsOption.points + ' PG Points')

            if (sourceType === 'token') {
                body.append('auth_token', sourceId)
                body.append('save_source', this.stripeSaveSource ? 1 : 0)
            } else if (sourceType === 'source') {
                body.append('source_id', sourceId)
            } else {
                console.log('Invalid Stripe source type specified')
                return
            }

            return axios({
                method: 'POST',
                url: '/payment/nonrecurring/stripe-callback',
                data: body
            }).then((response) => {
                if (typeof amplitude !== "undefined") {
                    amplitude.getInstance().logEvent("Refil Points", {
                        'points_package': this.getSelectedPointsOption.points,
                        'payment_type': 'cc'
                    })
                }

                if (response.data.status === 'failure') {
                    this.creditCardError = _.get(response, 'data.message', 'Sorry, something went wrong.')
                } else {
                    this.state = 'credit-card-success'
                    this.currentPoints += this.getSelectedPointsOption.points
                    $('.current-resource').text(this.currentPoints);
                }

                // Re-fetch sources in the case one was added to the Customer
                this.loadUserStripeCards()
            })
        },
        confirmCancelSession () {
            axios({
                method: 'POST',
                url: '/api/v2/instapro/session-request/' + this.currentRequest.id + '/finish',
                headers: {
                    'Authorization': 'Bearer ' + this.getPgUserToken,
                    'X-INSTA-TOKEN': this.instaProAccessToken,
                    'Content-Type': 'application/x-www-form-urlencoded'
                }
            }).then((response) => {
                if (window.$zopim.livechat) {
                    $zopim.livechat.addTags('ended_session')
                }
                if (typeof amplitude !== "undefined") {
                    amplitude.getInstance().logEvent("User Ends Session")
                } else {
                    console.log('no amplitude')
                }
            }).catch((error) => {
                console.log(error)
            })
            this.userInSession = false
            this.state = 'rate-session'
        },
        endSession () {
            this.cancellingSession = true
        },
        getCoachBusyStatus (coach) {
            if (coach.status === 'offline') {
                return 'Offline'
            } else if (coach.status === 'in-session') {
                return 'In Session'
            }
        },
        filterRegions (coaches) {
            if (this.areFilterRegionsSelected) {
                coaches = coaches.filter((coach) => {
                    let regionExists = (obj) => {
                        return _.get(coach, 'games.' + this.selectedGame + '.regions', []).includes(obj)
                    }
                    return Object.keys(this.selectedFilterRegions).some(regionExists)
                })
            }
            return coaches
        },
        filterRanks (coaches) {
            if (this.areFilterRanksSelected) {
                coaches = coaches.filter((coach) => {
                    let rank = _.get(coach, 'games.' + this.selectedGame + '.rank')
                    return Object.keys(this.selectedFilterRanks).includes(rank)
                })
            }
            return coaches
        },
        filterSpecialties (coaches) {
            if (this.areFilterSpecialtiesSelected) {
                coaches = coaches.filter((coach) => {
                    let specialtyExists = (obj) => {
                        let coachGameSpecialties = _.get(coach, 'games.' + this.selectedGame + '.specialties') || []
                        return coachGameSpecialties.includes(obj)
                    }
                    return Object.keys(this.selectedFilterSpecialties).some(specialtyExists)
                })
            }
            return coaches
        },
        filterPrices (coaches) {
            if (this.areFilterPricesSelected) {
                coaches = coaches.filter((coach) => {
                    let coachPrices = Object.values(_.get(coach, 'games.' + this.selectedGame + '.price'))
                    let coachMin = Math.min(...coachPrices)
                    let coachMax = Math.max(...coachPrices)
                    for (let i = 0; i < this.getSelectedFilterPrices.length; i++) {
                        if (coachMin >= this.getSelectedFilterPrices[i].min && coachMax <= this.getSelectedFilterPrices[i].max) {
                            return coach
                        }
                    }
                })
            }
            return coaches
        },
        filterSearchQuery (coaches) {
            if (this.searchQueryValue) {
                let searchVal = this.searchQueryValue.toLowerCase()
                coaches = coaches.filter((obj) => {
                    let valid = false
                    let coachName = obj.name.toLowerCase()
                    let coachRank = _.get(obj, 'games.' + this.selectedGame + '.rank').toLowerCase()
                    let coachRoles = _.get(obj, 'games.' + this.selectedGame + '.specialties', []) || []
                    if (coachName.includes(searchVal)) {
                        valid = true
                    } else if (coachRank.includes(searchVal)) {
                        valid = true
                    } else {
                        for (let i = 0; i < coachRoles.length; i++) {
                            if (coachRoles[i].toLowerCase().includes(searchVal)) {
                                valid = true
                            }
                        }
                    }
                    return valid
                })
            }
            return coaches
        },
        filterCoaches (coaches) {
            let filteredCoaches = coaches
            // Coaches with selected regions
            filteredCoaches = this.filterRegions(filteredCoaches)
            filteredCoaches = this.filterRanks(filteredCoaches)
            filteredCoaches = this.filterSpecialties(filteredCoaches)
            filteredCoaches = this.filterPrices(filteredCoaches)
            filteredCoaches = this.filterSearchQuery(filteredCoaches)

            return filteredCoaches
        },
        showRankImage (coach) {
            return this.getRankImageSrc(_.get(coach, 'games.' + this.selectedGame + '.rank'))
        },
        sortRawCoaches (coaches) {
            // Sort primarily by coach's rating, with some randomness thrown in
            let sortedCoaches = coaches.sort((a, b) => {
                let aVal = _.get(a, 'coach.simple_data.requests.avg')
                let bVal = _.get(b, 'coach.simple_data.requests.avg')

                // introduce randomness
                let random = (Math.random() * 2) - 1

                // randomness is exponential so it is less likely to have any effect
                aVal += (10 * Math.pow(random, 3))

                if (aVal < bVal) {
                    return 1
                } else if (aVal > bVal) {
                    return -1
                } else if (aVal === bVal) {
                    return 0
                }
            })
            return sortedCoaches
        }
    },
    computed: {
        getContactInfoRegionOptions () {
            let coachRegions = _.get(this.getSelectedCoach, 'games.' + this.selectedGame + '.regions')
            let mappedRegions = {}
            coachRegions.forEach((region) => {
                mappedRegions[region] = this.getGameRegionOptions[region]
            })
            return mappedRegions
        },
        getContactInfoPlatformOptions () {
            if (this.shouldShowPlatformDropdown) {
                let coachPlatforms = _.get(this.getSelectedCoach, 'games.' + this.selectedGame + '.platforms')
                let mappedPlatforms = {}
                let platformOptions = {
                    'console': { name: 'Console' },
                    'pc': { name: 'PC' }
                }
                coachPlatforms.forEach((platform) => {
                    mappedPlatforms[platform] = platformOptions[platform]
                })
                return mappedPlatforms
            }
        },
        shouldShowPlatformDropdown () {
            return ['fortnite', 'overwatch'].includes(this.selectedGame)
        },
        getLoginHref () {
            return '/login' + '?from=' + window.location.pathname
        },
        getRegisterHref () {
            return '/register' + '?from=' + window.location.pathname
        },
        shouldShowCoachChatButton () {
            return this.showCoachChatButton && this.userLoggedIn
        },
        getNumOfflineCoaches () {
            if (this.selectedGame === 'leagueoflegends' || this.selectedGame === 'fortnite') {
                return 49
            } else {
                return this.getOfflineCoaches.length
            }
        },
        getSessionUnit () {
            if (this.selectedGame === 'super-smash-bros-ultimate') {
                return 'Session'
            } else {
                return 'Game'
            }
        },
        isMessagingEnabled () {
            return ![null, undefined].includes(this.pgUserId)
        },
        getSelfPgId () {
            return this.selfPgId
            // return this.testUserId
        },
        getSelfUsername () {
            return this.selfUsername
        },
        getSelfAvatar () {
            return this.selfAvatar
        },
        getUserToken () {
            // return this.testAccessToken
            return this.getPgUserToken
        },
        getPgUserToken () {
            return this.pgAccessToken || window.localStorage.getItem('client_credentials') || ''
        },
        getChatUsers () {
            return this.chatUsers
        },
        getFilteredConversations () {
            if (this.searchMessagesQueryValue === '') {
                return this.getConversations
            }
            return Object.values(this.conversations).filter((obj) => {
                let username = _.get(obj, 'name', '').toLowerCase()
                let search = (this.searchMessagesQueryValue || '').toLowerCase()
                return username.includes(search)
            })
        },
        getConversations () {
            return Object.values(this.conversations).sort((a, b) => {
                let aTime = _.get(a, 'lastReceivedAt')
                let bTime = _.get(b, 'lastReceivedAt')
                if (aTime < bTime) {
                    return 1
                } else if (aTime > bTime) {
                    return -1
                } else {
                    return 0
                }
            })
        },
        getCurrentChats () {
            return Object.values(this.currentChats).filter((obj) => {
                return obj.visible
            }).sort((a, b) => {
                if (a.added < b.added) {
                    return -1
                } else if (a.added > b.added) {
                    return 1
                } else {
                    return 0
                }
            })
        },
        getNotificationCooldownAmount () {
            return 600
        },
        areFiltersSelected () {
            return this.areFilterRegionsSelected || this.areFilterLanguagesSelected || this.areFilterRanksSelected || this.areFilterSpecialtiesSelected || this.areFilterPricesSelected
        },
        areFilterRegionsSelected () {
            return Object.keys(this.selectedFilterRegions).length > 0
        },
        areFilterLanguagesSelected () {
            return Object.keys(this.selectedFilterLanguages).length > 0
        },
        areFilterRanksSelected () {
            return Object.keys(this.selectedFilterRanks).length > 0
        },
        areFilterSpecialtiesSelected () {
            return Object.keys(this.selectedFilterSpecialties).length > 0
        },
        areFilterPricesSelected () {
            return Object.keys(this.selectedFilterPrices).length > 0
        },
        getPriceOptions () {
            let trueMin = _.get(this.InstaproGamesData.INSTAPRO_PRICES[this.selectedGame], 'min')
            let trueMax = _.get(this.InstaproGamesData.INSTAPRO_PRICES[this.selectedGame], 'max')
            let priceOptions = []
            for (let i = 0; i < 4; i++) {
                let increment = ((trueMax - trueMin) / 4)
                priceOptions.push({
                    numPriceIcons: i + 1,
                    min: trueMin + (increment * i),
                    max: trueMin + (increment * (i + 1))
                })
                if (i === 0) {
                    priceOptions[i].min = 0
                }
                if (i === 3) {
                    priceOptions[i].max = 99999
                }
            }
            return priceOptions
        },
        getSelectedFilterPrices () {
            return this.getPriceOptions.reduce((result, obj, index) => {
                if (Object.keys(this.selectedFilterPrices).includes(index.toString())) {
                    result.push(obj)
                }
                return result
            }, [])
        },
        getGameRegionOptions () {
            if (this.selectedGame in this.instaPROGames) {
                let gameRegions = {}
                let availableRegions = this.instaPROGames[this.selectedGame].regions || []
                availableRegions.forEach(region => {
                    gameRegions[region] = { name: _.get(this.InstaproGamesData.GAME_LABELS, [this.selectedGame, 'regions', region], region) }
                })
                return gameRegions
            }
            return {
                'NA': {name: 'North America'},
                'EU': {name: 'Europe'},
                'BR': {name: 'Brazil'},
                'JP': {name: 'Japan'},
                'OCE': {name: 'Oceania'},
                'KR': {name: 'Korea'}
            }
        },
        getGameRankOptions () {
            return _.get(this.instaPROGames, this.selectedGame + '.achievements', [])
        },
        getSpecializationOptions () {
            return _.get(this.instaPROGames, this.selectedGame + '.specializations', [])
        },
        getLanguageOptions () {
            return this.InstaproGamesData.INSTAPRO_LANGUAGES
        },
        showShowMore () {
            return this.getAvailableCoaches.length > this.numOnlineCoachesVisible
        },
        showShowMoreOffline () {
            return _.get(this.offlineCoachData, this.selectedGame + '.showShowMore', false)
        },
        getShowMoreAmount () {
            let notShown = this.getAvailableCoaches.length - this.numOnlineCoachesVisible
            return notShown > this.showCoachesOnlineIncrement ? this.showCoachesOnlineIncrement : notShown
        },
        getFetchCoachesTimeoutDuration () {
            if (this.drawerOpen) {
                return this.fetchCoachesTimeoutDuration
            } else {
                return this.fetchCoachesTimeoutDurationSlow
            }
        },
        getFavoriteCoachesOnline () {
            return this.getFavoriteCoaches.filter((obj) => {
                return obj.status === 'online' || obj.status === 'busy'
            })
        },
        getFavoriteCoaches () {
            return this.getGameFilteredCoaches.filter((obj) => {
                return this.favoritesList.includes(obj.id)
            }).sort((a, b) => {
                if (a.status === 'online') {
                    return -1
                } else if (b.status === 'online') {
                    return 1
                }

                if (a.status === 'offline') {
                    return 1
                } else if (b.status === 'offline') {
                    return -1
                }
            })
        },
        oneVsOneAvailable () {
            return _.get(this.getCurrentCoachPrices, '1v1')
        },
        inGameAvailable () {
            return _.get(this.getCurrentCoachPrices, 'in-game')
        },
        spectateAvailable () {
            return _.get(this.getCurrentCoachPrices, 'spectate')
        },
        replayAvailable () {
            return _.get(this.getCurrentCoachPrices, 'replay')
        },
        allDayPassAvailable () {
            return _.get(this.getCurrentCoachPrices, 'all-day-pass')
        },
        sessionCoachingAvailable () {
            return this.oneVsOneAvailable || this.inGameAvailable || this.spectateAvailable || this.replayAvailable
        },
        getCoachSessionTypeGroups () {
            let groups = []
            if (this.sessionCoachingAvailable) {
                groups.push({
                    'type': 'session',
                    'label': 'Sessions',
                    'isNew': false
                })
            }

            if (this.allDayPassAvailable) {
                groups.push({
                    'type': 'passes',
                    'label': 'All-Day Pass',
                    'isNew': true
                })
            }

            return groups
        },
        getInSessionTimeEstimate () {
            if (this.currentRequest.type === 'replay') {
                return 30 * this.getCurrentRequestGames + 'min'
            } else {
                return this.getCurrentGameDurationEstimate
            }
        },
        getSessionTimeText () {
            if (this.currentRequest.type === 'replay') {
                return 'Time Limit for Replay Analysis'
            } else {
                return 'Recommended Time for ' + this.getCurrentRequestGames + ' Game' + ((this.getCurrentRequestGames > 1) ? 's' : '')
            }
        },
        getGameMinimumTime () {
            if (this.selectedGame === 'leagueoflegends') {
                return '15'
            } else if (this.selectedGame === 'fortnite') {
                return '10'
            } else if (this.selectedGame === 'csgo') {
                return '15'
            } else if (this.selectedGame === 'super-smash-bros-ultimate') {
                return '15'
            } else if (this.selectedGame === 'teamfight-tactics') {
                return '15'
            } else if (this.selectedGame === 'overwatch') {
                return '15'
            } else if (this.selectedGame === 'hearthstone') {
                return '15'
            } else {
                return '15'
            }
        },
        getSelectedCoachingType () {
            return ![undefined, null].includes(this.coachSelectionSessionType) ? this.coachSelectionSessionType : this.getSelectedCoach.games[this.selectedGame].defaultGameType
        },
        getSelectedSessionType () {
            if (this.getSelectedCoachingType === 0) {
                return 'in-game'
            } else if (this.getSelectedCoachingType === 1) {
                return 'spectate'
            } else if (this.getSelectedCoachingType === 2) {
                return 'replay'
            } else if (this.getSelectedCoachingType === 3) {
                return '1v1'
            } else if (this.getSelectedCoachingType === 4) {
                return 'all-day-pass'
            }
        },
        getSelectedSessionTypeCost () {
            if (this.getSelectedCoachingType === 0) {
                return this.getCoachSessionTypeCost('in-game')
            } else if (this.getSelectedCoachingType === 1) {
                return this.getCoachSessionTypeCost('spectate')
            } else if (this.getSelectedCoachingType === 2) {
                return this.getCoachSessionTypeCost('replay')
            } else if (this.getSelectedCoachingType === 3) {
                return this.getCoachSessionTypeCost('1v1')
            } else if (this.getSelectedCoachingType === 4) {
                return this.getCoachSessionTypeCost('all-day-pass')
            }
        },
        getCoachReplayAnalysisDuration () {
            return '30min'
        },
        getCurrentGameDurationEstimate () {
            if (this.selectedGame === 'leagueoflegends') {
                return '30-45min'
            } else if (this.selectedGame === 'fortnite') {
                return '20-30min'
            } else if (this.selectedGame === 'csgo') {
                return '40-50min'
            } else if (this.selectedGame === 'super-smash-bros-ultimate') {
                return '30-45min'
            } else {
                return '30-40min'
            }
        },
        getCoach1v1GameCount () {
            if (this.selectedGame === 'leagueoflegends') {
                return 3
            } else if (this.selectedGame === 'fortnite') {
                return 5
            } else if (this.selectedGame === 'super-smash-bros-ultimate') {
                return 4
            } else {
                return 1
            }
        },
        getCoach1v1DurationEstimate () {
            if (this.selectedGame === 'leagueoflegends') {
                return '30min'
            } else if (this.selectedGame === 'fortnite') {
                return '15min'
            } else if (this.selectedGame === 'super-smash-bros-ultimate') {
                return '20min'
            } else {
                return '20min'
            }
        },
        coaches () {
            let coaches = Object.values(this.coachDict)
            return coaches.sort((a, b) => {
                if (a.added > b.added) {
                    return 1
                } else if (a.added < b.added) {
                    return -1
                }
                return 0
            })
        },
        userLoggedIn () {
            return this.instaProAccessToken && this.pgUserId
        },
        playNowDisabled () {
            return (this.notEnoughPoints || (this.getSelectedCoach.status !== 'online')) && this.userLoggedIn
        },
        getCurrentGameName () {
            return this.convertGameName(this.selectedGame) || 'your game client'
        },
        getSessionEstimatedTime () {
            if (this.selectedGame === 'leagueoflegends') {
                let time = moment().startOf('day')
                    .minutes(30 * this.getCurrentRequestGames)
                    .format('H:mm:ss');
                return time
            }
        },
        getCurrentRequestGames () {
            return this.currentRequest.games
        },
        getInSessionCoaches () {
            return this.getGameFilteredCoaches.filter(obj => {
                // exclude favorite coaches from this list
                return !this.favoritesList.includes(obj.id)
            }).filter(obj => {
                return obj.status === 'in-session'
            })
        },
        getAllOnlineCoaches () {
            return this.coaches.filter(obj => {
                return obj.status !== 'offline'
            })
        },
        getOnlineCoaches () {
            return this.getAvailableCoaches.concat(this.getInSessionCoaches)
        },
        getOfflineCoaches () {
            return this.getGameFilteredCoaches.filter(obj => {
                // exclude favorite coaches from this list
                return !this.favoritesList.includes(obj.id)
            }).filter(obj => {
                return obj.status === 'offline'
            })
        },
        getAvailableCoaches () {
            return this.getGameFilteredCoaches.filter(obj => {
                return ['online', 'busy'].includes(obj.status)
            })
        },
        getVisibleOnlineCoaches () {
            return this.getAvailableCoaches.filter(obj => {
                // exclude favorite coaches from this list
                return !this.favoritesList.includes(obj.id)
            }).slice(0, this.numOnlineCoachesVisible)
        },
        getGameFilteredCoaches () {
            let filteredCoaches = this.coaches.filter(obj => {
                if (obj.games) {
                    return Object.keys(obj.games).includes(this.selectedGame)
                }
                return obj.game === this.selectedGame
            })

            return this.filterCoaches(filteredCoaches)
        },
        modalOpen () {
            let isOpen = this.onCoachProfile || this.showOnboarding || this.cancellingSession || ['selecting', 'guidelines', 'confirming', 'confirming-info', 'reload-points', 'purchasing--credit-card-select', 'purchasing--credit-card', 'credit-card-success', 'shouldShowCancelSessionModal', 'rate-session', 'rate-session-success', 'report-session', 'report-session-success', 'register'].includes(this.state)
            $('body').toggleClass('instapro__modal-open', isOpen)
            return isOpen
        },
        getUsername () {
            return "";
        },
        getModalDark () {
            return this.showOnboarding || this.state === 'guidelines'
        },
        showOnboarding () {
            return ['onboarding-1', 'onboarding-2', 'onboarding-3'].includes(this.state)
        },
        getCurrentSessionTimeElapsed () {
            let seconds = 0
            if (this.currentRequest.created) {
                seconds = this.currentTime.unix() - this.currentRequest.created.unix()
            }
            let date = moment().startOf('day')
                .seconds(seconds)
                .format('H:mm:ss')

            return date
        },
        getCurrentSessionTabOpen () {
            return this.currentSessionTabOpen && !this.cancellingSession
        },
        shouldShowCurrentSessionTab () {
            return this.userInSession
        },
        shouldShowInSessionWarning () {
            return this.userInSession && this.inSessionWarning
        },
        shouldShowCancelSessionModal () {
            return this.userInSession && this.cancellingSession
        },
        getNumCoachesOnline () {
            return this.getAllOnlineCoaches.length > 99 ? '99+' : this.getAllOnlineCoaches.length
        },
        isWaitingForCoach () {
            return this.state === 'waiting' && !(this.requestCancelled || this.requestProgressEnded || this.coachUnavailable)
        },
        getDiscordSkypePlaceholder () {
            if (this.sessionConfirmationCommunicationMethod === 'skype') {
                return 'Enter your skype username'
            } else if (this.sessionConfirmationCommunicationMethod === 'discord') {
                return 'Enter your discord username'
            }
        },
        getInGameUsernameLabel () {
            let map = {
                'leagueoflegends': 'Summoner Name',
                'fortnite': 'Fortnite Username',
                'super-smash-bros-ultimate': 'Smash Username',
                'overwatch': 'Battlenet Username',
                'teamfight-tactics': 'Summoner Name',
                'hearthstone': 'Battlenet Username',
                'csgo': 'Steam Username'
            }
            return map[this.selectedGame] || 'Username'
        },
        getRequestTimeRemaining () {
            return Math.floor(this.requestProgressMaxTime - this.requestProgressTimer)
        },
        onCoachProfile () {
            return ['selecting', 'waiting', 'unavailable'].includes(this.state)
        },
        getCurrentCoachPrices () {
            return _.get(this.getSelectedCoach.games[this.selectedGame], 'price') || null
        },
        notEnoughPoints () {
            return this.getSelectedSessionTypeCost > this.currentPoints
        },
        getCoachCostDifference () {
            return Number(this.getSelectedSessionTypeCost - this.currentPoints).toLocaleString()
        },
        getSelectedCoach () {
            return this.coachDict[this.selectedCoachKey] || this.currentRequest.coach
        },
        getSelectedCoachReviews () {
            let selectedCoach = this.getSelectedCoach
            let coachId = _.get(this.getSelectedCoach, 'id')
            return _.get(this.coachReviews, coachId, [])
        },
        getDrawerDisabled () {
            return (!['selecting'].includes(this.state)
                && this.state !== null
                && !(this.state === 'waiting' && (this.coachUnavailable || this.requestCancelled))
                && !(this.state === 'in-session'))
        },
        getSelectedPointsOption () {
            return this.pointsOptions[this.selectedPointsOptionIndex]
        },
        getRequestProgressBarPosition () {
            return `transform: translateX(` + (((this.requestProgressTimer / this.requestProgressMaxTime) * 100 - 100).toFixed(2)) + `%)`
        }
    }
})
</script>
<script>
    $(function() {
        $('#footer-contact-us').on('click', function(e) {
            e.preventDefault();
            $("#contact-us-modal").modal("show");
        });

        $('#footer-partners-contact').on('click', function(e) {
            e.preventDefault();
            $("#partner-modal").modal("show");
        });

        $('#signup-banner-free').on('click', function(e) {
            if (typeof amplitude !== 'undefined') {
                amplitude.getInstance().logEvent('Signup Banner Join Free', {
                    'page': window.location.pathname
                })
            }
            window.location = '/register?from=' + window.location.pathname
        });
        $('#signup-banner-pro').on('click', function(e) {
            if (typeof amplitude !== 'undefined') {
                amplitude.getInstance().logEvent('Signup Banner Go Pro', {
                    'page': window.location.pathname
                })
            }
            window.location = '/checkout'
        });
                    if (typeof amplitude !== 'undefined') {
                amplitude.getInstance().logEvent('View Signup Banner', {
                    'page': window.location.pathname
                })
            }
            });
    </script>
</div>
</footer>
</div>
</div>
<script type="text/javascript">window.NREUM||(NREUM={});NREUM.info={"beacon":"bam.nr-data.net","licenseKey":"89e9936178","applicationID":"272879472","transactionName":"YwdRYkUDCERYARYPDlpNZkReTRZFUBQDBRhrElxaXgEfGUkKEg==","queueTime":0,"applicationTime":11,"atts":"T0BSFA0ZG0o=","errorBeacon":"bam.nr-data.net","agent":""}</script>

</body></html>